<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>33èŠå¤©å®¤</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Long+Cang&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap');
        /* --- 1. å…¨å±€ä¸ä¸»é¢˜ --- */
        :root {
            --theme-color-1: #F4E8DD; /* å¥¶æ²¹æ */
            --theme-color-2: #EDD4D8; /* æŸ”ç²‰ */
            --theme-color-3: #CCD4CC; /* ç°ç»¿ */
            --theme-color-4: #B5BFCF; /* é›¾è“ */
            /* --- é¢œè‰²ä¿®æ”¹ --- */
            --accent-color: #A7C7E7; /* å¼ºè°ƒè‰²-æµ…è“ */
            --accent-color-deep: #88A9D1; /* æ·±ä¸€ç‚¹çš„æµ…è“ */
            /* --- é¢œè‰²ä¿®æ”¹ç»“æŸ --- */
            --text-color-dark: #5D534A; /* æ·±æ£• */
            --text-color-medium: #7E746D;
            --text-color-light: #A39B94;
            --text-color-white: #FFFFFF;
            --bg-main: #F7F8FA; /* æ”¹ä¸ºæŸ”å’Œçš„æµ…ç°è‰²èƒŒæ™¯ */
            --bg-light: rgba(255, 255, 255, 0.7);
            --border-color: rgba(0, 0, 0, 0.08);
            --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 6px 20px rgba(0, 0, 0, 0.1);
            --font-main: "SimSun", "å®‹ä½“", serif; /* å…¨å±€å­—ä½“ï¼Œé»˜è®¤æ¥·ä½“ */
            --font-title: "Kaiti", "æ¥·ä½“", serif;
            --font-bubble: "LXGW WenKai Screen", "Kaiti", "æ¥·ä½“", serif; /* æ°”æ³¡å­—ä½“ï¼Œé»˜è®¤æ¥·ä½“ */
            --font-inner-voice: "Long Cang", cursive; /* å¿ƒå£°å­—ä½“ï¼Œé»˜è®¤é¾™è—ä½“ */
            --font-essay: "Long Cang", cursive; /* éšç¬”å­—ä½“ï¼Œé»˜è®¤é¾™è—ä½“ */
            --font-bubble-size: 0.95rem; /* ä½¿ç”¨CSSå˜é‡ */
            --unread-bg: #ff4d4d;
            --red-packet-red: #DB5445;
            --red-packet-gold: #F8D69A;
            
            /* --- æ–°å¢ï¼šæ°”æ³¡ä¸»é¢˜åŒ–å˜é‡ --- */
            --player-bubble-bg: var(--accent-color); /* æˆ‘çš„æ¶ˆæ¯èƒŒæ™¯è‰² (Aç±»æ°”æ³¡) */
            --friend-bubble-bg: var(--text-color-white);  /* å¥½å‹æ¶ˆæ¯èƒŒæ™¯è‰² (Aç±»æ°”æ³¡) */
            --player-bubble-text-color: var(--text-color-dark); /* æˆ‘çš„æ¶ˆæ¯å­—ä½“é¢œè‰² */
            --friend-bubble-text-color: var(--text-color-dark);  /* å¥½å‹æ¶ˆæ¯å­—ä½“é¢œè‰² */
        }
        @keyframes paw-pulse { /* æ–°å¢ */
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
/* --- å¼€å±åŠ¨ç”»æ ·å¼ (å‚è€ƒæ ·å¼) --- */
#splash-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-main);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    transition: opacity 0.5s ease-out;
}
#splash-screen.hidden {
    opacity: 0;
    pointer-events: none;
}
.splash-logo {
    font-family: 'ZCOOL KuaiLe', cursive; /* ä½¿ç”¨å‚è€ƒæ–‡ä»¶å­—ä½“ */
    font-size: 36px; /* å‚è€ƒæ–‡ä»¶å­—ä½“å¤§å° */
    color: var(--accent-color-2); /* ä½¿ç”¨å‚è€ƒæ–‡ä»¶é¢œè‰²é£æ ¼ï¼Œæ˜ å°„åˆ°å½“å‰ä¸»é¢˜ */
    margin-bottom: 20px;
}
.splash-loader {
    width: 50px;
    height: 50px;
    border: 3px solid var(--theme-color-2); /* è¾¹æ¡†é¢œè‰²æ˜ å°„ */
    border-top-color: var(--accent-color); /* é¡¶éƒ¨é¢œè‰²æ˜ å°„ */
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* ç§»é™¤ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: var(--font-main);
            color: var(--text-color-dark);
        }

    body {
        background: var(--bg-main);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: var(--font-main); /* åº”ç”¨å…¨å±€å­—ä½“ */
    }

        #app-container {
            width: 100%;
            height: 100%;
            max-width: 500px;
            background-color: var(--bg-light);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: var(--shadow-medium);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #main-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            display: flex;
        }

        /* --- 2. é¡µé¢åˆ‡æ¢ä¸å¸ƒå±€ --- */
        .page {
            display: none;
            flex-grow: 1;
            flex-direction: column;
            overflow: hidden;
            animation: fadeIn 0.4s ease-in-out;
        }
        .page.active {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        .page-header {
            padding: 15px 10px;
            display: grid;
            grid-template-columns: 50px 1fr auto; /* è°ƒæ•´å³ä¾§ä¸ºè‡ªé€‚åº”å®½åº¦ */
            align-items: center;
            background: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative;
        }
        .page-header h1 {
            font-family: var(--font-title);
            font-size: 1.3rem; /* å‡å°å­—ä½“å¤§å° */
            /* ç§»é™¤ç»å¯¹å®šä½å’Œå˜æ¢ï¼Œç”±çˆ¶çº§wrapperæ§åˆ¶ */
        }
        .page-header .header-icon {
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--text-color-medium);
            z-index: 2;
        }

        .page-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            -webkit-overflow-scrolling: touch;
        }
        .page-content::-webkit-scrollbar {
            width: 4px;
        }
        .page-content::-webkit-scrollbar-thumb {
            background: var(--theme-color-4);
            border-radius: 2px;
        }
        
        /* --- 3. åº•éƒ¨å¯¼èˆªæ  --- */
        #bottom-nav {
            display: flex;
            width: 100%;
            background-color: var(--bg-light);
            border-top: 1px solid var(--border-color);
            padding: 8px 0;
            flex-shrink: 0;
        }
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-color-light);
            transition: color 0.3s, transform 0.3s;
        }
        .nav-item:hover {
            color: var(--accent-color);
        }
        .nav-item.active {
            color: var(--accent-color-deep);
            transform: scale(1.1);
        }
        .nav-item i {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }
        .nav-item span {
            font-size: 0.75rem;
        }

        /* --- 4. æ¶ˆæ¯åˆ—è¡¨é¡µé¢ --- */
        #page-messages .page-header {
            padding: 10px 15px;
        }
        #my-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            border: 2px solid var(--text-color-white);
            box-shadow: var(--shadow-light);
        }
        .message-list {
            list-style: none;
            padding: 0;
        }
        .message-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-bottom: 1px solid var(--border-color);
        }
        .message-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        .item-avatar {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .item-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .item-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 6px;
        }
        .item-last-msg {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .item-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-left: 10px;
            flex-shrink: 0;
        }
        .item-time {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-bottom: 8px;
        }
        .unread-badge {
            background-color: var(--unread-bg);
            color: white;
            font-size: 0.7rem;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 6px;
        }
        /* --- 4.1 é¡µé¢å¤´éƒ¨å›¾æ ‡è°ƒæ•´ --- */
        #header-link-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.05);
            color: var(--text-color-medium);
            display: flex;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            justify-self: end;
            margin-right: 15px;
            transition: all 0.2s;
        }
        #header-link-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }

        .page-header .header-icon {
            font-size: 1.2rem; /* ç¼©å°å›¾æ ‡ */
            padding: 0 10px; /* è°ƒæ•´ç‚¹å‡»åŒºåŸŸ */
        }
        /* å°†å³ä¾§å›¾æ ‡æ¨åˆ°æœ€å³è¾¹ */
        .page-header .header-icon:last-child {
            justify-self: end;
            padding-right: 15px; /* å¢åŠ å³è¾¹è· */
        }
        /* --- 4.2. åº•éƒ¨ä¸Šç§»æ ·å¼ --- */
        #app-container.bottom-offset-active {
            padding-bottom: 30px; /* ä¸ºç³»ç»Ÿå¯¼èˆªæ ç•™å‡ºç©ºé—´ */
            height: calc(100% - 30px); /* ç›¸åº”åœ°è°ƒæ•´é«˜åº¦ */
        }
        /* --- 5. é€šè®¯å½•é¡µé¢ --- */
        .tabs {
            display: flex;
            justify-content: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-btn {
            padding: 8px 20px;
            cursor: pointer;
            border-radius: 20px;
            background-color: transparent;
            border: 1px solid transparent;
            color: var(--text-color-medium);
            transition: all 0.3s;
        }
        .tab-btn.active {
            background-color: var(--text-color-white);
            border-color: var(--theme-color-2);
            color: var(--accent-color-deep);
            font-weight: bold;
            box-shadow: var(--shadow-light);
        }
        .contact-section {
            display: none;
        }
        .contact-section.active {
            display: block;
        }
        .contact-list-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 5px;
            color: var(--text-color-light);
        }
        .sort-btn {
            cursor: pointer;
            font-size: 0.9rem;
        }
        .contact-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .contact-item-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-4);
        }
        .contact-item-name {
            flex-grow: 1;
            font-size: 1.1rem;
        }
        .contact-info-btn {
            font-size: 1.2rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px;
        }

        /* --- 6. è®¾ç½®é¡µé¢ --- */
        .settings-list {
            padding-top: 10px;
        }
        .setting-item {
            display: flex;
            align-items: center;
            padding: 18px 15px;
            background-color: var(--text-color-white);
            margin: 0 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .setting-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-light);
        }
        .setting-item i {
            font-size: 1.3rem;
            color: var(--accent-color);
            margin-right: 15px;
            width: 25px;
            text-align: center;
        }
        .setting-item span {
            font-size: 1.1rem;
            flex-grow: 1;
        }
        .setting-item .fa-chevron-right {
            color: var(--text-color-light);
            font-size: 1rem;
        }

        /* --- 7. èŠå¤©é¡µé¢ --- */
        #page-chat .page-header .header-title {
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 1.1rem; /* æ–°å¢ï¼šç¼©å°å­—ä½“å¤§å° */
        }
        .header-title-wrapper {
            grid-column: 2 / 3; /* å æ®ä¸­é—´æ  */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* é˜²æ­¢å†…å®¹æº¢å‡º */
        }
        .typing-indicator-container {
            font-size: 0.75rem; /* è¿›ä¸€æ­¥è°ƒå° */
            color: var(--text-color-medium);
            display: none; /* Initially hidden */
            margin-top: 1px; /* å¾®è°ƒä¸æ ‡é¢˜çš„é—´è· */
        }
        .chat-area {
            flex-grow: 1;
            padding: 20px 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            /* å…³é”®ä¿®å¤ï¼šè®©èŠå¤©åŒºåŸŸæ‹¥æœ‰è‡ªå·±çš„èƒŒæ™¯ï¼Œè€Œä¸æ˜¯é€æ˜ */
            background-color: var(--theme-color-1); 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        /* --- æ–°å¢ï¼šèŠå¤©èƒŒæ™¯å®¹å™¨ --- */
        #app-container {
            /* ... (ä¿ç•™åŸæœ‰æ ·å¼) */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed; /* å…³é”®ï¼šä½¿èƒŒæ™¯å›ºå®šä¸æ»šåŠ¨ */
        }
        
        /* --- æ–°å¢ï¼šä¸»é¢˜è®¾ç½®å¼¹çª—å†…æ ·å¼ (å‚è€ƒ èŠå¤©èƒŒæ™¯ä¸Šä¼ .html) --- */
        .theme-settings-modal .form-group {
            margin-bottom: 25px;
        }

        .theme-settings-modal .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--form-label-color, #555);
        }

        .theme-settings-modal .background-upload-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 15px;
            border: 1px dashed var(--border-color);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.5);
        }

        .theme-settings-modal .background-preview {
            width: 150px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }

        .theme-settings-modal .cover-preview {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }
        
        .theme-settings-modal .color-input-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .theme-settings-modal .color-input-group input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch { border: 2px solid var(--border-color); border-radius: 8px; }

        .message-row {
            display: flex;
            max-width: 80%;
            width: -webkit-fit-content;
            width: -moz-fit-content;
            width: fit-content;
        }
        .message-row.sent {
            align-self: flex-end;
            flex-direction: row-reverse;
        }
        .message-row.received {
            align-self: flex-start;
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .message-avatar.group-avatar-style {
            border-radius: 12px; /* æ–¹å½¢åœ†è§’ */
        }
        .message-row.sent .message-avatar {
            margin-left: 10px;
        }
        .message-row.received .message-avatar {
            margin-right: 10px;
        }
        .message-content {
            display: flex;
            flex-direction: column;
        }
        .message-row.sent .message-content {
            align-items: flex-end;
        }
        .message-row.received .message-content {
            align-items: flex-start;
        }
        .message-name {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 5px;
            padding: 0 5px;
        }
    .bubble {
        padding: 8px 12px;
        border-radius: 16px;
        word-break: break-word;
        font-family: var(--font-bubble); /* åº”ç”¨æ°”æ³¡å­—ä½“ */
        font-size: var(--font-bubble-size, 0.95rem); /* ä½¿ç”¨CSSå˜é‡ */
        line-height: 1.4;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        border: none; /* ç§»é™¤é»˜è®¤è¾¹æ¡†ï¼Œç”±å…·ä½“æ ·å¼æ§åˆ¶ */
    }
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* --- é»˜è®¤æ°”æ³¡æ ·å¼ (Aç±», è¾¹æ¡†å˜è‰²) --- */
        #app-container.app-bubble-style-default .bubble {
            background: white; /* å›ºå®šèƒŒæ™¯ä¸ºç™½è‰² */
            color: var(--text-color-dark); /* å›ºå®šæ–‡å­—é¢œè‰²ä¸ºæ·±è‰² */
        }
        #app-container.app-bubble-style-default .bubble.received {
            border: 1px solid var(--friend-bubble-bg); /* è¾¹æ¡†é¢œè‰²ç”±å˜é‡æ§åˆ¶ */
            border-top-left-radius: 5px;
        }
        #app-container.app-bubble-style-default .bubble.sent {
            border: 1px solid var(--player-bubble-bg); /* è¾¹æ¡†é¢œè‰²ç”±å˜é‡æ§åˆ¶ */
            border-top-right-radius: 5px;
        }
        #app-container.app-bubble-style-default .message-row.sent .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--player-bubble-bg); 
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .message-row.received .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--friend-bubble-bg);
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-default .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }


        /* --- ç«‹ä½“3Dæ°”æ³¡æ ·å¼ (Aç±») --- */
        #app-container.app-bubble-style-3d .bubble {
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            border-bottom-width: 3px;
            border-bottom-style: solid;
        }
        #app-container.app-bubble-style-3d .bubble.received {
            background: var(--friend-bubble-bg);
            color: var(--friend-bubble-text-color);
            border-color: rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-3d .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-color: rgba(0,0,0,0.2);
        }


        /* --- å¯çˆ±æ¡çº¹ (Bç±») --- */
        #app-container.app-bubble-style-stripey .bubble {
            background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);
            color: #a3505f;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-stripey .voice-wave-bar { background-color: #a3505f; }

        /* --- æ¸å˜å½©è™¹ (Bç±», åŠ¨ç”») --- */
        @keyframes gradientBG {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
        }
        #app-container.app-bubble-style-gradient .bubble {
            background: linear-gradient(45deg, #ff9a9e, #fad0c4, #a1c4fd, #c2e9fb, #ff9a9e);
            background-size: 300% 300%;
            animation: gradientBG 8s ease infinite;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        #app-container.app-bubble-style-gradient .voice-wave-bar { background-color: white; }

        /* --- æ‰‹ç»˜æ¶‚é¸¦ (Bç±») --- */
        #app-container.app-bubble-style-doodle .bubble {
            border: 2px solid #333;
            border-radius: 15px 10px 15px 12px;
            background: white;
            color: #333;
            box-shadow: 3px 3px 0px #ccc;
        }
        #app-container.app-bubble-style-doodle .bubble.sent {
            border-radius: 10px 15px 12px 15px;
        }
        #app-container.app-bubble-style-doodle .quote-block {
            border-left-width: 2px;
            border-left-style: dashed;
            background-color: #f7f7f7;
        }
        #app-container.app-bubble-style-doodle .voice-wave-bar { background-color: #333; }

        /* --- æ‰‹ç»˜æ¶‚é¸¦2 (Bç±») --- */
        #app-container.app-bubble-style-hand-drawn .bubble {
            background: white; border: 3px solid #333; position: relative;
            box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: 'Comic Sans MS', cursive;
            color: #333;
        }
        #app-container.app-bubble-style-hand-drawn .bubble.received { border-radius: 0 20px 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .bubble.sent { border-radius: 20px 0 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .voice-wave-bar { background-color: #333; }

        /* --- æ‹Ÿæ€ (Aç±») --- */
        #app-container.app-bubble-style-neumorphic .bubble {
            background: var(--friend-bubble-bg);
            border-radius: 20px;
            box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff;
            color: var(--friend-bubble-text-color);
            border: none;
        }
        #app-container.app-bubble-style-neumorphic .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            box-shadow: inset 6px 6px 12px #b8b9be, inset -6px -6px 12px #fff;
        }
        #app-container.app-bubble-style-neumorphic .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-neumorphic .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }

        /* --- æŸ”å’Œæ¡çº¹ (Aç±») --- */
        #app-container.app-bubble-style-stripes .bubble {
            background-color: var(--friend-bubble-bg);
            background-image: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.2),
                rgba(255, 255, 255, 0.2) 15px,
                rgba(255, 255, 255, 0.1) 15px,
                rgba(255, 255, 255, 0.1) 30px
            );
            color: var(--friend-bubble-text-color);
            border: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
         #app-container.app-bubble-style-stripes .bubble.sent {
            background-color: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
        }

        /* --- ç½‘æ ¼ (Aç±») - ä¿®å¤ --- */
        #app-container.app-bubble-style-grid .bubble {
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 15px 15px;
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 80%, transparent); /* å¢åŠ é€æ˜åº¦ */
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--friend-bubble-text-color);
        }
         #app-container.app-bubble-style-grid .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent); /* å¢åŠ é€æ˜åº¦ */
            color: var(--player-bubble-text-color);
        }

        /* --- å¯çˆ±é£ (Aç±», è¾¹æ¡†å˜è‰²) --- */
        #app-container.app-bubble-style-cute .bubble {
            background: transparent;
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-cute .bubble.received {
            border: 2px solid var(--friend-bubble-bg);
            border-radius: 25px 25px 25px 5px;
        }
        #app-container.app-bubble-style-cute .bubble.sent {
            border: 2px solid var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-radius: 25px 25px 5px 25px;
        }

        /* --- æ¯›ç»ç’ƒ (Aç±») --- */
        #app-container.app-bubble-style-frosted-glass .bubble {
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-frosted-glass .bubble.received {
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 60%, transparent); /* å¢åŠ ä¸é€æ˜åº¦ */
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-frosted-glass .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 60%, transparent); /* å¢åŠ ä¸é€æ˜åº¦ */
            color: var(--player-bubble-text-color);
        }

        /* --- å‘å…‰æœå†» (Bç±») --- */
        #app-container.app-bubble-style-glow-jelly .bubble.received {
            background: linear-gradient(135deg, #00c9ff, #92fe9d);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 201, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }
        #app-container.app-bubble-style-glow-jelly .bubble.sent {
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #app-container.app-bubble-style-glow-jelly .voice-wave-bar { background-color: white; }
        #app-container.app-bubble-style-glow-jelly .bubble.received .voice-wave-bar { background-color: black; }

        /* --- é‡‘å±è´¨æ„Ÿ (Bç±») --- */
        #app-container.app-bubble-style-metal .bubble {
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0); border: 1px solid #a0a0a0;
            color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1), inset 0 1px 3px rgba(255,255,255,0.8);
            position: relative; overflow: hidden;
            border-radius: 16px; /* åŸºç¡€åœ†è§’ */
        }
        #app-container.app-bubble-style-metal .bubble.received { border-top-left-radius: 5px; } /* å°–è§’ */
        #app-container.app-bubble-style-metal .bubble.sent { border-top-right-radius: 5px; } /* å°–è§’ */

        #app-container.app-bubble-style-metal .bubble::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(to bottom right, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 45%, rgba(255,255,255,0) 55%, rgba(255,255,255,0.2) 100%);
            transform: rotate(30deg);
        }
        #app-container.app-bubble-style-metal .voice-wave-bar { background-color: #333; }
        
        /* --- æµ·æ´‹é£ (Bç±», å¸¦å°–è§’) --- */
        #app-container.app-bubble-style-ocean .bubble {
            background: linear-gradient(160deg, #0077b6, #00b4d8);
            color: white;
            border: 2px solid transparent; /* åŒ¹é…å¯çˆ±é£å°ºå¯¸ï¼Œä½†é€æ˜ */
            border-radius: 16px;
            position: relative;
        }
        #app-container.app-bubble-style-ocean .bubble.received { border-bottom-left-radius: 5px; }
        #app-container.app-bubble-style-ocean .bubble.sent { border-bottom-right-radius: 5px; }

        /* --- çŒ«çˆªé£ (Bç±») --- */
        #app-container.app-bubble-style-paw .bubble.received {
            background: #fce1cb;
            color: #8b5e34;
            border: none;
            border-radius: 20px 20px 20px 5px;
        }
        #app-container.app-bubble-style-paw .bubble.sent {
            background: #cbe7fc;
            color: #345c8b;
            border: none;
            border-radius: 20px 20px 5px 20px;
        }
        #app-container.app-bubble-style-paw .bubble::before {
            content: 'ğŸ¾';
            position: absolute;
            bottom: -10px;
            font-size: 1.5rem;
            opacity: 0.2;
        }
        #app-container.app-bubble-style-paw .bubble.received::before { left: 10px; }
        #app-container.app-bubble-style-paw .bubble.sent::before { right: 10px; }
        #app-container.app-bubble-style-paw .voice-wave-bar { background-color: #8b5e34; }
        #app-container.app-bubble-style-paw .bubble.sent .voice-wave-bar { background-color: #345c8b; }
        
        /* --- å¤é£ (Bç±») --- */
        #app-container.app-bubble-style-ancient .bubble.received {
            background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-ancient .bubble.sent {
            background: #d7ccc8; color: #4e342e; border: 2px solid #795548;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }

        /* --- å›½é£ (Bç±») --- */
        #app-container.app-bubble-style-chinese .bubble {
            border-radius: 0;
            clip-path: polygon(0 10px, 10px 0, calc(100% - 10px) 0, 100% 10px, 100% calc(100% - 10px), calc(100% - 10px) 100%, 10px 100%, 0 calc(100% - 10px));
        }
        #app-container.app-bubble-style-chinese .bubble.received {
            background: white; border: 1px solid #c81e1e; color: #c81e1e;
        }
        #app-container.app-bubble-style-chinese .bubble.sent {
            background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;
        }
        #app-container.app-bubble-style-chinese .voice-wave-bar { background-color: #f9d56e; }
        #app-container.app-bubble-style-chinese .bubble.received .voice-wave-bar { background-color: #c81e1e; }

        /* --- æ‹Ÿæ€2 (Bç±», æ•ˆæœå›ºå®š) - æ–°å¢ --- */
        #app-container.app-bubble-style-neumorphic-2 .bubble {
            background: #F0F0F3;
            font-weight: 500;
            color: #888;
            text-shadow: 1px 1px 1px #fff;
            border: 1px solid rgba(0,0,0,0.05);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.received {
            border-radius: 25px 25px 25px 5px; /* åº”ç”¨å°–è§’ */
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.sent {
            border-radius: 25px 25px 5px 25px; /* åº”ç”¨å°–è§’ */
             box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.9), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }

        /* --- å¼•ç”¨å’Œè¯­éŸ³æ¶ˆæ¯çš„é€šç”¨é€‚é… --- */
        .quote-block {
            padding: 8px 12px;
            border-left: 3px solid; /* é¢œè‰²ç”±çˆ¶çº§æ ·å¼å†³å®š */
            background-color: rgba(0, 0, 0, 0.04); /* æ–°å¢ï¼šæµ…ç°è‰²èƒŒæ™¯ */
            line-height: 1.4;
            font-size: 0.85em;
            border-radius: 8px;
            color: var(--text-color-dark); /* æ–°å¢ï¼šç¡®ä¿æ–‡å­—é¢œè‰² */
        }
        .quote-block .quoted-name { font-weight: bold; }

        .voice-duration {
            font-size: 0.8rem;
            color: var(--text-color-medium); /* é»˜è®¤é¢œè‰² */
            margin-right: 10px;
            font-weight: bold;
        }
        .voice-wave {
            display: flex;
            align-items: center;
            height: 20px;
            flex-grow: 1;
            justify-content: flex-end;
        }
        .voice-wave-bar {
            width: 3px;
            background-color: var(--theme-color-4); /* é»˜è®¤é¢œè‰² */
            margin: 0 2px;
            border-radius: 2px;
            animation: voiceWave 1.5s infinite ease-in-out;
            transform-origin: bottom;
        }
        @keyframes voiceWave {
            0%, 100% { transform: scaleY(0.4); }
            50% { transform: scaleY(1.0); }
        }
        .voice-wave-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .voice-wave-bar:nth-child(2) { height: 12px; animation-delay: 0.2s; }
        .voice-wave-bar:nth-child(3) { height: 16px; animation-delay: 0.4s; }
        .voice-wave-bar:nth-child(4) { height: 12px; animation-delay: 0.6s; }
        .voice-wave-bar:nth-child(5) { height: 8px; animation-delay: 0.8s; }

        /* --- å‰©ä½™åŸºç¡€æ ·å¼ä¿æŒä¸å˜ --- */
        .bubble-emoji {
            background: none !important; border: none !important; box-shadow: none !important; padding: 0;
            max-width: 120px; overflow: hidden;
        }
        .bubble-emoji img { max-width: 100%; display: block; border-radius: 12px; }
        .bubble.quote-message-bubble { display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble { max-width: 120px; max-height: 120px; padding: 3px; display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble img { max-width: 100%; border-radius: 8px; display: block; background-color: var(--theme-color-1); }
        .bubble.image-with-desc-bubble .description-text { display: none; padding: 0 4px; font-size: 0.9rem; line-height: 1.5; color: var(--text-color-dark); }
        .bubble.voice-message-bubble {
            display: flex;
            align-items: center;
            padding: 12px 16px !important; /* ä½¿ç”¨ !important å¼ºåˆ¶è¦†ç›–ä¸»é¢˜æ ·å¼ */
            background-color: white !important; /* ä½¿ç”¨ !important å¼ºåˆ¶è¦†ç›–ä¸»é¢˜æ ·å¼ */
            border-radius: 18px !important; /* ä½¿ç”¨ !important å¼ºåˆ¶è¦†ç›–ä¸»é¢˜æ ·å¼ */
            border: 1px solid var(--theme-color-1) !important; /* ä½¿ç”¨ !important å¼ºåˆ¶è¦†ç›–ä¸»é¢˜æ ·å¼ */
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            z-index: 1;
            min-width: 80px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05) !important; /* ä½¿ç”¨ !important å¼ºåˆ¶è¦†ç›–ä¸»é¢˜æ ·å¼ */
        }
        .bubble.voice-message-bubble:hover {
            background-color: #f9f9f9 !important;
        }
        .message-row.sent .voice-duration { color: var(--player-bubble-text-color); }
        .message-row.received .voice-duration { color: var(--friend-bubble-text-color); }
        .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }
        .message-row.received .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        .bubble-and-tag-wrapper { position: relative; display: flex; flex-direction: column; align-items: flex-start; }
        .message-row.sent .bubble-and-tag-wrapper { align-items: flex-end; }
        .voice-transcript { position: absolute; top: calc(100% + 5px); left: 0; width: max-content; max-width: 250px; background: #e6f7ff; border: 1px dashed #91d5ff; color: #03a9f4; border-radius: 10px; padding: 8px 12px; font-size: 0.85rem; z-index: 5; display: none; word-wrap: break-word; }
        .voice-transcript.show { display: block; }
        .message-row.sent .voice-transcript { left: auto; right: 0; }
        .bubble-retracted { background: #e0e0e0; font-style: italic; color: #888; animation: retract 0.5s ease-in-out forwards; }
        .retract-button-wrapper { position: absolute; bottom: calc(100% + 5px); z-index: 5; animation: popIn 0.2s ease-out; background: rgba(0, 0, 0, 0.7); border-radius: 15px; padding: 4px; gap: 4px; display: none; }
        .message-row.sent .retract-button-wrapper { right: 0; }
        .message-row.received .retract-button-wrapper { left: 0; }
        .retract-button-wrapper.show { display: flex; }
        .retract-btn { background: transparent; color: white; border: none; border-radius: 12px; padding: 6px 12px; font-size: 0.8rem; cursor: pointer; transition: background 0.2s; display: flex; align-items: center; gap: 5px; }
        .retract-btn:hover { background: rgba(255, 255, 255, 0.2); }
        @keyframes retract { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.8); opacity: 0; } }
        /* AI Typing Indicator Bubble */
        .bubble-typing { display: flex; gap: 5px; align-items: center; padding: 10px 15px; background: var(--text-color-white); border: 1px solid var(--theme-color-2); border-top-left-radius: 5px; }
        .typing-dot { width: 8px; height: 8px; background-color: var(--text-color-light); border-radius: 50%; animation: typing-pulse 1.4s infinite ease-in-out both; }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing-pulse { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }

        .time-divider, .retracted-notice, .system-notice {
            align-self: center;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
        }

        .chat-area::-webkit-scrollbar {
            width: 6px;
        }
        .chat-area::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.02);
        }
        .chat-area::-webkit-scrollbar-thumb {
            background-color: var(--theme-color-4);
            border-radius: 3px;
        }
        .chat-area::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-color);
        }

        #history-loader {
            text-align: center;
            padding: 10px;
            display: none; /* Initially hidden */
        }
        #history-loader.visible {
            display: block;
        }
        #history-loader .loader-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--theme-color-2);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }

        .retracted-notice {
            cursor: pointer;
            transition: background 0.3s;
        }
        .retracted-notice:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .chat-input-area {
            display: flex;
            flex-direction: column; /* æ”¹ä¸ºçºµå‘å¸ƒå±€ */
            padding: 10px 15px;
            border-top: 1px solid var(--border-color);
            background-color: white;
            flex-shrink: 0;
            position: relative; /* ä¸ºè¡¨æƒ…é¢æ¿å®šä½ */
        }
        /* èŠå¤©é¡µé¢é¡¶éƒ¨*/
        #page-chat .page-header {
            background: white;
        }


        /* --- åŠŸèƒ½ï¼šå¼•ç”¨é¢„è§ˆæ ·å¼ --- */
        .quote-preview-area {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-color-medium);
            margin-bottom: 8px; /* å’Œä¸‹æ–¹è¾“å…¥æ¡†çš„é—´è· */
            display: none; /* é»˜è®¤éšè— */
        }
        .quote-preview-content { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cancel-quote-btn { background: none; border: none; font-size: 1.2rem; color: #999; cursor: pointer; padding: 0 5px;}

        /* è¾“å…¥å’Œå‘é€æŒ‰é’®çš„å®¹å™¨ */
        .input-top-row {
            display: flex;
            align-items: flex-end;
            width: 100%;
        }

        /* æ–°å¢çš„åŠŸèƒ½æŒ‰é’®è¡Œ */
        .input-feature-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-top: 8px;
        }
        .feature-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: var(--text-color-medium);
            transition: all 0.2s;
        }
        .feature-btn:hover {
            background: white;
            color: var(--accent-color);
        }

        /* è¡¨æƒ…åŒ…é¢æ¿ */
        .emoji-card {
            position: absolute;
            bottom: 100%; /* ä½äºè¾“å…¥åŒºåŸŸæ­£ä¸Šæ–¹ */
            left: 10px; right: 10px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
            padding: 15px;
            z-index: 100;
            display: none;
            max-height: 250px;
            overflow-y: auto;
        }
        .emoji-card.active { display: block; }
.emoji-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4åˆ— */
    grid-template-rows: repeat(2, auto); /* 2è¡Œ */
    gap: 15px; /* å¢å¤§é—´è· */
    min-height: 140px; /* è°ƒæ•´æœ€å°é«˜åº¦ä»¥é€‚åº”æ–°å¸ƒå±€ */
}
        .emoji-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .emoji-nav button {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px 15px;
        }
        .emoji-nav button:hover {
            color: var(--accent-color);
        }
        #emoji-page-indicator {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            min-width: 30px;
            text-align: center;
        }
        
        .emoji-item { cursor: pointer; text-align: center; transition: transform 0.2s; }
        .emoji-item:hover { transform: scale(1.1); }
        .emoji-item img { width: 60px; height: 60px; object-fit: contain; }
        .emoji-item { position: relative; } /* ä¸ºç»å¯¹å®šä½æä¾›åŸºå‡† */
        .favorite-emoji-toggle {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 22px;
            height: 22px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: #ccc;
            font-size: 0.8rem;
            transition: all 0.2s;
            opacity: 0.5; /* æ–°å¢ï¼šé™ä½é»˜è®¤é€æ˜åº¦ï¼Œé¿å…è§†è§‰å¹²æ‰° */
        }
        .favorite-emoji-toggle:hover {
            transform: scale(1.1);
            opacity: 1; /* æ–°å¢ï¼šæ‚¬æµ®æ—¶å®Œå…¨ä¸é€æ˜ */
        }
        .favorite-emoji-toggle.is-favorite {
            color: #ffc107; /* é»„è‰²æ˜Ÿæ˜Ÿ */
            background-color: white;
            border-color: #ffc107;
        }
        #ai-request-btn {
            background: none; border: none; font-size: 1.8rem; color: var(--accent-color); cursor: pointer; padding: 5px 10px 5px 0; transition: transform 0.2s;
        }
        #ai-request-btn:hover {
             transform: scale(1.1);
        }
        #message-input {
            flex-grow: 1;
            border: none;
            background: var(--text-color-white);
            padding: 12px;
            border-radius: 18px;
            resize: none;
            font-size: 1rem;
            font-family: var(--font-main);
            max-height: 100px;
            outline: none;
            margin-left: 10px; /* å’Œå·¦ä¾§AIæŒ‰é’®çš„é—´è· */
        }
        #send-btn {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--theme-color-2) 100%);
            color: white;
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 1.2rem;
            margin-left: 10px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            flex-shrink: 0; /* é˜²æ­¢è¢«æŒ¤å‹ */
            box-shadow: 0 4px 10px rgba(167, 199, 231, 0.4);
        }
        #send-btn:hover {
            background-color: var(--accent-color-deep);
            transform: scale(1.05);
        }

        /* --- 8. æ¨¡æ€æ¡†/å¼¹çª— --- */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500; /* æå‡å±‚çº§ï¼Œé«˜äºä¾§è¾¹æ çš„ 2000 */
        }
        #modal-overlay.visible {
            display: flex;
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background: var(--bg-main);
            padding: 25px;
            border-radius: 20px;
            width: 90%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-medium);
            animation: slideInUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes slideInUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            font-family: var(--font-title);
            font-size: 1.6rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--text-color-dark);
        }

        /* --- è¯¦æƒ…é¡µæ ·å¼ (æ¥è‡ªå‚è€ƒæ–‡ä»¶) --- */
        .details-card {
            background-color: var(--text-color-white);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow-light);
            margin-bottom: 20px;
        }
        .details-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            position: relative; /* æ–°å¢ï¼šä¸ºç»å¯¹å®šä½çš„å­å…ƒç´ æä¾›å®šä½å‚è€ƒ */
        }
        .details-header-attribution {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 2;
            flex-shrink: 0; /* é˜²æ­¢è¢«æ ‡é¢˜æŒ¤å‹ */
        }
        .details-header-attribution:hover {
            transform: scale(1.1);
            background-color: var(--accent-color);
        }
        .details-header .avatar {
            width: 64px;
            height: 64px;
            border-radius: 12px;
            margin-right: 20px;
            object-fit: cover;
        }
        .details-info .name {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color-dark);
        }
        .details-info .id {
            font-size: 0.9rem;
            color: var(--text-color-light);
        }
        .details-section {
            margin-top: 20px;
        }
        .details-section-title {
            font-size: 1rem;
            color: var(--text-color-medium);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .details-field {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 1rem;
        }
        .details-field .label { color: var(--text-color-medium); }
        .details-field .value { color: var(--text-color-dark); text-align: right; }
        .details-section p {
            white-space: pre-wrap; /* å…³é”®ï¼šè®©æ¢è¡Œç¬¦ç”Ÿæ•ˆ */
            max-height: 150px;     /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;      /* å†…å®¹è¶…å‡ºæ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            line-height: 1.6;
            color: var(--text-color-medium);
            background-color: rgba(0,0,0,0.02); /* åŠ ä¸€ç‚¹æ·¡æ·¡çš„åº•è‰²ä»¥åŒºåˆ† */
            padding: 10px;
            border-radius: 8px;
        }
        .details-section p::-webkit-scrollbar { width: 4px; }
        .details-section p::-webkit-scrollbar-thumb { background: var(--theme-color-4); border-radius: 2px; }
        .member-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
        }
        .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .member-item .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0;
        }
        .member-item .name {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .details-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .details-btn {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 8px; /* è°ƒæ•´åœ†è§’ */
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.2); /* é€æ˜èƒŒæ™¯ */
            border: 1px dashed var(--text-color-light); /* è™šçº¿è¾¹æ¡† */
            color: var(--text-color-dark); /* æ·±è‰²æ–‡å­— */
        }
        .details-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            border-color: var(--accent-color);
            color: var(--accent-color-deep);
        }
        /* ç§»é™¤ç‰¹å®šçš„èƒŒæ™¯è‰²ï¼Œä½¿å…¶é£æ ¼ç»Ÿä¸€ */
        .btn-details-primary {
            /* æ ·å¼å·²ç”± .details-btn ç»Ÿä¸€å¤„ç† */
        }
        .btn-details-danger {
            /* æ ·å¼å·²ç”± .details-btn ç»Ÿä¸€å¤„ç† */
        }
        .btn-details-danger:hover {
            border-color: #e74c3c;
            color: #c0392b;
        }
        /* --- ç»“æŸï¼šè¯¦æƒ…é¡µæ ·å¼ --- */

        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color-medium);
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            border-radius: 10px;
            font-size: 1rem;
            font-family: var(--font-main);
            outline-color: var(--accent-color);
        }
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        .modal-content .form-group textarea {
    max-height: 25vh; /* é™åˆ¶æœ€å¤§é«˜åº¦ä¸ºè§†çª—çš„25% */
    overflow-y: auto; /* ç¡®ä¿å†…å®¹è¶…å‡ºæ—¶å¯æ»šåŠ¨ */
}
        .avatar-uploader {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            background-color: var(--theme-color-3);
            border: 2px solid white;
        }
        .upload-btn {
            padding: 8px 15px;
            background: var(--theme-color-4);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 25px;
        }
        .modal-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
        }
        /* --- Neumorphic Modal Style --- */
        .modal-content.modal-neumorphic {
            background: #F0F0F3;
            border-radius: 20px;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 25px;
        }
        .modal-neumorphic .modal-header {
            color: #555;
            font-family: var(--font-title);
            text-shadow: 1px 1px 1px #fff;
            text-align: center;
            margin-bottom: 25px;
        }
        .modal-neumorphic .form-group label {
            color: #888;
            font-weight: 500;
            text-shadow: 1px 1px 1px #fff;
        }
        .modal-neumorphic .form-group input,
        .modal-neumorphic .form-group select,
        .modal-neumorphic .form-group textarea {
            background: #F0F0F3;
            border: none;
            border-radius: 12px;
            padding: 12px 15px;
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.7),
                inset 5px 5px 9px rgba(174, 174, 192, 0.2);
            color: var(--text-color-dark);
            font-size: 1rem;
            outline: none;
        }
        .modal-neumorphic .modal-actions {
            display: flex;
            justify-content: space-around; /* Space them out */
            margin-top: 30px;
        }
        .modal-neumorphic .modal-btn {
            padding: 12px 0; /* Vertical padding, horizontal from flex */
            flex: 1; /* Take up equal space */
            margin: 0 10px; /* Spacing between buttons */
            border-radius: 12px;
            border: none;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .modal-neumorphic .btn-primary {
            background: #5A8DEE;
            color: white;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-primary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            background: #4a7de0; /* Slightly darker on hover */
            color: #f0f0f0;
        }
        .modal-neumorphic .btn-secondary {
            background: #F0F0F3;
            color: #888;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-secondary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-color-deep);
            transform: translateY(-2px);
        }
        .btn-secondary {
            background-color: #ccc;
            color: #333;
        }
        .btn-secondary:hover {
            background-color: #bbb;
        }
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .persona-modal-card {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow-light);
        }
        .persona-modal-card h4 {
            font-family: var(--font-title);
            color: var(--accent-color-deep);
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
    .persona-modal-card p {
        font-family: var(--font-inner-voice); /* åº”ç”¨å¿ƒå£°å­—ä½“ */
        line-height: 1.6;
        color: var(--text-color-dark);
    }
    .note-paper {
        font-family: var(--font-essay); /* åº”ç”¨éšç¬”å­—ä½“ */
        background-color: #fdf5d3;
        background-image:
            linear-gradient(90deg, rgba(200, 180, 140, 0.15) 1px, transparent 1px),
            linear-gradient(rgba(200, 180, 140, 0.15) 1px, transparent 1px);
        background-size: 20px 20px;
        border: 1px solid #e0d9c3;
        position: relative;
        padding-top: 30px; /* ä¸ºå›¾é’‰ç•™å‡ºç©ºé—´ */
    }
        .note-paper::before {
            content: '';
            position: absolute;
            top: 5px;
            right: 15px;
            width: 20px;
            height: 20px;
            background: #ff7675;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        .member-select-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 5px;
        }
        .member-select-item {
            display: flex;
            align-items: center; /* å‚ç›´å±…ä¸­å¯¹é½ */
            padding: 8px;
            cursor: pointer; /* è®©æ•´è¡Œéƒ½å¯ä»¥ç‚¹å‡» */
        }

        .member-select-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
        }

        .group-info-modal-body .form-group {
            margin-bottom: 10px;
        }
        .group-info-modal-body .member-list-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 15px;
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0,0,0,0.02);
            border-radius: 8px;
        }
        .group-info-modal-body .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .group-info-modal-body .member-item img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid white;
        }
        .group-info-modal-body .member-item span {
            font-size: 0.8rem;
            color: var(--text-color-medium);
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* --- 8.5. é¡¶éƒ¨æµ®çª—é€šçŸ¥ --- */
        #top-notification-container {
            position: absolute;
            top: 15px; /* ä»é¡¶éƒ¨ç•™å‡ºä¸€äº›é—´è· */
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 480px; /* åŒ¹é…app-containerçš„æœ€å¤§å®½åº¦ */
            z-index: 5000;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€å®¹å™¨æœ¬èº« */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .notification-banner {
            pointer-events: auto; /* ä»…bannerå¯ç‚¹å‡» */
            background-color: #FBFBFC; /* æŸ”å’Œçš„ç°ç™½è‰² */
            border: 1px solid var(--border-color); /* ä½¿ç”¨é€šç”¨è¾¹æ¡†è‰² */
            border-radius: 16px; /* åœ†è§’ */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1); /* å¢å¼ºé˜´å½±æ•ˆæœ */
            padding: 12px 18px; /* å¢å¤§å†…è¾¹è· */
            display: flex;
            align-items: center;
            gap: 15px; /* å¢å¤§é—´è· */
            width: fit-content;
            max-width: 95%; /* é™åˆ¶æœ€å¤§å®½åº¦ */
            min-width: 280px; /* å¢å¤§æœ€å°å®½åº¦ */
            cursor: pointer;
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            animation: notification-enter 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        
        @keyframes notification-enter {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        @keyframes notification-exit {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .notification-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 8px;
        }
        .notification-name {
            font-weight: bold;
            color: var(--text-color-dark);
            white-space: nowrap;
        }
        .notification-time {
            font-size: 0.7rem;
            color: var(--text-color-light);
            flex-shrink: 0;
        }
        .notification-message {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- 8.5.1 ç‰¹æ®Šï¼šéšç¬”æ›´æ–°æµ®çª— --- */
        .essay-notification-banner {
            pointer-events: auto;
            position: relative;
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: width 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .essay-notification-banner.is-playing {
            animation: expand-toast 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .essay-notification-banner.is-playing .icon-wrapper {
             animation: move-icon 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .text-content {
            opacity: 0;
            white-space: nowrap;
            padding-left: 52px; /* ç»™å›¾æ ‡ç•™å‡ºç©ºé—´ */
        }
        .essay-notification-banner.is-playing .text-content {
            animation: show-text 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        @keyframes expand-toast {
            0% { width: 48px; }
            50%, 100% { width: 220px; }
        }

        @keyframes move-icon {
            0% {
                left: 50%;
                transform: translate(-50%, -50%) scale(1);
            }
            40% {
                left: 24px;
                transform: translate(-50%, -50%) scale(0.9);
            }
            50%, 100% {
                left: 24px;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes show-text {
            0%, 50% { opacity: 0; transform: translateX(-10px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* --- 8.6. è‡ªå®šä¹‰æ•°å­—è¾“å…¥æ¡† --- */
        .number-input-custom {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        .number-input-custom button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            font-size: 1.2rem;
            color: var(--text-color-medium);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .number-input-custom button:hover {
            background-color: var(--theme-color-1);
            color: var(--accent-color-deep);
        }
        .number-input-display {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--text-color-dark);
            min-width: 50px;
            text-align: center;
            padding: 5px 10px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 8px;
        }

        /* --- 8.7. Toast è½»é‡æç¤º --- */
        .toast-notification {
            position: fixed; /* ä¿®å¤ï¼šä½¿ç”¨fixedå®šä½ï¼Œç›¸å¯¹äºè§†å£ */
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 10000; /* ç¡®ä¿é«˜äºæ‰€æœ‰å…¶ä»–å…ƒç´  */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            animation: toast-in 0.3s forwards;
        }

        @keyframes toast-in {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .toast-notification.hiding {
            opacity: 0;
        }
        /* --- 8.8. Bottom Sheet --- */
        #bottom-sheet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            z-index: 3000; /* é«˜äºæ¨¡æ€æ¡† */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out; /* åªå¯¹ opacity è¿‡æ¸¡ */
        }
        #bottom-sheet-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .bottom-sheet-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-height: 50vh;
            background: white;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;
        }
        #bottom-sheet-overlay.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .bottom-sheet-header {
            padding: 15px 20px;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .bottom-sheet-body {
            padding: 10px;
            overflow-y: auto;
        }
        .bottom-sheet-item {
            padding: 15px 20px;
            font-size: 1.1rem;
            cursor: pointer;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }
        .bottom-sheet-item:last-child {
            border-bottom: none;
        }
        .bottom-sheet-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        /* Neumorphic style for bottom sheet */
        .bottom-sheet-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item {
            color: var(--text-color-dark);
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item:hover {
            background: #e6e6e9;
        }
        .bottom-sheet-content.compact-list .bottom-sheet-item {
            padding: 10px 20px; /* Reduced vertical padding */
            font-size: 1rem; /* Slightly smaller font */
        }
/* --- 9. ç‚¹å‡»ç‰¹æ•ˆ --- */
#click-effect-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 9999;
}
.ripple {
    position: absolute;
    border-radius: 50%;
    background-color: var(--accent-color);
    transform: scale(0);
    animation: ripple-effect 0.6s ease-out;
    opacity: 0.5;
}
@keyframes ripple-effect {
    to {
        transform: scale(1);
        opacity: 0;
    }
}
.heart {
    position: absolute;
    color: var(--accent-color);
    animation: heart-fly 1.2s ease-out forwards;
    opacity: 1;
    font-size: 16px;
}
@keyframes heart-fly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}
/* --- 10. ä¾§è¾¹æ  --- */
#sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(5px);
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
#sidebar-overlay.visible {
    opacity: 1;
    visibility: visible;
}
#sidebar-content {
    position: absolute;
    top: 0;
    right: 0; /* æ”¹ä¸º right */
    left: auto; /* æ–°å¢ */
    width: 80%;
    max-width: 350px;
    height: 100%;
    background: var(--bg-main);
    box-shadow: var(--shadow-medium);
    transform: translateX(100%); /* æ”¹ä¸ºæ­£å€¼ */
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
}
#sidebar-overlay.visible #sidebar-content {
    transform: translateX(0);
}
#sidebar-content .form-group {
    margin-bottom: 20px;
}

        /* --- 10.1. å·¦ä¾§æ»‘å‡ºä¾§è¾¹æ  --- */
        #sidebar-content.sidebar-from-left {
            left: 0;
            right: auto;
            transform: translateX(-100%);
        }
        #sidebar-overlay.visible #sidebar-content.sidebar-from-left {
            transform: translateX(0);
        }

        /* --- 10.2. ä¾§è¾¹æ æ ·å¼è°ƒæ•´ --- */
        #sidebar-content .modal-header {
            font-size: 1.4rem; /* ç¼©å°æ ‡é¢˜å­—ä½“ */
            padding-bottom: 15px; /* ä¸ºåˆ†å‰²çº¿ç•™å‡ºç©ºé—´ */
            margin-bottom: 15px; /* è°ƒæ•´ä¸ä¸‹æ–¹å†…å®¹çš„é—´è· */
            border-bottom: 1px solid var(--border-color); /* æ·»åŠ åˆ†å‰²çº¿ */
            position: relative;
        }
        /* ä¼˜ç¾çš„åˆ†å‰²çº¿è£…é¥° */
        #sidebar-content .modal-header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 2px;
            background: var(--accent-color);
            border-radius: 1px;
        }
        #sidebar-content .setting-item span {
            font-size: 1rem; /* ç¼©å°ä¾§è¾¹æ å†…æŒ‰é’®æ–‡å­—å¤§å° */
        }
        

        /* ä¾§è¾¹æ å†…çš„ç‰¹å®šæ ·å¼ */
        #sidebar-content .details-card {
             background-color: rgba(255,255,255,0.6);
             margin: 0 0 15px 0;
             padding: 15px;
        }
        #sidebar-content .details-header .avatar {
            width: 50px;
            height: 50px;
        }
        #sidebar-content .details-info .name {
            font-size: 1.3rem;
        }
        #sidebar-content .details-actions {
            margin-top: 20px;
        }
        
        /* ç¾¤æˆå‘˜åˆ—è¡¨å¼¹çª—æ ·å¼ */
        .member-list-modal-body {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px; /* ä¸ºæ»šåŠ¨æ¡ç•™å‡ºç©ºé—´ */
        }
        .member-list-modal-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .member-list-modal-item:last-child {
            border-bottom: none;
        }
        .member-list-modal-item img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            margin-right: 15px;
        }
        .member-list-modal-item .owner-tag {
            font-size: 0.7rem;
            background-color: #f1c40f;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 10px;
        }

        /* --- 10.3. Neumorphic Sidebar Style --- */
        #sidebar-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px 0px 20px 0px #fff,
                7px 0px 20px 0px #d1d9e6;
            border-left: 1px solid rgba(255, 255, 255, 0.5); /* For right sidebar */
        }
        #sidebar-content.neumorphic.sidebar-from-left {
            box-shadow: 
                -7px 0px 20px 0px #d1d9e6,
                7px 0px 20px 0px #fff;
            border-left: none;
            border-right: 1px solid rgba(255, 255, 255, 0.5);
        }
        #sidebar-content.neumorphic .modal-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        #sidebar-content.neumorphic .modal-header::after {
            background: #888;
            box-shadow: 1px 1px 1px #fff;
        }
        #sidebar-content.neumorphic .setting-item {
            background: transparent;
            box-shadow: 
                -5px -5px 9px rgba(255, 255, 255, 0.9), 
                5px 5px 9px rgba(174, 174, 192, 0.4);
            margin: 0 0 15px; /* Adjust margin */
        }
        #sidebar-content.neumorphic .setting-item:hover {
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.9), 
                inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            transform: none; /* Override hover transform */
        }

        /* --- 11. è‡ªå®šä¹‰æç¤ºè¯é¡µé¢ --- */
        #prompts-page-content {
            padding: 15px;
        }
        #prompt-header-actions {
            gap: 10px; /* å‡å°å›¾æ ‡é—´è· */
        }
        #prompt-header-actions .header-icon {
            font-size: 1.1rem; /* å‡å°å›¾æ ‡å¤§å° */
            padding: 0 5px; /* å‡å°å›¾æ ‡çš„æ°´å¹³å†…è¾¹è·ï¼Œè®©å…¶æ›´ç´§å‡‘ */
        }
        
        .prompt-folder {
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-light);
            transition: all 0.3s;
        }
        .prompt-folder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        .prompt-folder-header h3 {
            font-size: 1.1rem;
            color: var(--text-color-dark);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-folder-header h3 .folder-toggle-icon {
        transition: transform 0.3s ease-in-out;
         }
        .prompt-folder-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .prompt-folder-controls .folder-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-light);
            transition: color 0.2s;
        }
        .prompt-folder-controls .folder-action-btn:hover {
            color: var(--accent-color);
        }
        .prompt-folder-content {
            padding: 15px;
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }
        .prompt-folder-content.collapsed {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
    margin-top: -1px; /* ä¼˜åŒ–è¾¹æ¡†æ˜¾ç¤º */
    display: block; 
}
.prompt-folder-header.collapsed .folder-toggle-icon {
    transform: rotate(-90deg);
}
        .prompt-card {
            background-color: var(--text-color-white);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border-left: 5px solid var(--theme-color-4);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .prompt-card.inactive {
            border-left-color: #ccc;
            opacity: 0.7;
        }
        .prompt-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .prompt-card-name {
            font-weight: bold;
            font-size: 1rem;
            color: var(--text-color-dark);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-card-name .prompt-index {
            font-size: 0.8rem;
            background: var(--theme-color-4);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
        }
        .prompt-card.inactive .prompt-card-name .prompt-index {
            background: #ccc;
        }
        .prompt-card-tags {
            display: flex;
            gap: 6px;
        }
        .prompt-tag {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 10px;
            color: white;
        }
        .tag-explicit { background-color: var(--accent-color); }
        .tag-implicit { background-color: var(--theme-color-4); }
        .tag-keywords {
            background-color: var(--theme-color-3);
            color: var(--text-color-dark);
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .prompt-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .prompt-card-actions .action-btn {
            background: rgba(0,0,0,0.05);
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .prompt-card-actions .action-btn:hover {
            background: var(--accent-color);
            color: white;
        }
        .font-delete-btn {
            padding: 8px 10px;
            font-size: 0.9rem;
            min-width: 40px;
        }
        
        /* --- 12. ç»‘å®šæç¤ºè¯å¼¹çª—æ ·å¼ --- */
        .binding-modal-content {
            background: var(--bg-light) !important; /* ä½¿ç”¨ä¸»é¡µé¢çš„æµ…è‰²èƒŒæ™¯ */
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
        }
        .binding-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .binding-modal-header h2 {
            margin: 0;
            font-size: 1.4rem;
            font-family: var(--font-title);
        }
        #open-folder-selection-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        #open-folder-selection-btn:hover {
            transform: scale(1.1) rotate(90deg);
            background: var(--accent-color-deep);
        }
        #bound-folders-list {
            min-height: 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .bound-folder-card {
            background: var(--text-color-white);
            padding: 15px;
            border-radius: 10px;
            box-shadow: var(--shadow-light);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .bound-folder-card i {
            font-size: 1.5rem;
            color: var(--theme-color-4);
        }
        .bound-folder-card span {
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .folder-selection-list {
            max-height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .folder-selection-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 8px;
            cursor: pointer;
        }
        .folder-selection-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 15px;
            accent-color: var(--accent-color);
        }
        .folder-selection-item i {
            margin-right: 10px;
            color: var(--text-color-medium);
        }
        
        /* --- å¼€å…³æ ·å¼ (å¯å¤ç”¨) --- */
        .switch { position: relative; display: inline-block; width: 52px; height: 30px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 30px; }
        .slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(22px); }


        /* --- 13. å‘ç°é¡µé¢ --- */
        #page-discover .settings-list {
            padding-top: 10px;
        }
        #page-discover .setting-item {
            margin: 0 10px 1px; /* ç´§å‡‘åˆ—è¡¨ */
            border-radius: 0;
            padding: 18px 15px;
            background: var(--text-color-white);
        }
        #page-discover .setting-item:first-child {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            margin-top: 10px;
        }
        #page-discover .setting-item:last-child {
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            margin-bottom: 10px;
        }
        #page-discover .setting-item:hover {
            transform: none;
            box-shadow: none;
            background-color: #f7f7f7;
        }

        /* --- 14. æœ‹å‹åœˆé¡µé¢ --- */
        #page-moments {
            /* å…³é”®1ï¼šè®©å®ƒæˆä¸ºä¸€ä¸ªå‰ªè£å’Œå®šä½çš„å®¹å™¨ */
            overflow: hidden; 
            position: relative; /* æ–°å¢ï¼šä¸ºå­å…ƒç´ çš„ç»å¯¹å®šä½æä¾›åŸºå‡† */
        }

        #moments-wrapper {
            /* å…³é”®2ï¼šä½¿ç”¨ç»å¯¹å®šä½æ¥ç¡®ä¿å°ºå¯¸å’Œä½ç½®çš„ç²¾ç¡®æ€§ */
            position: absolute;
            top: 0;
            left: 0;
            width: 125%; /* 100% / 0.8 = 125% */
            height: 125%;
            transform: scale(0.8);
            transform-origin: top left;
            
            /* å†…éƒ¨å¸ƒå±€ä¿æŒä¸å˜ï¼Œä¾ç„¶ä½¿ç”¨flexæ¥æ’åˆ—headerå’Œcontent */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* é˜²æ­¢å†…éƒ¨å‡ºç°æ„å¤–çš„æ»šåŠ¨æ¡ */
        }
        #page-moments .page-header {
            display: flex; /* ä½¿ç”¨flexå¸ƒå±€ä»¥é€‚åº”æŒ‰é’® */
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            position: absolute; /* æµ®åŠ¨åœ¨èƒŒæ™¯å›¾ä¸Š */
            top: 0;
            left: 0;
            right: 0;
            background: transparent;
            border-bottom: none;
            z-index: 10;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
        }
        #moments-actions-group {
            display: flex;
            gap: 10px;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
            padding: 5px 8px; /* è°ƒæ•´å†…è¾¹è·ä½¿æŒ‰é’®æ›´ç´§å‡‘ */
        }

        #page-moments .page-content {
            padding: 0; /* ç§»é™¤å†…è¾¹è·ï¼Œè®©å†…å®¹å¡«æ»¡ */
            background-color: var(--theme-color-1);
        }

        .moments-header-container {
            position: relative;
        }
        #moments-bg {
            width: 100%;
            height: 250px;
            object-fit: cover;
            display: block;
        }
        .moments-profile-info {
            position: absolute;
            bottom: 0;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .moments-profile-info .name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color-white);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .moments-profile-info .avatar {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            border: 3px solid white;
            box-shadow: var(--shadow-light);
        }

        #moments-list {
            list-style: none;
            padding: 0;
            background-color: var(--bg-light);
        }

        .moments-post {
            display: flex;
            gap: 15px;
            padding: 20px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        .post-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .post-main-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .post-author-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent-color-deep);
            margin-bottom: 8px;
        }
        .post-text {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .post-images-grid {
            display: grid;
            gap: 5px;
            margin-bottom: 10px;
        }
        .post-images-grid.grid-1 { grid-template-columns: minmax(0, 2fr); }
        .post-images-grid.grid-2, .post-images-grid.grid-4 { grid-template-columns: repeat(2, 1fr); }
        .post-images-grid.grid-3, .post-images-grid.grid-5, .post-images-grid.grid-6, .post-images-grid.grid-7, .post-images-grid.grid-8, .post-images-grid.grid-9 { grid-template-columns: repeat(3, 1fr); }

        .post-images-grid img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            background-color: var(--theme-color-1);
        }
        .post-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-color-light);
        }
        .post-actions-btn {
            background: transparent; /* å»æ‰èƒŒæ™¯è‰² */
            border: none;
            width: 30px;
            height: 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
            transition: background-color 0.2s; /* æ·»åŠ è¿‡æ¸¡æ•ˆæœ */
        }
        .post-actions-btn:hover, .post-action-icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.05); /* æ·»åŠ æ‚¬æµ®æ•ˆæœ */
        }

        .post-comments-section {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
        }
        .post-interactions {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        .post-likes {
            padding: 8px 10px;
            line-height: 1.5;
            color: var(--accent-color-deep);
            font-weight: 500;
            border-bottom: 1px solid #ededed;
        }
        .post-likes .fa-heart {
            margin-right: 8px;
        }
        .post-likes:empty {
            display: none;
        }
        .post-likes:empty + .post-comments-list {
            border-top: none; /* å¦‚æœæ²¡æœ‰ç‚¹èµï¼Œè¯„è®ºåŒºå°±ä¸è¦æœ‰ä¸Šè¾¹æ¡† */
        }
        .post-footer .action-buttons-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .post-action-icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
        }
        .post-action-icon-btn.liked .fa-heart {
            color: var(--accent-color);
            font-weight: 900; /* 'fas' style */
        }
        .post-comment-item {
            padding: 8px 10px;
            line-height: 1.5;
        }
        .comment-author {
            color: var(--accent-color);
            font-weight: bold;
        }
        .comment-reply-to {
            color: var(--text-color-medium);
        }
        .post-comment-typing-indicator {
            padding: 8px 10px;
            color: var(--text-color-light);
            font-style: italic;
        }

        /* è¯„è®ºè¾“å…¥æ¡† */
        .comment-input-wrapper {
            display: none; /* é»˜è®¤éšè— */
            padding: 8px 10px;
            margin-top: 5px;
        }
        .comment-input-wrapper.active {
            display: flex; /* ç‚¹å‡»è¯„è®ºæŒ‰é’®åæ˜¾ç¤º */
            gap: 8px;
        }
        .comment-input-wrapper input {
            flex-grow: 1;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 8px 12px;
            font-size: 0.9rem;
            outline: none;
        }
        .comment-input-wrapper button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 0 15px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* --- 15. æœ‹å‹åœˆè½¬å‘å¡ç‰‡æ ·å¼ --- */
        .bubble.forwarded-moment-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 250px;
        }
        .bubble.forwarded-moment-bubble:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        /* --- æ ¸å¿ƒä¿®å¤ï¼šé’ˆå¯¹æ‰€æœ‰ä¸»é¢˜ï¼Œå¼ºåˆ¶é‡ç½®ç‰¹æ®Šæ¶ˆæ¯çš„æ°”æ³¡æ ·å¼ --- */
        #app-container[class*="app-bubble-style-"] .bubble.transfer-or-red-packet-bubble,
        #app-container[class*="app-bubble-style-"] .bubble.card-bubble,
        #app-container[class*="app-bubble-style-"] .bubble.forwarded-moment-bubble {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
        }
        
        .forwarded-moment-card-content {
            background-color: var(--text-color-white);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .forwarded-moment-card-content .card-title {
            font-size: 0.9rem;
            font-weight: 500;
        }
        .forwarded-moment-card-content .card-preview {
            font-size: 0.8rem;
            color: var(--text-color-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .forwarded-moment-card-content .card-footer {
            font-size: 0.75rem;
            color: var(--text-color-light);
            border-top: 1px solid var(--border-color);
            padding-top: 8px;
            margin-top: 8px;
        }

        /* --- æœ‹å‹åœˆè½¬å‘å¡ç‰‡è¯¦æƒ…å¼¹çª—æ ·å¼ --- */
        .moment-detail-wrapper { padding: 20px 15px; }
        .moment-detail-wrapper .post-header { display: flex; align-items: center; gap: 15px; }
        .moment-detail-wrapper .post-avatar { width: 50px; height: 50px; border-radius: 8px; object-fit: cover; }
        .moment-detail-wrapper .post-author-info .name { font-size: 1.1rem; font-weight: 600; color: var(--accent-color-deep); }
        .moment-detail-wrapper .post-content-full { margin: 15px 0; font-size: 1rem; line-height: 1.7; white-space: pre-wrap; }
        .moment-detail-wrapper .post-image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 5px; margin: 15px 0; }
        .moment-detail-wrapper .post-image-grid img { width: 100%; height: 80px; object-fit: cover; border-radius: 6px; }
        .moment-detail-wrapper .post-footer-full { display: flex; justify-content: space-between; align-items: center; color: var(--text-color-light); font-size: 0.8rem; margin-bottom: 10px; }
        .moment-detail-wrapper .interactions-section { background-color: rgba(0,0,0,0.03); border-radius: 8px; font-size: 0.9rem; }
        .moment-detail-wrapper .likes-list { padding: 10px 12px; line-height: 1.5; color: var(--accent-color-deep); font-weight: 500; word-break: break-all; }
        .moment-detail-wrapper .likes-list .fa-heart { margin-right: 8px; }
        .moment-detail-wrapper .likes-list:empty + .comments-list { border-top: none; }
        .moment-detail-wrapper .comments-list { padding: 5px 0; border-top: 1px solid var(--border-color); }
        .moment-detail-wrapper .comment-item { padding: 8px 12px; line-height: 1.5; }
        .moment-detail-wrapper .comment-author { color: var(--accent-color); font-weight: bold; }
        .moment-detail-wrapper .comment-reply-to { color: var(--text-color-medium); }

        /* 
        =============================
        æ¶ˆæ¯æ°”æ³¡æ ·å¼ (æ¥è‡ªå‚è€ƒæ–‡ä»¶)
        =============================
        */

        /* --- é€šç”¨åŸºç¡€æ ·å¼ --- */
        .bubble.transfer-or-red-packet-bubble,
        .bubble.card-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 280px;
        }
        .bubble.transfer-or-red-packet-bubble:not(.claimed):hover,
        .bubble.card-bubble:hover .card-message-wrapper {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        .bubble.card-bubble {
            max-width: 280px; /* è°ƒæ•´ä¸º max-width */
        }

        /* --- å¡ç‰‡æ¶ˆæ¯å®¹å™¨æ ·å¼ --- */
        .card-message-wrapper {
            background-color: var(--text-color-white, white);
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            color: var(--text-color-dark, #333);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card-message-wrapper h4,
        .card-message-wrapper p {
            margin: 0;
            padding: 0;
            line-height: 1.4;
        }
        .card-message-wrapper h4 {
            font-size: 1rem;
            font-weight: 600;
        }
        .card-message-wrapper p {
            font-size: 0.85rem;
            color: var(--text-color-light, #666);
        }

        /* --- å¡ç‰‡è¯¦æƒ…å±•å¼€æ ·å¼ (ä¿®æ”¹å) --- */
        .bubble.card-bubble {
            position: relative; /* æ–°å¢ï¼šä¸ºç»å¯¹å®šä½çš„å­å…ƒç´ æä¾›å‚è€ƒ */
            overflow: visible;  /* æ–°å¢ï¼šå…è®¸ç»å¯¹å®šä½çš„å­å…ƒç´ æº¢å‡º */
            background: none; /* å¡ç‰‡æ¶ˆæ¯æœ¬èº«ä¸éœ€è¦èƒŒæ™¯ */
            padding: 0;       /* ç§»é™¤å†…è¾¹è·ï¼Œç”±å†…éƒ¨wrapperæ§åˆ¶ */
            box-shadow: none; /* ç§»é™¤é˜´å½±ï¼Œç”±å†…éƒ¨wrapperæ§åˆ¶ */
        }
        .card-detail-content {
            position: absolute; /* å…³é”®ä¿®æ”¹ï¼šè„±ç¦»æ–‡æ¡£æµ */
            top: 100%; /* å®šä½åˆ°å¯è§å¡ç‰‡çš„æ­£ä¸‹æ–¹ */
            left: 0;
            width: 100%;
            z-index: 10; /* ç¡®ä¿åœ¨å…¶ä»–å…ƒç´ ä¹‹ä¸Š */
            
            background-color: var(--text-color-white); /* å›ºå®šç™½è‰²èƒŒæ™¯ */
            color: var(--text-color-dark); /* å›ºå®šæ·±è‰²å­—ä½“ */
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px; /* ç»™è‡ªå·±å®Œæ•´çš„åœ†è§’ */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* ç‹¬ç«‹çš„å¤–é˜´å½± */
            padding: 15px;

            max-height: 0; /* é»˜è®¤éšè— */
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.4s ease, padding-top 0.4s ease, padding-bottom 0.4s ease;
            box-sizing: border-box;
        }
        .card-detail-content.visible {
            max-height: 500px;
            opacity: 1;
        }
        /* ç¡®ä¿è¯¦æƒ…å†…çš„æ–‡å­—é¢œè‰²ä¸è¢«å¤–éƒ¨æ°”æ³¡æ ·å¼è¦†ç›– */
        .card-detail-content h5, .card-detail-content p {
            color: var(--text-color-dark) !important;
        }

        /* --- 1. æ–°ç‰ˆè½¬è´¦æ ·å¼ --- */
        .message-row.sent .transfer-content-v3 {
            background-color: #BEE3F8;
            color: #2A4365;
        }
        .message-row.received .transfer-content-v3 {
            background-color: #FFF0F5;
            color: var(--text-color-dark);
        }
        .transfer-content-v3 {
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%;
            position: relative; /* æ–°å¢ï¼šä¸ºä¼ªå…ƒç´ å®šä½ */
            overflow: hidden; /* æ–°å¢ï¼šè£å‰ªä¼ªå…ƒç´  */
            z-index: 1; /* æ–°å¢ï¼šç¡®ä¿å†…å®¹åœ¨èƒŒæ™¯ä¹‹ä¸Š */
        }
        /* æ–°å¢ï¼šç¡®ä¿å†…å®¹åœ¨é®ç½©å±‚ä¹‹ä¸Š */
        .transfer-content-v3 > * {
            position: relative;
            z-index: 2;
        }
        /* æ–°å¢ï¼šåŠé€æ˜ç™½è‰²é®ç½©ï¼Œé™ä½èƒŒæ™¯å›¾é¥±å’Œåº¦ */
        .transfer-content-v3::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.65);
            z-index: 1;
        }
        .transfer-header-v3 {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 5px;
        }
        .transfer-icon-v3 {
            font-size: 24px;
        }
        .message-row.sent .transfer-icon-v3 { color: #3182CE; }
        .message-row.received .transfer-icon-v3 { color: #FF69B4; }

        .transfer-info-v3 h4 { margin: 0; font-size: 1em; font-weight: 500; }
        .transfer-info-v3 p { margin: 0; font-size: 1.2em; font-weight: 700; }
        .transfer-footer-v3 {
            border-top: 1px solid rgba(0,0,0,0.08);
            padding-top: 5px;
            margin-top: 5px;
            font-size: 0.75em;
            color: #777;
        }
        .bubble.claimed .transfer-content-v3 {
            background-color: #e0e0e0;
            opacity: 0.8;
        }

        /* --- 2. æ–°ç‰ˆçº¢åŒ…æ ·å¼ --- */
        .red-packet-v3-wrapper {
            width: 120px;
            height: 160px;
            position: relative;
        }
        .rp-cover-v3 {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            background-image: url('https://z.wiki/u/IDzEvp'); /* å·²æ›´æ¢ä¸ºæ–°çš„é»˜è®¤å°é¢ */
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* è®©å†…å®¹ä»åº•éƒ¨å¼€å§‹å¯¹é½ï¼Œä¸ºéšè—æ ‡é¢˜åšå‡†å¤‡ */
            padding: 10px;
            box-sizing: border-box;
        }
        .rp-title-v3 {
            display: none; /* å·²éšè—çº¢åŒ…å°é¢ä¸Šçš„æ ‡é¢˜ */
        }
        .open-button-v3 {
            width: 45px;
            height: 45px;
            background-color: var(--red-packet-gold);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            color: var(--red-packet-red);
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            animation: paw-pulse 2s infinite ease-in-out;
            align-self: center; /* ç¡®ä¿åœ¨ flex å¸ƒå±€ä¸­å±…ä¸­ */
            margin-bottom: 5px; /* è°ƒæ•´ä¸åº•éƒ¨è·ç¦» */
        }
        .claimed-overlay-v3 {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--red-packet-red);
            font-weight: bold;
            font-size: 1rem;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .bubble.claimed .claimed-overlay-v3 {
            opacity: 1;
        }
        .bubble.claimed .open-button-v3 {
            display: none; /* é¢†å–åéšè—æŒ‰é’® */
        }
        
        /* --- 3. å·¦å›¾å³æ–‡å¡ç‰‡ (é€šç”¨åˆ†äº«) --- */
        .card-type-2 { display: flex; align-items: center; }
        .card-type-2 .card-image { width: 80px; height: 80px; object-fit: cover; flex-shrink: 0; }
        .card-type-2 .card-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 8px;
            flex-grow: 1;
            overflow: hidden;
        }
        .card-type-2 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* --- 4. å›¾æ ‡èšç„¦å¡ç‰‡ (ä½ç½®åˆ†äº«) --- */
        .card-type-3 { display: flex; align-items: center; padding: 16px; gap: 15px; }
        .card-type-3 .card-icon-area {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--theme-color-1);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .card-type-3 .card-icon-area i { font-size: 1.8rem; color: var(--text-color-white, white); }
        .card-type-3 .card-content { flex-grow: 1; }

        /* --- 5. æ–‡ä»¶ä¸‹è½½å¡ç‰‡ --- */
        .card-type-9 { display: flex; align-items: center; padding: 15px; gap: 15px; }
        .card-type-9 .file-icon { font-size: 3rem; color: var(--theme-color-4); }
        .card-type-9 .file-info { flex-grow: 1; overflow: hidden; }
        .card-type-9 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-type-9 .file-size { font-size: 0.8rem; color: var(--text-color-light); margin-top: 4px; }
        
        /* --- 6. ä¸»åŠ¨å›å¤ä¸æ—¶é—´æˆ³æ ·å¼ --- */
        .bubble.auto-reply-bubble {
            background: #E6F7FF; /* æ·¡è“è‰²èƒŒæ™¯ */
            border: 1px dashed #91D5FF; /* ç¨æ·±çš„è™šçº¿è¾¹æ¡† */
        }
        .message-timestamp {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-top: 5px;
            padding: 0 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .message-row.sent .message-timestamp {
            justify-content: flex-end;
        }
        .auto-reply-tag {
            font-size: 0.65rem;
            color: #1890FF;
            background-color: #E6F7FF;
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid #91D5FF;
        }
        /* --- 16. ä¸»é¢˜è®¾ç½®é¡µé¢ (æ–°) --- */
        #page-theme-settings .page-content {
            padding: 15px;
            background-color: rgba(0,0,0,0.02); /* ç»™é¡µé¢ä¸€ä¸ªæ·¡æ·¡çš„åº•è‰² */
        }

        .theme-setting-card {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            border-radius: 16px; /* æ›´å¤§çš„åœ†è§’ */
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: var(--shadow-light);
        }
        .theme-setting-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--text-color-dark);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        .theme-setting-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .theme-page-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px; /* æŒ‰é’®åœ†è§’ */
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
            background-color: var(--text-color-white);
            color: var(--text-color-dark);
            border: 1px solid var(--border-color);
        }
        .theme-page-btn:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* é¢œè‰²é€‰æ‹©å¼¹çª— */
        .color-palette-modal-body {
            display: flex;
            justify-content: space-around; /* æ°´å¹³æ’åˆ— */
            align-items: center;
            gap: 15px;
            padding: 20px 0;
        }
        .color-picker-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .color-picker-wrapper input[type="color"] {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            padding: 0;
        }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }

        /* ä¸Šä¼ ç»„ä»¶ */
        .theme-upload-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        .theme-upload-preview-wrapper {
            position: relative;
            width: 120px;
            height: 80px;
            flex-shrink: 0;
        }
        .theme-upload-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            background-color: #e9e9e9;
            border: 1px solid var(--border-color);
        }
        /* ç¾½åŒ–æ•ˆæœ */
        .theme-upload-preview-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            box-shadow: inset 0 0 10px 5px rgba(255, 255, 255, 0.9);
            pointer-events: none;
        }
        /* --- 17. æ•™ç¨‹é¡µé¢ (æ–°) --- */
        #page-tutorial {
            background-color: #fff !important;
            background-image: none !important;
        }
        .tutorial-watermark {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: #d0d0d0;
            pointer-events: none;
            user-select: none;
            text-align: right; /* æ–°å¢ï¼šè®©æ–‡å­—å³å¯¹é½ */
        }
    </style>
</head>
<body>
    <!-- å¼€å±åŠ¨ç”» -->
    <div id="splash-screen">
        <div class="splash-logo">33èŠå¤©å®¤</div>
        <div class="splash-loader"></div>
        <p style="position: absolute; bottom: 20px; font-size: 12px; color: #aaa; user-select: none;">æ­¤èŠå¤©å®¤ç”±33åˆ¶ä½œï¼Œxhs:@å›é£</p>
    </div>
    <div id="app-container">
        <!-- é¡¶éƒ¨æµ®çª—é€šçŸ¥å®¹å™¨ -->
        <div id="top-notification-container"></div>
        <!-- ä¸»å†…å®¹åŒºåŸŸ -->
        <main id="main-content">
            <!-- æ¶ˆæ¯åˆ—è¡¨é¡µé¢ -->
            <div id="page-messages" class="page active">
                <div class="page-header">
                    <img id="my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="My Avatar">
                    <h1>æ¶ˆæ¯</h1>
                    <a href="https://www.xiaohongshu.com/user/profile/5e65e0f00000000001002837?xsec_token=YBen3b8AVcwS9WjKSzS_xETWKfb3hsoxlS1uX8KTmQLSU%3D&xsec_source=app_share&xhsshare=CopyLink&appuid=5e65e0f00000000001002837&apptime=1751753800&share_id=a6aa049960ff46489ba8080e8cc476d0&share_channel=copy_link" target="_blank" id="header-link-btn">
                        <i class="fas fa-lightbulb"></i>
                    </a>
                </div>
                <div class="page-content">
                    <ul id="message-list-ul" class="message-list">
                        <!-- æ¶ˆæ¯é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                    </ul>
                </div>
            </div>

            <!-- é€šè®¯å½•é¡µé¢ -->
            <div id="page-contacts" class="page">
                <div class="page-header">
                    <div class="header-icon" style="visibility: hidden;"></div> <!-- å ä½ç¬¦ -->
                    <h1>é€šè®¯å½•</h1>
                    <div id="add-menu-btn" class="header-icon"><i class="fas fa-plus"></i></div>
                </div>
                <div class="tabs">
                    <button class="tab-btn active" data-tab="friends">å¥½å‹</button>
                    <button class="tab-btn" data-tab="groups">ç¾¤èŠ</button>
                </div>
                <div class="page-content" style="padding: 0 15px;">
                    <div id="contacts-friends" class="contact-section active">
                        <div class="contact-list-header">
                            <span id="sort-friends-btn" class="sort-btn">æ’åº <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="friends-list-ul" class="contact-list"></ul>
                    </div>
                    <div id="contacts-groups" class="contact-section">
                        <div class="contact-list-header">
                            <span id="sort-groups-btn" class="sort-btn">æ’åº <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="groups-list-ul" class="contact-list"></ul>
                    </div>
                </div>
            </div>

            <!-- è®¾ç½®é¡µé¢ -->
            <div id="page-settings" class="page">
                <div class="page-header">
                    <h1>è®¾ç½®</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="setting-tutorial">
                            <i class="fas fa-question-circle"></i>
                            <span>33é£Ÿç”¨æŒ‡å—</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <!-- æ–°å¢çš„èŠå¤©è®¾ç½®é¡¹ -->
                        <div class="setting-item" id="setting-chat">
                            <i class="fas fa-comments"></i>
                            <span>èŠå¤©è®¾ç½®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-api">
                            <i class="fas fa-server"></i>
                            <span>API é…ç½®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-prompts">
                            <i class="fas fa-magic"></i>
                            <span>è‡ªå®šä¹‰æç¤ºè¯</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-theme">
                            <i class="fas fa-palette"></i>
                            <span>ä¸»é¢˜è®¾ç½®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="setting-reset">
                            <i class="fas fa-trash-alt"></i>
                            <span>é‡ç½®åº”ç”¨</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- èŠå¤©é¡µé¢ -->
            <div id="page-chat" class="page">
                <div class="page-header">
                    <div id="chat-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <div class="header-title-wrapper">
                        <h1 class="header-title" id="chat-title"></h1>
                        <div class="typing-indicator-container" id="chat-typing-indicator">
                            <span>å¯¹æ–¹æ­£åœ¨è¾“å…¥...</span>
                        </div>
                    </div>
                    <div id="chat-manage-btn" class="header-icon"><i class="fas fa-ellipsis-v"></i></div> 
                </div>
                <div class="chat-area" id="chat-area">
                    <div id="history-loader"><div class="loader-spinner"></div></div>
                    <!-- æ¶ˆæ¯æ°”æ³¡å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div class="chat-input-area" id="chat-input-area">
                    <!-- å¼•ç”¨é¢„è§ˆåŒºåŸŸ -->
                    <div class="quote-preview-area" id="quote-preview-area">
                        <div class="quote-preview-content" id="quote-preview-content"></div>
                        <button class="cancel-quote-btn" id="cancel-quote-btn" title="å–æ¶ˆå¼•ç”¨">Ã—</button>
                    </div>

                    <!-- è¾“å…¥å’Œå‘é€è¡Œ -->
                    <div class="input-top-row">
                        <button id="ai-request-btn"><i class="fas fa-feather-alt"></i></button>
                        <textarea id="message-input" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="1"></textarea>
                        <button id="send-btn"><i class="fas fa-paper-plane"></i></button>
                    </div>

                    <!-- åŠŸèƒ½æŒ‰é’®è¡Œ -->
                    <div class="input-feature-row">
                        <button class="feature-btn" id="emoji-btn" title="å‘é€è¡¨æƒ…"><i class="fas fa-smile"></i></button>
                        <button class="feature-btn" id="favorite-emoji-btn" title="æ”¶è—çš„è¡¨æƒ…"><i class="fas fa-star"></i></button>
                        <button class="feature-btn" id="voice-btn" title="å‘é€è¯­éŸ³"><i class="fas fa-microphone"></i></button>
                        <button class="feature-btn" id="transfer-btn" title="è½¬è´¦"><i class="fas fa-wallet"></i></button>
                        <button class="feature-btn" id="red-packet-btn" title="å‘çº¢åŒ…"><i class="fas fa-gift"></i></button>
                        <button class="feature-btn" id="simulated-image-btn" title="å›¾æ–‡æ¶ˆæ¯"><i class="fas fa-image"></i></button>
                    </div>
                    <!-- è¡¨æƒ…åŒ…é¢æ¿ (é»˜è®¤éšè—) -->
                    <div class="emoji-card" id="emoji-card">
                        <div class="emoji-grid" id="emoji-grid"></div>
                        <div class="emoji-nav">
                            <button id="emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="emoji-page-indicator"></span>
                            <button id="emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                    <!-- æ”¶è—è¡¨æƒ…åŒ…é¢æ¿ (é»˜è®¤éšè—) -->
                    <div class="emoji-card" id="favorite-emoji-card">
                        <div class="emoji-grid" id="favorite-emoji-grid"></div>
                        <div class="emoji-nav" style="display: none;">
                            <button id="favorite-emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="favorite-emoji-page-indicator"></span>
                            <button id="favorite-emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è‡ªå®šä¹‰æç¤ºè¯é¡µé¢ -->
            <div id="page-prompts" class="page">
                <div class="page-header">
                    <div id="prompts-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>è‡ªå®šä¹‰æç¤ºè¯</h1>
                    <div id="prompt-header-actions" style="display: flex; gap: 15px; justify-self: end; padding-right: 15px;">
                        <div id="import-prompts-btn" class="header-icon" title="å¯¼å…¥"><i class="fas fa-download"></i></div>
                        <div id="export-prompts-btn" class="header-icon" title="å¯¼å‡º"><i class="fas fa-upload"></i></div>
                        <div id="add-prompt-folder-btn" class="header-icon" title="æ–°å»ºæ–‡ä»¶å¤¹"><i class="fas fa-folder-plus"></i></div>
                    </div>
                </div>
                <div class="page-content" id="prompts-page-content">
                    <!-- æ–‡ä»¶å¤¹å’Œæç¤ºè¯å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="add-new-prompt-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-plus-circle"></i> æ–°å»ºæç¤ºè¯</button>
                </div>
            </div>

            <!-- å‘ç°é¡µé¢ -->
            <div id="page-discover" class="page">
                <div class="page-header">
                    <h1>å‘ç°</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="nav-to-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>æœ‹å‹åœˆ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ä¸»é¢˜è®¾ç½®é¡µé¢ (æ–°) -->
            <div id="page-theme-settings" class="page">
                <div class="page-header">
                    <div id="theme-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>ä¸»é¢˜è®¾ç½®</h1>
                </div>
                <div class="page-content" id="theme-settings-content">
                    <!-- å¡ç‰‡å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <!-- æœ‹å‹åœˆé¡µé¢ -->
            <div id="page-moments" class="page">
                <!-- æ–°å¢çš„åŒ…è£¹å±‚ -->
                <div id="moments-wrapper">
                    <div class="page-header">
                        <div id="moments-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                        <div id="moments-actions-group">
                             <div id="moments-refresh-btn" class="header-icon"><i class="fas fa-sync-alt"></i></div>
                             <div id="moments-new-post-btn" class="header-icon"><i class="fas fa-camera"></i></div>
                             <div id="moments-manage-btn" class="header-icon"><i class="fas fa-bars"></i></div>
                        </div>
                    </div>
                    <div class="page-content">
                        <div class="moments-header-container">
                            <img id="moments-bg" src="https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png" alt="æœ‹å‹åœˆèƒŒæ™¯">
                            <div class="moments-profile-info">
                                <span id="moments-my-name" class="name">ä½ çš„åå­—</span>
                                <img id="moments-my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="ä½ çš„å¤´åƒ" class="avatar">
                            </div>
                        </div>
                        <ul id="moments-list">
                            <!-- æœ‹å‹åœˆåŠ¨æ€å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                        </ul>
                    </div>
                </div> <!-- æ–°å¢çš„åŒ…è£¹å±‚é—­åˆæ ‡ç­¾ -->
            </div>
            <!-- æ•™ç¨‹é¡µé¢ (æ–°) -->
            <div id="page-tutorial" class="page">
                <div class="page-header">
                    <div id="tutorial-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>æ•™ç¨‹</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="tutorial-api">
                            <i class="fas fa-key"></i>
                            <span>å¦‚ä½•é…ç½®API</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-character">
                            <i class="fas fa-user-plus"></i>
                            <span>å¦‚ä½•åˆ›å»ºæ–°è§’è‰²</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-group">
                            <i class="fas fa-users"></i>
                            <span>å¦‚ä½•åˆ›å»ºç¾¤èŠ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-chatting">
                            <i class="fas fa-comment-alt"></i>
                            <span>å¦‚ä½•è¿›è¡ŒèŠå¤©</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-opening-scene">
                            <i class="fas fa-scroll"></i>
                            <span>å¼€åœºç™½æ˜¯ä»€ä¹ˆï¼Ÿ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-prompts">
                            <i class="fas fa-magic"></i>
                            <span>æç¤ºè¯æ˜¯ä»€ä¹ˆï¼Ÿ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="tutorial-import-export">
                            <i class="fas fa-exchange-alt"></i>
                            <span>å¦‚ä½•å¯¼å…¥å¯¼å‡º</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>æœ‹å‹åœˆå¦‚ä½•ä½¿ç”¨</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-theme">
                            <i class="fas fa-palette"></i>
                            <span>å¦‚ä½•è®¾ç½®ä¸»é¢˜</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                    <div class="tutorial-watermark">
                        <span>æ­¤èŠå¤©å®¤ç”±33åˆ¶ä½œï¼Œxhs:@å›é£ã€‚</span><br>
                        <span style="font-size: 0.9em; opacity: 0.8;">åŠŸèƒ½åé¦ˆä¸æ–°åŠŸèƒ½éœ€æ±‚å¯è”ç³»æˆ‘å™¢âŒ¯>á´—oâŒ¯ .áŸ.áŸ</span>
                    </div>
                </div>
            </div>
        </main>

        <!-- åº•éƒ¨å¯¼èˆª -->
        <nav id="bottom-nav">
            <div class="nav-item active" data-page="messages">
                <i class="fas fa-comment-dots"></i>
                <span>æ¶ˆæ¯</span>
            </div>
            <div class="nav-item" data-page="contacts">
                <i class="fas fa-address-book"></i>
                <span>é€šè®¯å½•</span>
            </div>
            <div class="nav-item" data-page="discover">
                <i class="fas fa-compass"></i>
                <span>å‘ç°</span>
            </div>
            <div class="nav-item" data-page="settings">
                <i class="fas fa-cog"></i>
                <span>è®¾ç½®</span>
            </div>
        </nav>
    </div>


    <!-- æ¨¡æ€æ¡† -->
    <input type="file" id="import-data-input" accept=".json" style="display: none;">
    <div id="modal-overlay">
        <div id="modal-content-wrapper" class="modal-content">
            <!-- æ¨¡æ€æ¡†å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
    
    <!-- ç‚¹å‡»ç‰¹æ•ˆå±‚ -->
    <div id="click-effect-layer"></div>


    
    <!-- ä¸ªäººä¿¡æ¯ä¾§è¾¹æ  -->
    <div id="sidebar-overlay">
        <div id="sidebar-content">
            <!-- ä¾§è¾¹æ å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <!-- åº•éƒ¨é€‰æ‹©å™¨ -->
    <div id="bottom-sheet-overlay">
        <div id="bottom-sheet-content-wrapper" class="bottom-sheet-content">
             <!-- å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <input type="file" id="moments-bg-input" accept="image/*" style="display: none;">
    <input type="file" id="import-prompts-input" accept=".json" style="display: none;">

<script>
    
    (function() {
        'use strict';

        
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        
        const appContainer = $('#app-container');
        const mainContent = $('#main-content');
        const bottomNav = $('#bottom-nav');
        const modalOverlay = $('#modal-overlay');
        const modalContentWrapper = $('#modal-content-wrapper');
        const clickEffectLayer = $('#click-effect-layer');
        
        
        const pages = {
            messages: $('#page-messages'),
            contacts: $('#page-contacts'),
            discover: $('#page-discover'),
            moments: $('#page-moments'),
            tutorial: $('#page-tutorial'),
            settings: $('#page-settings'),
            'theme-settings': $('#page-theme-settings'), 
            chat: $('#page-chat'),
            prompts: $('#page-prompts'),
        };

        
        const chatTitle = $('#chat-title');
        const chatTypingIndicator = $('#chat-typing-indicator');
        const chatArea = $('#chat-area');
        const aiRequestBtn = $('#ai-request-btn');
        const messageInput = $('#message-input');
        const sendBtn = $('#send-btn');
        const chatBackBtn = $('#chat-back-btn');
        
        const emojiBtn = $('#emoji-btn');
        const voiceBtn = $('#voice-btn');
        const emojiCard = $('#emoji-card');
        const emojiGrid = $('#emoji-grid');
        const quotePreviewArea = $('#quote-preview-area');
        const quotePreviewContent = $('#quote-preview-content');
        const cancelQuoteBtn = $('#cancel-quote-btn');
        const favoriteEmojiBtn = $('#favorite-emoji-btn');
        const favoriteEmojiCard = $('#favorite-emoji-card');
        const favoriteEmojiGrid = $('#favorite-emoji-grid');
        const chatInputArea = $('#chat-input-area');
        
        const appState = {
            currentPage: 'messages',
            currentChatId: null,
            currentCircleId: null, 
            momentsLastRefresh: 0, 
            theme: 'neumorphic',
            contactsSortOrder: 'asc',
            groupsSortOrder: 'asc',
            quotingMessage: null,
            longPressTimer: null,
            cardCoverLibrary: [
                'https://z.wiki/u/fHMKzJ',
                'https://z.wiki/u/hmSAIR',
                'https://z.wiki/u/YWUcea',
                'https://z.wiki/u/dDuLcP',
                'https://z.wiki/u/JQtgF6',
                'https://z.wiki/u/bVpr6w',
                'https://z.wiki/u/dVvZ7t'
            ],
            emojiCurrentPage: 0,
            emojisPerPage: 8,
            favoriteEmojis: [],
            favoriteEmojiCurrentPage: 0,
            aiEmojiMap: {
      'iazCCF': 'è°åœ¨å–Šæœ¬å¤§ç‹',
      'xPHzNC': 'å°Šå˜Ÿå‡å˜Ÿ',
      '7kVeZJ': 'æˆ‘æ“',
      'pCQgk2': 'è€å­ç”Ÿæ°”äº†',
      'IUg8vO': 'åƒç“œç¾¤ä¼—',
      'Il6dL9': 'å¯¹ä¸èµ·',
      'vjEl6R': 'èŠ±èŠ±é€ä½ ',
      'werDxS': 'æŠ±æŠ±æˆ‘',
      'Ms5AEa': 'å§”å±ˆ(å¯çˆ±)',
      'QX7VnJ': 'å®‰æ…°',
      'nHcfqI': 'å–èŒ(å¯çˆ±)',
      'oztxES': 'æ¯”å¿ƒ(å¯çˆ±)',
      'GOl2dp': 'è¯·å’Œæˆ‘çº¦ä¼š',
      'BuD0Gy': 'ä½ æ˜¯ç‹—',
      'jcisbx': 'æˆ‘åªæ˜¯ä¸€åªç‹—',
      'Zo82H7': 'æ¯å¤©éƒ½æƒ³ä½ (å–èŒ)',
      'CcIWXl': 'å‡è£…æ— è¾œ(å¯çˆ±)',
      'zSBHMm': 'è‚¯å®š(å¯çˆ±)',
      'CIWud3': 'è°æ„¿æ„æ”¶ç•™æˆ‘(å¯çˆ±)',
      'HOAcPN': 'è°„åªš(å¯çˆ±)',
      'GP1VJ3': 'å®¶é‡Œäº¤ç»™æˆ‘å§(å¯çˆ±)',
      'BISbnP': 'æ³ªäº†',
      'asnj6B': 'è¯•æ¢(å¯çˆ±)',
      'htNZls': 'æ‡‚å¾—éƒ½æ‡‚',
      '2q5VbM': 'å°±ä½ å°å­æ˜¯å§(åš£å¼ )',
      'sd0yQX': 'æ”¾å¿ƒäº¤ç»™æˆ‘ï¼Œæˆ‘ä¼šæç ¸çš„(æ²™é›•)',
      'E0PrxD': 'çš‡å¸é©¾åˆ°(æ²™é›•)',
      '7vgm7D': 'çš‡å¸é©¾å´©(æ²™é›•)',
      'lPgzpQ': 'è¯›ä½ ä¹æ—(é¾™å›¾)',
      'j2d9di': 'éª‚æœ•ï¼Œæ»¡é—¨æŠ„æ–©ï¼',
      'hKyKwP': 'å¥´æ‰è°¢ä¸»éš†æ©(é¾™å›¾)',
      'IkZP8N': 'æˆ‘é¥¿äº†',
      'osIpSG': 'æ€ä¹ˆä¸å›æˆ‘æ¶ˆæ¯',
      'IgfF9w': 'å¿«ç†æˆ‘(å§”å±ˆå¯çˆ±)',
      'wb63Ag': 'ç­‰ä¸‹è®²ä½ ä½ åˆä¸é«˜å…´(åæ§½)',
      '8CCMsJ': 'æˆ‘é ï¼Œä½ çˆ±ä¸çˆ±æˆ‘',
      '34LcOG': 'æŒ‡æŒ‡ç‚¹ç‚¹',
      'hDpVH8': 'æˆ‘å—ï¼Ÿ(æ‡µé€¼)',
      '1RcY8W': 'æ³¨æ„ä½ çš„æ€åº¦',
      '6cIfGp': 'æ€¥å¾—è¹¬è…¿',
      'm1zzxd': 'ä¸æƒ³æ´»äº†(æ²™é›•)',
      'YqlPWK': 'ä½ å’Œæˆ‘è¿™ä¸ªç¥ç»ç—…è®¡è¾ƒä»€ä¹ˆ',
      'LokqQT': 'ä½ å¾ˆç‰›å—ï¼Ÿ',
      'qHSXVP': 'å¦ˆçš„ï¼Œè¢«çœ‹æ‰äº†',
      'CUOA6Y': 'ä»¤äººç«å¤§',
      '3jc0XI': 'ä¸æƒ³æ´»äº†(å¯çˆ±)',
      'qZxeWV': 'ä½ å¿«å“„æˆ‘(å¯çˆ±)',
      '3iYdgX': 'æˆ‘è¢«å“„å¥½äº†(å¯çˆ±)',
      'ZNzgpY': 'ä½ å°±æ˜¯å¾ˆå¥½å¾ˆå¥½(å¯çˆ±)',
      'PCLA8G': 'æˆ‘å¥½æƒ³ä½ å–(å§”å±ˆå¯çˆ±)',
      'i0UYTS': 'ä½ ç§ä¸èµ·æˆ‘(å§”å±ˆ)',
      'VWwt5c': 'æˆ‘æƒ³è¦è¿™ä¸ª(å¯çˆ±)',
      'SIWqFT': 'å¾—æ„',
      'ff8JWS': 'æˆ‘èäº†',
      'oiMaM6': 'ä½ ç²¾ç¥æ­£å¸¸å—',
      'LIQKcy': 'æƒ³æ­»',
      'EhcgEa': 'è¢«çœ‹ç©¿äº†',
      'vnDXiy': 'æ€ä¹ˆä½ è¦æ‰“æ­»æˆ‘å—(çŠ¯è´±)',
      '71bINa': 'ä½ å°‘çœ‹æ‰æˆ‘(è‡ªå˜²ç†Š)',
      'gcubY9': 'tui(åå£æ°´)',
      'r1lada': 'ä½ å¤ªç²˜äººäº†_æŠŠä½ æ‹¿å»ç²˜è€é¼ ',
      'y6ldmK': 'å¾ˆä¸é«˜å…´ä¸ºä½ æœåŠ¡',
      'yrVneI': 'çœŸè´±å•Š',
      'dP6HDY': 'ä½ è‡ªé¦–å§',
      'jjyR6G': 'ä½ æ˜¯çŒª',
      'WfSWCe': 'ä½ ä»–å¦ˆè°å•Š',
      'B0S4LA': 'è’™åœˆ'
            },
            playerEmojiMap: {
      'iazCCF': 'è°åœ¨å–Šæœ¬å¤§ç‹',
      'xPHzNC': 'å°Šå˜Ÿå‡å˜Ÿ',
      '7kVeZJ': 'æˆ‘æ“',
      'pCQgk2': 'è€å­ç”Ÿæ°”äº†',
      'IUg8vO': 'åƒç“œç¾¤ä¼—',
      'Il6dL9': 'å¯¹ä¸èµ·',
      'vjEl6R': 'èŠ±èŠ±é€ä½ ',
      'werDxS': 'æŠ±æŠ±æˆ‘',
      'Ms5AEa': 'å§”å±ˆ(å¯çˆ±)',
      'QX7VnJ': 'å®‰æ…°',
      'nHcfqI': 'å–èŒ(å¯çˆ±)',
      'oztxES': 'æ¯”å¿ƒ(å¯çˆ±)',
      'GOl2dp': 'è¯·å’Œæˆ‘çº¦ä¼š',
      'BuD0Gy': 'ä½ æ˜¯ç‹—',
      'jcisbx': 'æˆ‘åªæ˜¯ä¸€åªç‹—',
      'Zo82H7': 'æ¯å¤©éƒ½æƒ³ä½ (å–èŒ)',
      'CcIWXl': 'å‡è£…æ— è¾œ(å¯çˆ±)',
      'zSBHMm': 'è‚¯å®š(å¯çˆ±)',
      'CIWud3': 'è°æ„¿æ„æ”¶ç•™æˆ‘(å¯çˆ±)',
      'HOAcPN': 'è°„åªš(å¯çˆ±)',
      'GP1VJ3': 'å®¶é‡Œäº¤ç»™æˆ‘å§(å¯çˆ±)',
      'BISbnP': 'æ³ªäº†',
      'asnj6B': 'è¯•æ¢(å¯çˆ±)',
      'htNZls': 'æ‡‚å¾—éƒ½æ‡‚',
      '2q5VbM': 'å°±ä½ å°å­æ˜¯å§(åš£å¼ )',
      'sd0yQX': 'æ”¾å¿ƒäº¤ç»™æˆ‘ï¼Œæˆ‘ä¼šæç ¸çš„(æ²™é›•)',
      'E0PrxD': 'çš‡å¸é©¾åˆ°(æ²™é›•)',
      '7vgm7D': 'çš‡å¸é©¾å´©(æ²™é›•)',
      'lPgzpQ': 'è¯›ä½ ä¹æ—(é¾™å›¾)',
      'j2d9di': 'éª‚æœ•ï¼Œæ»¡é—¨æŠ„æ–©ï¼',
      'hKyKwP': 'å¥´æ‰è°¢ä¸»éš†æ©(é¾™å›¾)',
      'IkZP8N': 'æˆ‘æœ‰ç‚¹é¥¿äº†',
      'osIpSG': 'æ€ä¹ˆä¸å›æˆ‘æ¶ˆæ¯',
      'Lt1f9K': 'ç‰¹åˆ«ç‰¹åˆ«é¥¿',
      'IgfF9w': 'å¿«ç†æˆ‘(å§”å±ˆ)',
      'wb63Ag': 'ç­‰ä¸‹è®²ä½ ä½ åˆä¸é«˜å…´(åæ§½)',
      's9xWmu': 'ä½ æ˜¯ä¸ªåä¸œè¥¿',
      '8CCMsJ': 'æˆ‘é ï¼Œä½ çˆ±ä¸çˆ±æˆ‘',
      '34LcOG': 'æŒ‡æŒ‡ç‚¹ç‚¹',
      'hDpVH8': 'æˆ‘å—ï¼Ÿ(æ‡µé€¼)',
      '1RcY8W': 'æ³¨æ„ä½ çš„æ€åº¦',
      '6cIfGp': 'æ€¥å¾—è¹¬è…¿',
      'kRdQhe': 'å·å¬',
      '3jc0XI': 'ä¸æƒ³æ´»äº†(å¯çˆ±)',
      'm1zzxd': 'ä¸æƒ³æ´»äº†(æ²™é›•)',
      'YqlPWK': 'ä½ å’Œæˆ‘è¿™ä¸ªç¥ç»ç—…è®¡è¾ƒä»€ä¹ˆ',
      'LokqQT': 'ä½ å¾ˆç‰›å—ï¼Ÿ',
      '4ZkXRx': 'ä»–ä»¬éƒ½æ¬ºè´Ÿæˆ‘',
      'qZxeWV': 'ä½ å¿«å“„æˆ‘',
      '3iYdgX': 'æˆ‘è¢«å“„å¥½äº†(å¯çˆ±)',
      'qHSXVP': 'å¦ˆçš„ï¼Œè¢«çœ‹æ‰äº†',
      '278MJW': 'ä¸åŠªåŠ›å°±ä¼šæˆä¸ºå¥³äººçš„ç©ç‰©',
      'mzqDku': 'æˆ‘å–œæ¬¢ä½ (å®³ç¾)',
      'dnzCAP': 'ä»€ä¹ˆéƒ½æƒ³å’Œä½ è¯´',
      'ZNzgpY': 'ä½ å°±æ˜¯å¾ˆå¥½å¾ˆå¥½(å¯çˆ±)',
      'PCLA8G': 'æˆ‘å¥½æƒ³ä½ å–(å§”å±ˆ)',
      'sf7Egt': 'æˆ‘å»æ´—æ¾¡å•¦(å¯çˆ±)',
      'i0UYTS': 'ä½ ç§ä¸èµ·æˆ‘(å§”å±ˆ)',
      'VWwt5c': 'æˆ‘æƒ³è¦è¿™ä¸ª',
      'hMTJRH': 'å’Œä½ è´´è´´',
      'CUOA6Y': 'ä»¤äººç«å¤§',
      'Y06FYQ': 'æˆ‘æ˜¯å°å­©ï¼Œè®©æˆ‘(å¯çˆ±)',
      'lFpXLU': 'å†å«å‰ªäº†ä½ çš„å°é¸¡é¸¡',
      'RaogpF': 'æ²¡åŠæ³•äººå®¶å°±æ˜¯å¥½è‰²å˜›',
      '7a48eQ': 'ä½ æ€ä¹ˆé¸¡8å°å°çš„ï¼Œè¯´è¯åŠåŠçš„',
      'N3ZzUs': 'æ‹¿æ¥å§ä½ ',
      'oGFqYZ': 'å‡ºæ¥äº²å˜´',
      'Z3glHK': 'åœæ­¢æ€è€ƒ',
      '9RWtTB': 'ä½ äººçœŸå¥½ï¼Œéƒ½æƒ³å’Œä½ è°ˆæ‹çˆ±äº†',
      'KNRPfQ': 'æ²¡äººçˆ±æˆ‘(æ°ç‘çŒ«è¡¨æƒ…)',
      'bpyimG': 'èµ·äº†æ€å¿ƒ',
      'DOwyrR': 'ç»™ä½ ç‚¹äº†(èµåŒ,æŠ½è±¡)',
      'fd1o0q': 'æˆ‘æ˜¯å›½å®¶ä¸€çº§ä¿æŠ¤åºŸç‰©(çŒ«å’ªè‘›ä¼˜ç˜«)',
      '0liCnk': 'ä¸­(è‚¯å®šçš„æ„æ€)',
      'wTC4Ha': 'å®ŒåŠ›(å®Œäº†)',
      'n0Ll5b': 'æ— åŠ›',
      'SIWqFT': 'å¾—æ„',
      '2up6Um': 'å˜å˜å¤§ç¬‘',
      'tLsCTf': 'ä¸è®¸ç¬‘äº†',
      'ff8JWS': 'æˆ‘èäº†',
      'oiMaM6': 'ä½ ç²¾ç¥æ­£å¸¸å—',
      'LIQKcy': 'æƒ³æ­»',
      'EhcgEa': 'è¢«çœ‹ç©¿äº†',
      'vnDXiy': 'æ€ä¹ˆä½ è¦æ‰“æ­»æˆ‘å—(çŠ¯è´±)',
      '71bINa': 'ä½ å°‘çœ‹æ‰æˆ‘(è‡ªå˜²ç†Š)',
      'eDzCRs': 'ç–‘æƒ‘',
      'gcubY9': 'tui(åå£æ°´)',
      'r1lada': 'ä½ å¤ªç²˜äººäº†_æŠŠä½ æ‹¿å»ç²˜è€é¼ ',
      'y6ldmK': 'å¾ˆä¸é«˜å…´ä¸ºä½ æœåŠ¡',
      'yrVneI': 'çœŸè´±å•Š',
      'dP6HDY': 'ä½ è‡ªé¦–å§',
      'OFcKsy': 'å‹¾å¼•æˆ‘æ˜¯å§',
      'jjyR6G': 'ä½ æ˜¯çŒª',
      'WfSWCe': 'ä½ ä»–å¦ˆè°å•Š',
      'ZbqhUq': 'å·²è¯»ä¸å›',
      'B0S4LA': 'è’™åœˆ',
      '3sp60p': 'ä¸åšè¯„ä»·(é¾™å›¾)',
      'VIbUBK': 'ä½ æ˜¯å°‘çˆ·å—',
      'RjmyAc': 'ä¸‹çº¿äº†å…„å¼ŸèŒ(ä»¬)',
      'y2w7BR': 'ä¸€è¾¹å»(é¾™å›¾)',
      'fyYVhV': 'ç³Ÿç³•çš„è¯æ— éœ€å†è¯´(æŠ½è±¡)',
      'PT4fq1': 'åœ¨å¹²å˜›_å‘¼å¸ä¹Ÿè¦å’Œæˆ‘è¯´ä¸€å£°å•Š',
      'wBBj7q': 'è€å­æƒ¹ä½ æ²¡',
      '3Yb2hM': 'èµ„æœ¬ä½ èµ¢äº†',
      '9K6IPq': 'è„‘å­æœ‰é—®é¢˜',
      'jHsXmD': 'æˆ‘ä»¬ä¸è¦å­¦ä»–',
      'khoGur': 'åˆšç¡é†’(è‡ªå˜²ç†Š)',
      '0svPHM': 'æƒ³å“­(è‡ªå˜²ç†Š)',
      '39cQOS': 'å˜»å˜»(è‡ªå˜²ç†Š)',
      '4wZWjY': 'å°´å°¬ä¸€ç¬‘(é»„è±†)',
      'YaiPfJ': 'æˆ‘è¶…_ä»€ä¹ˆå¯„å§',
      'mxDIwM': 'æ¬ºè´Ÿæ²¡åŠ›æ°”çš„æˆ‘ä½ å¼€å¿ƒå—',
      'HIRelu': 'å¤šæ‰¾æ‰¾ä½ è‡ªå·±çš„åŸå› ',
      'RNgGNY': 'ä»¥åä¸ä¼šå’Œä½ åˆ†äº«äº†(å§”å±ˆ)',
      'GWn8O2': 'å˜¬å˜¬å˜¬',
      'SwNPaw': 'ä½ ä»¬å¥½ä¼šè£…é€¼å•Š',
      'tDB1Sp': 'å¤å©šå¥½å—ï¼Œå­©å­æ€»å“­',
      'mWU2m4': 'ä½ æ´»è¿™ä¹ˆä¹…ï¼Œå’Œæˆ‘ç¡ä¸¤å¤©æ€ä¹ˆäº†',
      'YCRn9a': 'æˆ‘åï¼Œå¥¹å¥½ï¼Œè¡Œäº†å§',
      't7vGt6': 'å½“æˆ‘æ„è¯†åˆ°ç”Ÿæ´»çš„ç¼©å†™æ˜¯SMï¼Œæˆ‘çš„ç—›è‹¦å°±å…¨è¯´å¾—æ¸…äº†',
      '5AaDlW': 'æœ¬æ¥æŒºæƒ³ä½ çš„_åæ¥ç©æ‰‹æœºå¿˜äº†',
      'a2gifR': 'å·å·è°ˆæ‹çˆ±æ²¡äº‹_åˆ«å·å·å‘è´¢å¥½å—',
      'BI9YDr': 'è’å”',
      'ScbsVz': 'æˆ‘è¦æŠ¥è­¦',
      'yVU6HV': 'æœ‰è¶£ï¼Œè‰äº†',
      'WRy68R': 'ä½å£°äº›_éš¾é“å…‰å½©å—',
      'vHBtBv': 'åä¸ç¡(æŠ½è±¡è¡¨æƒ…)',
      'IvfqD7': 'è£…å¯æ€œ(æŠ½è±¡)',
      'E7e2MS': 'å¤Ÿäº†(æŠ½è±¡)',
      'OWcn1K': 'å‡è£…æ‡‚äº†',
      'pk06Iq': 'ä½ æ˜¯åç‹—(å¯çˆ±)'
            },
            currentChat: {
                allMessages: [],
                renderedCount: 0,
            },
            messagesPerLoad: 20,
            isHistoryLoading: false,
        };

        
        const DBHelper = {
            DB_NAME: 'AIChatRoomDB',
            DB_VERSION: 1,
            db: null,

            async init() {
                
                this.DB_VERSION = 10;

                return new Promise((resolve, reject) => {
                    if (this.db) {
                        return resolve(this.db);
                    }
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    request.onerror = (event) => {
                        console.error("æ•°æ®åº“æ‰“å¼€å¤±è´¥", event);
                        reject("æ•°æ®åº“æ‰“å¼€å¤±è´¥");
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("æ•°æ®åº“æ‰“å¼€æˆåŠŸ");
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        console.log("æ•°æ®åº“å‡çº§ä¸­...");
                        const db = event.target.result;
                        const transaction = event.target.transaction;
                        
                        
                        if (!db.objectStoreNames.contains('profile')) {
                            db.createObjectStore('profile', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('contacts')) {
                            const store = db.createObjectStore('contacts', { keyPath: 'id' });
                            store.createIndex('name', 'name', { unique: true });
                            store.createIndex('createdAt', 'createdAt', { unique: false });
                        }
                        if (!db.objectStoreNames.contains('groups')) {
                             const store = db.createObjectStore('groups', { keyPath: 'id' });
                             store.createIndex('createdAt', 'createdAt', { unique: false });
                        }
                        if (!db.objectStoreNames.contains('chats')) {
                            db.createObjectStore('chats', { keyPath: 'chatId' });
                        }
                        if (!db.objectStoreNames.contains('apiConfig')) {
                            db.createObjectStore('apiConfig', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('openingScenes')) {
                            const store = db.createObjectStore('openingScenes', { keyPath: 'id' });
                            store.createIndex('groupId', 'groupId', { unique: false });
                            store.createIndex('contactId', 'contactId', { unique: false }); 
                        } else {
                            
                            const store = transaction.objectStore('openingScenes');
                            if (!store.indexNames.contains('contactId')) {
                                store.createIndex('contactId', 'contactId', { unique: false });
                                console.log("ä¸º 'openingScenes' è¡¨æ·»åŠ  'contactId' ç´¢å¼•æˆåŠŸ");
                            }
                        }
                        

                        if (!db.objectStoreNames.contains('prompts')) {
                             const store = db.createObjectStore('prompts', { keyPath: 'id' });
                             store.createIndex('name', 'name', { unique: false });
                             store.createIndex('folderId', 'folderId', { unique: false });
                             console.log("åˆ›å»º 'prompts' è¡¨æˆåŠŸ");
                        }
                        if (!db.objectStoreNames.contains('promptFolders')) {
                             const store = db.createObjectStore('promptFolders', { keyPath: 'id' });
                             store.createIndex('name', 'name', { unique: true });
                             console.log("åˆ›å»º 'promptFolders' è¡¨æˆåŠŸ");
                        }
                        if (!db.objectStoreNames.contains('circles')) {
                             const store = db.createObjectStore('circles', { keyPath: 'id' });
                             store.createIndex('name', 'name', { unique: true });
                             console.log("åˆ›å»º 'circles' è¡¨æˆåŠŸ");
                        }
                        if (!db.objectStoreNames.contains('moments')) {
                             const store = db.createObjectStore('moments', { keyPath: 'id' });
                             store.createIndex('circleId', 'circleId', { unique: false });
                             store.createIndex('timestamp', 'timestamp', { unique: false });
                             console.log("åˆ›å»º 'moments' è¡¨æˆåŠŸ");
                        }
                        
                        console.log("æ•°æ®åº“å‡çº§å®Œæˆ");
                    };
                });
            },


            async get(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Get error from ${storeName}: ${e.target.error}`);
                });
            },

            async getAll(storeName, indexName, sortOrder = 'next') {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const index = indexName ? store.index(indexName) : store;
                    const request = index.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`GetAll error from ${storeName}: ${e.target.error}`);
                });
            },

            async put(storeName, item) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(item);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Put error in ${storeName}: ${e.target.error}`);
                });
            },

            async delete(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = (e) => reject(`Delete error from ${storeName}: ${e.target.error}`);
                });
            },
        };

        
        const Utils = {
            generateId(prefix) {
                return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            },
            
            getRandomColor() {
                const colors = ['#F4E8DD', '#EDD4D8', '#CCD4CC', '#B5BFCF', '#E8A0BF'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            createAvatarDataUrl(color) {
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50"><rect width="50" height="50" fill="${color}"/></svg>`;
                return `data:image/svg+xml;base64,${btoa(svg)}`;
            },

            formatTimestampSmartly(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();

                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterdayStart = new Date(todayStart);
                yesterdayStart.setDate(yesterdayStart.getDate() - 1);
                
                const formatTime = (d) => d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                
                if (date >= todayStart) {
                    
                    return formatTime(date);
                } else if (date >= yesterdayStart) {
                    
                    return `æ˜¨å¤© ${formatTime(date)}`;
                } else {
                    
                    return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) + ' ' + formatTime(date);
                }
            },

            formatTimestampForPrompt(timestamp) {
                const d = new Date(timestamp);
                return `${d.getMonth() + 1}æœˆ${d.getDate()}æ—¥ ${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`;
            },

            compressImage(file, maxWidth = 800, maxHeight = 800, quality = 0.7) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');

                            let width = img.width;
                            let height = img.height;

                            if (width > height) {
                                if (width > maxWidth) {
                                    height = Math.round(height * (maxWidth / width));
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width = Math.round(width * (maxHeight / height));
                                    height = maxHeight;
                                }
                            }

                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);

                            resolve(canvas.toDataURL(file.type, quality));
                        };
                        img.onerror = reject;
                    };
                    reader.onerror = reject;
                });
            },

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            },

            parseMomentTimestamp(timeStr) { 
                if (!timeStr) return Date.now();
                const now = new Date();
                const year = now.getFullYear();
                const [datePart, timePart] = timeStr.split(' ');
                if (!datePart || !timePart) return Date.now();

                const [month, day] = datePart.split('/');
                const [hour, minute] = timePart.split(':');
                
                
                const parsedDate = new Date(year, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));
                
                
                if (parsedDate > now) {
                    parsedDate.setFullYear(year - 1);
                }
                
                return parsedDate.getTime();
            }
        };

        
        const UIManager = {
            notificationQueue: [],
            isDisplayingNotification: false,
       async navigateTo(pageId, fromPage = null) {
            if (!pages[pageId]) return;

            
            if (['chat', 'prompts', 'moments', 'tutorial'].includes(pageId)) { 
                bottomNav.style.display = 'none';
            } else {
                bottomNav.style.display = 'flex';
            }

            
            $$('#bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.page === pageId);
            });

            
            Object.values(pages).forEach(page => page.classList.remove('active'));
            pages[pageId].classList.add('active');
            appState.currentPage = pageId;
            appState.fromPage = fromPage; 
            
            
            switch(pageId) {
                case 'messages': await this.renderMessagesListPage(); break;
                case 'contacts': await this.renderContactsPage(); break;
                case 'discover':  break;
                case 'moments': await this.renderMomentsPage(); break;
                case 'settings': break; 
                case 'theme-settings': await EventManager.renderThemeSettingsPage(); break;
                case 'prompts': await EventManager.renderPromptsPage(); break;
            }
        },

            async renderMessagesListPage() {
                const messageListUl = $('#message-list-ul');
                messageListUl.innerHTML = '';
                const chats = await DBHelper.getAll('chats');
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                if (chats.length === 0) {
                    messageListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">è¿˜æ²¡æœ‰æ¶ˆæ¯ï¼Œå¿«å»é€šè®¯å½•æ‰¾å¥½å‹èŠå¤©å§~</li>`;
                    return;
                }
                
                let combinedChats = [];

                for (const chat of chats) {
                    if (!chat.history || chat.history.length === 0) continue;

                    
                    const displayableHistory = chat.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                    
                    
                    if (displayableHistory.length === 0) continue;

                    const lastMessage = displayableHistory[displayableHistory.length - 1];
                    
                    
                    let unreadCount = chat.history.filter(m => m.isUnread).length;
                    
                    let chatInfo = {
                        id: chat.chatId,
                        lastMessageContent: lastMessage.content,
                        lastMessageTimestamp: lastMessage.timestamp,
                        unreadCount: unreadCount,
                    };
                    
                    let isGroupChat = false;

                    if (chat.chatId.startsWith('contact-')) {
                        const contact = contacts.find(c => c.id === chat.chatId);
                        if(contact) {
                            chatInfo.name = contact.remark || contact.name;
                            chatInfo.avatar = contact.avatar;
                        } else continue;
                    } else if (chat.chatId.startsWith('group-')) {
                        isGroupChat = true;
                        const group = groups.find(g => g.id === chat.chatId);
                        if(group) {
                            chatInfo.name = group.name;
                            chatInfo.avatar = group.avatar;
                        } else continue;
                    }

                    
                    switch (lastMessage.segmentType) {
                        case 'emoji-image':
                            
                            const emojiDesc = appState.playerEmojiMap[lastMessage.content];
                            chatInfo.lastMessageContent = emojiDesc ? `[è¡¨æƒ…] ${emojiDesc}` : '[æœªçŸ¥è¡¨æƒ…]';
                            break;
                        case 'image_simulated': 
                            chatInfo.lastMessageContent = '[å›¾ç‰‡]';
                            break;
                        case 'card':
                            
                            if (lastMessage.cardData) {
                                chatInfo.lastMessageContent = `[${lastMessage.cardData.shareType} ${lastMessage.cardData.title}]`;
                            } else {
                                chatInfo.lastMessageContent = '[åˆ†äº«]'; 
                            }
                            break;
                        case 'voice':
                            chatInfo.lastMessageContent = '[è¯­éŸ³]';
                            break;
                        case 'transfer':
                            chatInfo.lastMessageContent = '[è½¬è´¦]';
                            break;
                        case 'red-packet':
                            chatInfo.lastMessageContent = '[çº¢åŒ…]';
                            break;
                        case 'moment_forward':
                            chatInfo.lastMessageContent = '[è½¬å‘åŠ¨æ€]';
                            break;
                        
                    }

                    
                    if (lastMessage.isRetracted) {
                        chatInfo.lastMessageContent = '[ä¸€æ¡æ¶ˆæ¯è¢«æ’¤å›]';
                    }
                    
                    
                    
                    if (isGroupChat && lastMessage.type === 'received') {
                         const sender = contacts.find(c => c.id === lastMessage.senderId);
                         if(sender) {
                             chatInfo.lastMessageContent = `${sender.remark || sender.name}: ${chatInfo.lastMessageContent}`;
                         }
                    }
                    
                    combinedChats.push(chatInfo);
                }
                
                combinedChats.sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);

                combinedChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'message-item';
                    li.dataset.chatId = chat.id;
                    li.innerHTML = `
                        <img src="${chat.avatar}" alt="avatar" class="item-avatar">
                        <div class="item-content">
                            <div class="item-name">${chat.name}</div>
                            <div class="item-last-msg">${chat.lastMessageContent}</div>
                        </div>
                        <div class="item-info">
                            <div class="item-time">${Utils.formatTimestampSmartly(chat.lastMessageTimestamp)}</div>
                            ${chat.unreadCount > 0 ? `<div class="unread-badge">${chat.unreadCount}</div>` : ''}
                        </div>
                    `;
                    li.addEventListener('click', () => this.openChat(chat.id));
                    messageListUl.appendChild(li);
                });
            },

            async renderContactsPage(tab = 'friends') {
                $$('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
                $$('.contact-section').forEach(sec => sec.classList.toggle('active', sec.id.includes(tab)));

                if (tab === 'friends') {
                    const friends = await DBHelper.getAll('contacts');
                    friends.sort((a, b) => {
                        return appState.contactsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#friends-list-ul'), friends, 'contact');
                } else {
                    const groups = await DBHelper.getAll('groups');
                     groups.sort((a, b) => {
                        return appState.groupsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#groups-list-ul'), groups, 'group');
                }
            },
            
            renderContactList(ulElement, items, type) {
                ulElement.innerHTML = '';
                if (items.length === 0) {
                    ulElement.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">ç©ºç©ºå¦‚ä¹Ÿ~</li>`;
                    return;
                }
                items.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'contact-item';
                    li.dataset.id = item.id;
                    li.innerHTML = `
                        <img src="${item.avatar}" alt="avatar" class="contact-item-avatar">
                        <span class="contact-item-name">${type === 'contact' ? (item.remark || item.name) : item.name}</span>
                        ${type === 'contact' 
                            ? `<i class="fas fa-info-circle contact-info-btn" data-id="${item.id}"></i>` 
                            : `<i class="fas fa-ellipsis-h contact-info-btn" data-id="${item.id}"></i>`
                        }
                    `;
                    
                    li.addEventListener('click', (e) => {
                        if (e.target.classList.contains('contact-info-btn')) return;
                        this.openChat(item.id);
                    });
                    
                    
                    const infoBtn = li.querySelector('.contact-info-btn');
                    if (infoBtn) {
                        infoBtn.addEventListener('click', (e) => {
                           e.stopPropagation();
                           if (type === 'contact') {
                               this.showContactInfo(item.id);
                           } else {
                               this.showGroupInfo(item.id);
                           }
                        });
                    }

                    ulElement.appendChild(li);
                });
            },

        async openChat(chatId) {
            appState.currentChatId = chatId;
            const isGroup = chatId.startsWith('group-');
            let target;
            if (isGroup) {
                target = await DBHelper.get('groups', chatId);
            } else {
                target = await DBHelper.get('contacts', chatId);
            }

            if (!target) {
                this.showModal({
                    title: "é”™è¯¯",
                    body: `<p>æ‰¾ä¸åˆ°è¯¥èŠå¤©å¯¹è±¡ï¼Œå¯èƒ½å·²è¢«åˆ é™¤ã€‚</p>`,
                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => this.hideModal() }]
                });
                return;
            }

            chatTitle.textContent = isGroup ? target.name : (target.remark || target.name);

            
            const chatData = await DBHelper.get('chats', chatId) || { chatId, history: [], lastAiReplyTimestamp: 0 };
            let madeChanges = false;
            chatData.history.forEach(msg => {
                if (msg.isUnread) {
                    msg.isUnread = false;
                    madeChanges = true;
                }
            });
            if (madeChanges) {
                await DBHelper.put('chats', chatData);
            }
             
            
            if (isGroup) {
                for (const memberId of target.members) {
                    const privateChat = await DBHelper.get('chats', memberId);
                    if (privateChat && privateChat.history) {
                         let privateChatMadeChanges = false;
                        privateChat.history.forEach(msg => {
                            if (msg.isUnread && msg.isPrivateInGroup) {
                                msg.isUnread = false;
                                privateChatMadeChanges = true;
                            }
                        });
                        if (privateChatMadeChanges) {
                            await DBHelper.put('chats', privateChat);
                        }
                    }
                }
            }

            
            await this.refreshChatView();
            this.navigateTo('chat');

            
            await UIManager.applyChatBackground(chatId);
            

            
            setTimeout(() => {
                chatArea.scrollTop = chatArea.scrollHeight;
            }, 50);

            
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            const intervalHours = chatSettings.activeReplyInterval || 3;
            const lastAiTimestamp = chatData.lastAiReplyTimestamp || 0;
            const now = Date.now();
            const elapsedHours = (now - lastAiTimestamp) / (1000 * 60 * 60);

            if (lastAiTimestamp > 0 && elapsedHours >= intervalHours) {
                console.log(`è·ç¦»ä¸Šæ¬¡AIå›å¤å·²è¿‡å» ${elapsedHours.toFixed(2)} å°æ—¶ï¼Œå·²è¾¾åˆ°è®¾å®šçš„ ${intervalHours} å°æ—¶ï¼Œè§¦å‘ä¸»åŠ¨å›å¤ã€‚`);
                
                setTimeout(() => {
                    AIHandler.handleActiveReplyRequest(lastAiTimestamp);
                }, 500);
            } else {
                if (lastAiTimestamp > 0) {
                    console.log(`è·ç¦»ä¸Šæ¬¡AIå›å¤å·²è¿‡å» ${elapsedHours.toFixed(2)} å°æ—¶ï¼Œæœªè¾¾åˆ°è®¾å®šçš„ ${intervalHours} å°æ—¶ï¼Œä¸è§¦å‘ä¸»åŠ¨å›å¤ã€‚`);
                } else {
                    console.log(`è¿™æ˜¯æœ¬ä¼šè¯ç¬¬ä¸€æ¬¡ä¸AIäº¤äº’æˆ–æ— å†å²è®°å½•ï¼Œä¸è§¦å‘ä¸»åŠ¨å›å¤ã€‚`);
                }
            }
        },

        async refreshChatView() {
            if (!appState.currentChatId) return;

            const chatData = await DBHelper.get('chats', appState.currentChatId);
            appState.currentChat.allMessages = chatData ? chatData.history : [];
            appState.currentChat.renderedCount = 0;
            
            chatArea.innerHTML = ''; 
            const loaderHTML = '<div id="history-loader"><div class="loader-spinner"></div></div>';
            chatArea.insertAdjacentHTML('beforeend', loaderHTML);

            await this.loadMoreMessages();
            
            setTimeout(() => {
                chatArea.scrollTop = chatArea.scrollHeight;
            }, 10);
        },

        async loadMoreMessages() {
            if (appState.isHistoryLoading) return;
            
            const { allMessages, renderedCount } = appState.currentChat;
            const loader = $('#history-loader');

            if (renderedCount >= allMessages.length) {
                if(loader) loader.remove();
                return;
            }

            appState.isHistoryLoading = true;
            if (loader) loader.classList.add('visible');

            
            await new Promise(resolve => setTimeout(resolve, 300));

            const startIndex = Math.max(0, allMessages.length - renderedCount - appState.messagesPerLoad);
            const endIndex = allMessages.length - renderedCount;
            const messagesToLoad = allMessages.slice(startIndex, endIndex);

            if (messagesToLoad.length === 0) {
                if (loader) loader.remove();
                appState.isHistoryLoading = false;
                return;
            }

            const fragment = document.createDocumentFragment();
            let lastTimestamp = (startIndex > 0) ? allMessages[startIndex - 1].timestamp : 0;
            const profile = await DBHelper.get('profile', 'myProfile');
            const contacts = await DBHelper.getAll('contacts');

            
            const absoluteLastMessage = allMessages.length > 0 ? allMessages[allMessages.length - 1] : null;

            for (const msg of messagesToLoad.reverse()) { 
                if (['inner_voice', 'essay'].includes(msg.segmentType)) {
                    continue; 
                }
                if (msg.isHidden) {
                    continue;
                }
                let messageElement;
                
                let senderInfo;
                if (msg.senderInfo) {
                    senderInfo = msg.senderInfo;
                } else {
                    senderInfo = (msg.type === 'sent') ? profile : contacts.find(c => c.id === msg.senderId) || { name: 'æœªçŸ¥æˆå‘˜', avatar: Utils.createAvatarDataUrl('#ccc') };
                }

                if (msg.isRetracted) {
                    messageElement = this.createRetractionNotice(msg, senderInfo);
                } else if (msg.segmentType === 'system') {
                    messageElement = document.createElement('div');
                    messageElement.className = 'system-notice';
                    messageElement.textContent = msg.content;
                } else {
                    messageElement = await this.createMessageElement(msg, senderInfo);
                }
                fragment.prepend(messageElement); 

                
                const isTheVeryLastMessage = absoluteLastMessage && msg.messageId === absoluteLastMessage.messageId;
                if (lastTimestamp > 0 && msg.timestamp - lastTimestamp > 5 * 60 * 1000 && !isTheVeryLastMessage) {
                    const timeDiv = this.createTimeDividerElement(msg.timestamp);
                    fragment.prepend(timeDiv);
                }
                lastTimestamp = msg.timestamp;
            }

            const oldScrollHeight = chatArea.scrollHeight;
            loader.after(fragment);
            chatArea.scrollTop = chatArea.scrollHeight - oldScrollHeight;

            appState.currentChat.renderedCount += messagesToLoad.length;
            if (loader) loader.classList.remove('visible');
            appState.isHistoryLoading = false;

            
            if (appState.currentChat.renderedCount >= appState.currentChat.allMessages.length) {
                if (loader) loader.remove();
            }
        },

        async createMessageElement(msg, senderInfo, isTyping = false, isAnimating = false) {
            const messageRow = document.createElement('div');
            messageRow.className = `message-row ${msg.type}`;
            
            if (!isTyping) {
                messageRow.id = msg.messageId;
                messageRow.dataset.messageId = msg.messageId;
            }

            let bubbleContent = '';
            let bubbleClass = 'bubble';
            let detailContent = ''; 
            
            
            if (msg.isAutoReply) {
                bubbleClass += ' auto-reply-bubble';
            }

            if (isTyping) {
                bubbleClass += ` bubble-typing`;
                bubbleContent = `<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>`;
            } else {
                 switch(msg.segmentType) {
                    case 'emoji-image':
                        bubbleClass += ` bubble-emoji`;
                        bubbleContent = `<img src="https://z.wiki/u/${msg.content}" alt="${appState.playerEmojiMap[msg.content] || 'è¡¨æƒ…'}">`;
                        break;
                    case 'image_simulated':
                        bubbleClass += ' image-with-desc-bubble';
                        bubbleContent = `
                            ${msg.cardData.imageSrc ? `<img src="${msg.cardData.imageSrc}" alt="å›¾ç‰‡">` : ''}
                            <div class="description-text">${msg.cardData.description}</div>
                        `;
                        break;
                    case 'voice':
                        bubbleClass += ' voice-message-bubble';
                        bubbleContent = `<span class="voice-duration">${msg.cardData.duration}</span><div class="voice-wave"><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div></div>`;
                        detailContent = `<div class="voice-transcript">${msg.cardData.content}</div>`;
                        break;
                    case 'quote':
                        bubbleClass += ' quote-message-bubble';
                        bubbleContent = `<div class="quote-block"><span class="quoted-name">${msg.cardData.quotedName}:</span><span>${msg.cardData.quotedContent}</span></div><div>${msg.cardData.newContent}</div>`;
                        break;
                    case 'transfer':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimed) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const transferCoverStyle = themeSettings.transferCover ? `background-image: url(${themeSettings.transferCover}); background-size: cover; background-position: center;` : '';
                            
                            bubbleContent = `
                                <div class="transfer-content-v3" style="${transferCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-right-left transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>è½¬è´¦ç»™ ${msg.cardData.recipientName}</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    ${msg.cardData.note ? `<div class="transfer-footer-v3">${msg.cardData.note}</div>` : ''}
                                </div>
                            `;
                        }
                        break;
                    case 'transfer-receipt':
                        bubbleClass += ' received'; 
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const receiptCoverStyle = themeSettings.receiptCover ? `background-image: url(${themeSettings.receiptCover}); background-size: cover; background-position: center;` : '';
                            
                            bubbleContent = `
                                 <div class="transfer-content-v3" style="${receiptCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-check-circle transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>å·²æ”¶æ¬¾</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    <div class="transfer-footer-v3">æ¥è‡ª ${msg.cardData.senderName} çš„è½¬è´¦</div>
                                </div>
                            `;
                        }
                        
                        if (!bubbleClass.includes('claimed')) bubbleClass += ' claimed';
                        break;
                    case 'red-packet':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimedByPlayer) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const defaultCover = 'https://z.wiki/u/IDzEvp';
                            const rpCover = themeSettings.redPacketCover || defaultCover;
                            
                            bubbleContent = `
                                <div class="red-packet-v3-wrapper">
                                    <div class="rp-cover-v3" style="background-image: url('${rpCover}');">
                                        <h4 class="rp-title-v3">${msg.cardData.title}</h4>
                                        <div class="open-button-v3">
                                            <i class="fas fa-paw"></i>
                                        </div>
                                    </div>
                                    <div class="claimed-overlay-v3">å·²é¢†å–</div>
                                </div>
                            `;
                        }
                        break;
                    case 'card':
                        bubbleClass += ' card-bubble';
                        const cardId = `card-detail-${msg.messageId}`;
                        let cardInnerHtml = '';
                        
                        switch(msg.cardData.shareType) {
                            case 'åœ°ç‚¹åˆ†äº«': cardInnerHtml = `<div class="card-message-wrapper card-type-3" data-card-id="${cardId}"><div class="card-icon-area" style="background-color: var(--theme-color-1);"><i class="fas fa-map-marker-alt"></i></div><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`; break;
                            case 'æ–‡ä»¶åˆ†äº«': cardInnerHtml = `<div class="card-message-wrapper card-type-9" data-card-id="${cardId}"><i class="fas fa-file-archive file-icon" style="color: var(--theme-color-4);"></i><div class="file-info"><h4>${msg.cardData.title}</h4><div class="file-size">${msg.cardData.summary}</div></div></div>`; break;
                            default:
                                const randomCover = appState.cardCoverLibrary[Math.floor(Math.random() * appState.cardCoverLibrary.length)];
                                cardInnerHtml = `<div class="card-message-wrapper card-type-2" data-card-id="${cardId}"><img src="${randomCover}" class="card-image" alt="Card image"><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`;
                                break;
                        }
                        
                        const cardDetailHtml = `<div class="card-detail-content" id="${cardId}"><h5>${msg.cardData.title}</h5><p>${msg.cardData.details}</p></div>`;
                        
                        bubbleContent = cardInnerHtml + cardDetailHtml;
                        detailContent = ''; 
                        break;
                    case 'moment_forward':
                        bubbleClass += ' forwarded-moment-bubble';
                        bubbleContent = `
                            <div class="forwarded-moment-card-content" data-moment-id="${msg.cardData.momentId}">
                                <h4 class="card-title">[æœ‹å‹åœˆåŠ¨æ€]</h4>
                                <p class="card-preview">${msg.cardData.authorName}ï¼š${msg.cardData.preview}</p>
                                <div class="card-footer">æœ‹å‹åœˆ</div>
                            </div>
                        `;
                        break;
                    case 'text':
                    default:
                        bubbleContent = msg.content;
                        break;
                }
            }
            
            bubbleClass += ` ${msg.type}`;
            const avatarSrc = (isTyping && msg.isGroupTyping) ? senderInfo.avatar : (senderInfo.avatar || Utils.createAvatarDataUrl('#ccc'));
            const avatarClass = `message-avatar ${isTyping && msg.isGroupTyping ? 'group-avatar-style' : ''}`;
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            const isGroup = appState.currentChatId.startsWith('group-');
            const isMyMessage = msg.type === 'sent';
            let displayNameHtml = '';
            
            
            let timestampHtml = '';
            if (msg.isAutoReply && msg.displayTimestamp) {
                timestampHtml = `
                    <div class="message-timestamp">
                        <span>${msg.displayTimestamp}</span>
                        <span class="auto-reply-tag">æœªè¯»æ¶ˆæ¯</span>
                    </div>
                `;
            }

            if (!isTyping && !['transfer-receipt'].includes(msg.segmentType)) {
                if (isGroup) {
                    if (!isMyMessage) displayNameHtml = `<div class="message-name">${senderInfo.remark || senderInfo.name}</div>`;
                    else if (chatSettings.showMyNameInGroup) displayNameHtml = `<div class="message-name">${senderInfo.name}</div>`;
                } else {
                    if (chatSettings.showNamesInPrivate) displayNameHtml = `<div class="message-name">${isMyMessage ? senderInfo.name : (senderInfo.remark || senderInfo.name)}</div>`;
                }
            }
            
            messageRow.innerHTML = `<img src="${avatarSrc}" alt="avatar" class="${avatarClass}"><div class="message-content">${displayNameHtml}<div class="bubble-and-tag-wrapper"><div class="${bubbleClass}">${bubbleContent}</div>${detailContent}</div>${timestampHtml}</div>`;

            const avatarEl = messageRow.querySelector('.message-avatar');
            if (!isTyping) {
                avatarEl.style.cursor = 'pointer';
                if (msg.type === 'received') {
                    avatarEl.addEventListener('click', () => this.showPersonaModal(msg.senderId));
                } else if (msg.type === 'sent') {
                    avatarEl.addEventListener('click', () => AIHandler.handleRegenerateRequest(msg.messageId));
                }
            }
            return messageRow;
        },

        async addMessageToDOM(msg, senderInfo, isTyping = false, isAnimating = false) {
            if (msg.isHidden) return;
            
            const messageElement = await this.createMessageElement(msg, senderInfo, isTyping, isAnimating);
            
            
            if (isTyping && msg.messageId) {
                messageElement.id = msg.messageId;
            }

            chatArea.appendChild(messageElement);
            
            if(!isTyping) {
                appState.currentChat.allMessages.push(msg);
                appState.currentChat.renderedCount++;
            }
            chatArea.scrollTop = chatArea.scrollHeight;
        },
        
        createTimeDividerElement(timestamp) {
            const timeDiv = document.createElement('div');
            timeDiv.className = 'time-divider';
            timeDiv.textContent = Utils.formatTimestampSmartly(timestamp);
            return timeDiv;
        },
            
            createRetractionNotice(msg, senderInfo) {
                const notice = document.createElement('div');
                notice.className = 'retracted-notice';
                const isGroup = appState.currentChatId.startsWith('group-');
                const senderName = msg.type === 'sent' ? 'ä½ ' : (senderInfo.remark || senderInfo.name);
                notice.textContent = `${senderName} æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                
                notice.addEventListener('click', () => {
                    let retractedContentHtml = '';
                    if (msg.segmentType === 'emoji-image') {
                        retractedContentHtml = `<img src="https://z.wiki/u/${msg.content}" style="max-width: 150px; display: block; margin: 10px auto;">`;
                    } else {
                        retractedContentHtml = `<p style="line-height: 1.6;">${msg.content}</p>`;
                    }
                    this.showModal({
                        title: "è¢«æ’¤å›çš„æ¶ˆæ¯",
                        body: retractedContentHtml,
                        actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });
                return notice;
            },

            async showPersonaModal(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                const chatData = await DBHelper.get('chats', appState.currentChatId);
                const personaMessages = chatData.history.filter(m => m.senderId === contactId && (m.segmentType === 'inner_voice' || m.segmentType === 'essay'));
                
                const lastInnerVoice = personaMessages.filter(m => m.segmentType === 'inner_voice').pop();
                const lastEssay = personaMessages.filter(m => m.segmentType === 'essay').pop();

                let bodyHtml = `
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
                        <img src="${contact.avatar}" style="width: 70px; height: 70px; border-radius: 12px; object-fit: cover;">
                        <div>
                            <h3 style="font-size: 1.4rem; margin-bottom: 5px;">${contact.remark || contact.name}</h3>
                            <p style="color: #888;">ID: ${contact.name}</p>
                        </div>
                    </div>
                `;

                if (lastInnerVoice) {
                    bodyHtml += `
                        <div class="persona-modal-card">
                            <h4>å¿ƒå£°</h4>
                            <p>${lastInnerVoice.content}</p>
                        </div>
                    `;
                }

                if (lastEssay) {
                     bodyHtml += `
                        <div class="persona-modal-card note-paper">
                            <h4>éšç¬”</h4>
                            <p>${lastEssay.content}</p>
                        </div>
                    `;
                }

                this.showModal({
                    title: "è§’è‰²æ´å¯Ÿ",
                    body: bodyHtml,
                    actions: [
                        { text: 'è¿›å…¥èŠå¤©', class: 'btn-primary', handler: () => {
                            this.hideModal();
                            this.openChat(contactId); 
                        }}
                    ]
                });
            },

            async showModal(config) {
                
                if (appState.theme === 'neumorphic' && !config.customClass) {
                    modalContentWrapper.classList.add('modal-neumorphic');
                } else if (config.customClass) {
                    modalContentWrapper.classList.add(config.customClass);
                }

                
                if (config.isPersistent) {
                    modalOverlay.classList.add('no-overlay-close');
                } else {
                    modalOverlay.classList.remove('no-overlay-close');
                }
                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions">` + config.actions.map((action, index) =>
                        `<button class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`
                    ).join('') + `</div>`;
                }

                modalContentWrapper.innerHTML = `
                    <h2 class="modal-header">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                if (config.actions) {
                    
                    $$('#modal-content-wrapper .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                modalOverlay.classList.add('visible');
            },

            hideModal() {
                modalOverlay.classList.remove('visible');
                
                modalContentWrapper.className = 'modal-content';
                modalContentWrapper.innerHTML = '';
            },
            
            showBottomSheet(config) {
                const sheetOverlay = $('#bottom-sheet-overlay');
                const sheetContent = $('#bottom-sheet-content-wrapper');

                sheetContent.className = 'bottom-sheet-content';

                sheetContent.innerHTML = `
                    <div class="bottom-sheet-header">${config.title}</div>
                    <div class="bottom-sheet-body">
                        ${config.items.map(item => `<div class="bottom-sheet-item" data-value="${item.value}">${item.text}</div>`).join('')}
                    </div>
                `;

                if (appState.theme === 'neumorphic') sheetContent.classList.add('neumorphic');
                if (config.customClass) sheetContent.classList.add(...config.customClass.split(' '));
                
                $$('.bottom-sheet-item').forEach(item => {
                    item.addEventListener('click', () => {
                        config.onSelect(item.dataset.value, item.textContent);
                        this.hideBottomSheet();
                    });
                });

                
                sheetOverlay.style.visibility = 'visible';
                requestAnimationFrame(() => {
                    sheetOverlay.classList.add('visible');
                });
            },

            hideBottomSheet() {
                const sheetOverlay = $('#bottom-sheet-overlay');
                sheetOverlay.classList.remove('visible');
                
                setTimeout(() => {
                    sheetOverlay.style.visibility = 'hidden';
                }, 300); 
            },

            showSidebar(config) {
                const sidebarContent = $('#sidebar-content');
                const sidebarOverlay = $('#sidebar-overlay');

                
                sidebarContent.className = 'sidebar-content';

                
                if (appState.theme === 'neumorphic') {
                    sidebarContent.classList.add('neumorphic');
                }

                
                if (config.position === 'left') {
                    sidebarContent.classList.add('sidebar-from-left');
                } else {
                    sidebarContent.classList.remove('sidebar-from-left');
                }

                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions" style="margin-top: 30px;">` + config.actions.map((action, index) =>
                        `<button class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`
                    ).join('') + `</div>`;
                }
                sidebarContent.innerHTML = `
                    <h2 class="modal-header" style="text-align: left; padding-left: 0;">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                
                if (config.actions) {
                    $$('#sidebar-content .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                
                sidebarOverlay.classList.add('visible');
            },

            hideSidebar() {
                const sidebarOverlay = $('#sidebar-overlay');
                const sidebarContent = $('#sidebar-content');
                
                sidebarOverlay.classList.remove('visible');
                
                
                setTimeout(() => {
                    sidebarContent.classList.remove('sidebar-from-left');
                }, 400); 
            },

            showToast(message, duration = 1000) {
                
                const existingToast = $('#toast-notification');
                if (existingToast) {
                    existingToast.remove();
                }

                const toast = document.createElement('div');
                toast.id = 'toast-notification';
                toast.className = 'toast-notification';
                toast.textContent = message;

                
                document.body.appendChild(toast);

                
                setTimeout(() => {
                    
                    toast.classList.add('hiding');
                    
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300); 
                }, duration);
            },

            showTopNotification(msg) {
                this.notificationQueue.push(msg);
                this.processNotificationQueue();
            },

            showEssayNotification(authorName, contactId) {
                
                if ($('.essay-notification-banner')) return;

                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'essay-notification-banner';
                banner.innerHTML = `
                    <div class="icon-wrapper">
                        <i class="fas fa-heart"></i>
                    </div>
                    <span class="text-content">${authorName} æ›´æ–°äº†éšç¬”</span>
                `;

                
                banner.addEventListener('click', () => {
                    this.showPersonaModal(contactId);
                    hideAndRemove();
                });

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };
                
                container.appendChild(banner);

                
                setTimeout(() => {
                    banner.classList.add('is-playing');
                }, 10);

                
                setTimeout(hideAndRemove, 4000);
            },

            processNotificationQueue() {
                if (this.isDisplayingNotification || this.notificationQueue.length === 0) {
                    return;
                }
                this.isDisplayingNotification = true;

                const msg = this.notificationQueue.shift();
                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'notification-banner';
                
                let messageContent = msg.content;
                if (msg.segmentType === 'emoji-image') messageContent = '[è¡¨æƒ…åŒ…]';
                else if (msg.segmentType === 'voice') messageContent = msg.cardData.content;
                else if (msg.isRetracted) messageContent = 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯';

                banner.innerHTML = `
                    <img src="${msg.senderInfo.avatar}" alt="avatar" class="notification-avatar">
                    <div class="notification-content">
                        <div class="notification-header">
                            <span class="notification-name">${msg.senderInfo.remark || msg.senderInfo.name}</span>
                            <span class="notification-time">${Utils.formatTimestampSmartly(msg.timestamp)}</span>
                        </div>
                        <p class="notification-message">${messageContent}</p>
                    </div>
                `;

                const hideAndProcessNext = () => {
                    if (!container.contains(banner)) return; 
                    clearTimeout(autoHideTimeout);
                    banner.style.animation = 'notification-exit 0.5s forwards';
                    setTimeout(() => {
                        if (container.contains(banner)) container.removeChild(banner);
                        this.isDisplayingNotification = false;
                        
                        setTimeout(() => this.processNotificationQueue(), 500);
                    }, 500);
                };

                const autoHideTimeout = setTimeout(hideAndProcessNext, 5000); 

                banner.addEventListener('click', () => {
                    this.openChat(msg.senderId);
                    hideAndProcessNext(); 
                });

                container.appendChild(banner);
            },

            async showContactInfo(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${contact.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${contact.remark || contact.name}</div>
                                <div class="id">ID: ${contact.name}</div>
                            </div>
                        </div>
                         <div class="details-field"><span class="label">æ€§åˆ«</span><span class="value">${contact.gender}</span></div>
                    </div>
                    <div class="details-card">
                       ${contact.likes ? `<div class="details-field"><span class="label">å–œå¥½</span><span class="value">${contact.likes}</span></div>` : ''}
                       ${contact.dislikes ? `<div class="details-field"><span class="label">åŒæ¶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                       ${contact.habits ? `<div class="details-field"><span class="label">ä¹ æƒ¯</span><span class="value">${contact.habits}</span></div>` : ''}
                       ${contact.background ? `<div class="details-section">
                            <div class="details-section-title">èƒŒæ™¯èµ„æ–™</div>
                            <p>${contact.background}</p>
                        </div>` : ''}
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">å‘æ¶ˆæ¯</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">å¯¼å‡ºè§’è‰²</button>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                             <button class="details-btn" data-action="edit" style="flex: 1;">ç¼–è¾‘</button>
                             <button class="details-btn btn-details-danger" data-action="delete" style="flex: 1;">åˆ é™¤å¥½å‹</button>
                        </div>
                    </div>
                `;

                this.showModal({
                    
                    title: `
                        <span style="flex-grow: 1;">è¯¦ç»†èµ„æ–™</span>
                        ${contact.author ? `<div class="details-header-attribution" data-action="show-attribution" title="æŸ¥çœ‹ä½œè€…ä¿¡æ¯" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: [] 
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';
                
                
                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(contactId);
                });
                modalContentWrapper.querySelector('[data-action="edit"]').addEventListener('click', () => {
                    this.hideModal();
                    
                    EventManager.showEditFriendModal(contactId, async () => {
                        await UIManager.renderContactsPage('friends');
                    });
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contactId));
                    this.confirmDeleteContact(contactId, isInGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportContact(contactId));
                
                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(contact));
                }
            },
            
            async showGroupInfo(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (!group) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                let creatorName = 'æœªçŸ¥';
                if (group.creatorId === myProfile.id) {
                    creatorName = `æˆ‘ (${myProfile.name})`;
                } else {
                    const creatorContact = allContacts.find(c => c.id === group.creatorId);
                    if (creatorContact) creatorName = creatorContact.remark || creatorContact.name;
                }
                
                const membersDetails = group.members
                    .map(memberId => allContacts.find(c => c.id === memberId))
                    .filter(Boolean);

                const membersHtml = membersDetails.map(member => `
                    <div class="member-item">
                        <img src="${member.avatar}" class="avatar" alt="${member.name}">
                        <span class="name">${member.remark || member.name}</span>
                    </div>
                `).join('');

                const isMyGroup = group.creatorId === myProfile.id;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${group.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${group.name}</div>
                                <div class="id">ç¾¤ä¸»: ${creatorName}</div>
                            </div>
                        </div>
                    </div>
                    <div class="details-card">
                        <div class="details-section-title">ç¾¤æˆå‘˜ (${group.members.length})</div>
                        <div class="member-grid">${membersHtml}</div>
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">å‘æ¶ˆæ¯</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">å¯¼å‡ºç¾¤èŠ</button>
                        <button class="details-btn btn-details-danger" data-action="delete">${isMyGroup ? 'è§£æ•£ç¾¤èŠ' : 'é€€å‡ºç¾¤èŠ'}</button>
                    </div>
                `;

                this.showModal({
                    title: `
                        <span style="flex-grow: 1;">ç¾¤èŠèµ„æ–™</span>
                        ${group.author ? `<div class="details-header-attribution" data-action="show-attribution" title="æŸ¥çœ‹ä½œè€…ä¿¡æ¯" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: []
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';

                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(groupId);
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', () => {
                    this.confirmDeleteGroup(groupId, isMyGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportGroup(groupId));

                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(group));
                }
            },
            
            confirmDeleteGroup(groupId, isCreator, onCancel) { 
                const actionText = isCreator ? 'è§£æ•£' : 'é€€å‡º';
                this.showModal({
                    title: `ç¡®è®¤${actionText}`,
                    body: `<p>ä½ ç¡®å®šè¦${actionText}æ­¤ç¾¤èŠå—ï¼Ÿæ‰€æœ‰èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºä¸”æ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            this.hideModal();
                            if (onCancel) {
                                onCancel();
                            } else {
                                this.showGroupInfo(groupId);
                            }
                        }},
                        { text: `ç¡®è®¤${actionText}`, class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('groups', groupId);
                            await DBHelper.delete('chats', groupId);
                            this.hideModal();
                            this.hideSidebar();
                            
                            await this.navigateTo('contacts');
                            await this.renderContactsPage('groups');
                        }}
                    ]
                });
            },
            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('ã€');
                    this.showModal({
                        title: "æ— æ³•åˆ é™¤",
                        body: `<p>æ— æ³•åˆ é™¤å¥½å‹ï¼Œå› ä¸ºå¯¹æ–¹ä»åœ¨ç¾¤èŠï¼š<strong>${groupNames}</strong> ä¸­ã€‚è¯·å…ˆå°†å…¶ç§»å‡ºç¾¤èŠæˆ–è§£æ•£ç¾¤èŠã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => this.showContactInfo(contactId) }]
                    });
                    return;
                }
                
                this.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤è¯¥å¥½å‹å—ï¼Ÿæ‰€æœ‰èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºä¸”æ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.showContactInfo(contactId) },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chats', contactId);
                            this.hideModal();
                            await this.renderContactsPage();
                        }}
                    ]
                });
            },
            async showGroupManagementSidebar(group) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const isMyGroup = group.creatorId === myProfile.id;
                
                
                this.showSidebar({
                    position: 'right', 
                    title: "ç¾¤èŠç®¡ç†",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-edit-group">
                                <i class="fas fa-edit"></i>
                                <span>ä¿®æ”¹ç¾¤èŠä¿¡æ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-members">
                                <i class="fas fa-users"></i>
                                <span>æŸ¥çœ‹ç¾¤æˆå‘˜</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-invite-members">
                                <i class="fas fa-user-plus"></i>
                                <span>é‚€è¯·æ–°æˆå‘˜</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ${isMyGroup ? `
                            <div class="setting-item" id="sidebar-remove-members">
                                <i class="fas fa-user-minus"></i>
                                <span>ç§»é™¤ç¾¤æˆå‘˜</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ` : ''}
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>ç»‘å®šæç¤ºè¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene">
                                <i class="fas fa-scroll"></i>
                                <span>å¼€åœºç™½è®¾å®š</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>ä¸“å±èŠå¤©èƒŒæ™¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-leave-group">
                                <i class="fas ${isMyGroup ? 'fa-dumpster-fire' : 'fa-door-open'}"></i>
                                <span>${isMyGroup ? 'è§£æ•£ç¾¤èŠ' : 'é€€å‡ºç¾¤èŠ'}</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                
                $('#sidebar-edit-group').addEventListener('click', () => {
                    this.showModal({
                        title: "ä¿®æ”¹ç¾¤èŠä¿¡æ¯",
                        body: `
                            <div class="form-group">
                                <label>ç¾¤å¤´åƒ</label>
                                <div class="avatar-uploader">
                                    <img src="${group.avatar}" id="group-manage-avatar-preview" class="avatar-preview">
                                    <input type="file" id="group-manage-avatar-input" accept="image/*" style="display:none;">
                                    <button class="upload-btn" onclick="document.getElementById('group-manage-avatar-input').click()">ä¸Šä¼ æ–°å¤´åƒ</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="group-manage-name">ç¾¤åç§°</label>
                                <input type="text" id="group-manage-name" value="${group.name}">
                            </div>
                        `,
                        actions: [
                            { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.hideModal() },
                            { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                                const newName = $('#group-manage-name').value.trim();
                                if (!newName) return;
                                const oldName = group.name;
                                const updatedGroup = { ...group, name: newName, avatar: $('#group-manage-avatar-preview').src };
                                await DBHelper.put('groups', updatedGroup);
                                chatTitle.textContent = newName;

                                if (oldName !== newName) {
                                    const myProfile = await DBHelper.get('profile', 'myProfile');
                                    const systemMessage = {
                                        messageId: Utils.generateId('msg'),
                                        content: `${myProfile.name} ä¿®æ”¹ç¾¤åä¸º â€œ${newName}â€`,
                                        timestamp: Date.now(),
                                        type: 'received',
                                        segmentType: 'system',
                                        forAi: true,
                                    };
                                    const chatData = await DBHelper.get('chats', group.id) || { chatId: group.id, history: [] };
                                    chatData.history.push(systemMessage);
                                    await DBHelper.put('chats', chatData);
                                    if (appState.currentChatId === group.id) {
                                        await UIManager.refreshChatView();
                                    }
                                }
                                this.hideModal();
                            }}
                        ]
                    });
                     $('#group-manage-avatar-input').addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) $('#group-manage-avatar-preview').src = await Utils.fileToBase64(file);
                    });
                });
                
                $('#sidebar-view-members').addEventListener('click', () => this.showGroupMemberListModal(group.id));
                $('#sidebar-invite-members').addEventListener('click', () => EventManager.handleInviteMembers(group.id));
                if (isMyGroup) {
                    $('#sidebar-remove-members').addEventListener('click', () => EventManager.handleRemoveMembers(group.id));
                }
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(group.id)); 
                $('#sidebar-opening-scene').addEventListener('click', () => EventManager.handleOpeningSceneSettings(group.id, true));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(group.id, true));
                $('#sidebar-leave-group').addEventListener('click', () => {
                    this.confirmDeleteGroup(group.id, isMyGroup, () => this.showGroupManagementSidebar(group));
                });
            },

            async showGroupMemberListModal(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                
                const aiMembers = group.members
                    .map(id => allContacts.find(c => c.id === id))
                    .filter(Boolean);

                
                const playerAsMember = {
                    id: myProfile.id,
                    avatar: myProfile.avatar,
                    name: myProfile.name,
                    isPlayer: true
                };

                
                const allParticipants = [...aiMembers, playerAsMember];

                
                let owner;
                const otherMembers = [];
                allParticipants.forEach(p => {
                    if (p.id === group.creatorId) {
                        owner = p;
                    } else {
                        otherMembers.push(p);
                    }
                });
                
                
                const finalOrderedList = owner ? [owner, ...otherMembers] : otherMembers;

                
                const membersHtml = finalOrderedList.map(member => `
                    <div class="member-list-modal-item">
                        <img src="${member.avatar}" alt="${member.name}">
                        <span>${member.remark || member.name}</span>
                        ${member.id === group.creatorId ? '<span class="owner-tag">ç¾¤ä¸»</span>' : ''}
                        ${member.isPlayer ? '<span class="owner-tag" style="background-color: var(--accent-color);">ä½ </span>' : ''}
                    </div>
                `).join('');

                this.showModal({
                    title: `ç¾¤æˆå‘˜ (${finalOrderedList.length})`,
                    body: `<div class="member-list-modal-body"><ul>${membersHtml}</ul></div>`,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => this.hideModal() }]
                });
            },

            async showFriendManagementSidebar(contact) {
                 
                 this.showSidebar({
                    position: 'right', 
                    title: "å¥½å‹ç®¡ç†",
                     body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-view-friend">
                                <i class="fas fa-info-circle"></i>
                                <span>æŸ¥çœ‹è¯¦ç»†èµ„æ–™</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-friend">
                                <i class="fas fa-user-edit"></i>
                                <span>ä¿®æ”¹å¥½å‹ä¿¡æ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>ç»‘å®šæç¤ºè¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene-friend">
                                <i class="fas fa-scroll"></i>
                                <span>å¼€åœºç™½è®¾å®š</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>ä¸“å±èŠå¤©èƒŒæ™¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-delete-friend">
                                <i class="fas fa-user-times"></i>
                                <span>åˆ é™¤å¥½å‹</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });

                
                $('#sidebar-view-friend').addEventListener('click', () => {
                     this.showModal({
                        title: "è¯¦ç»†èµ„æ–™",
                        body: `
                            <div class="details-card">
                                <div class="details-header"><img src="${contact.avatar}" class="avatar"><div class="details-info"><div class="name">${contact.remark || contact.name}</div><div class="id">ID: ${contact.name}</div></div></div>
                                <div class="details-field"><span class="label">æ€§åˆ«</span><span class="value">${contact.gender}</span></div>
                            </div>
                            <div class="details-card">
                               ${contact.likes ? `<div class="details-field"><span class="label">å–œå¥½</span><span class="value">${contact.likes}</span></div>` : ''}
                               ${contact.dislikes ? `<div class="details-field"><span class="label">åŒæ¶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                               ${contact.habits ? `<div class="details-field"><span class="label">ä¹ æƒ¯</span><span class="value">${contact.habits}</span></div>` : ''}
                               ${contact.background ? `<div class="details-section"><div class="details-section-title">èƒŒæ™¯èµ„æ–™</div><p>${contact.background}</p></div>` : ''}
                            </div>
                        `,
                        actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });

                $('#sidebar-edit-friend').addEventListener('click', () => {
                    EventManager.showEditFriendModal(contact.id);
                });
                
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(contact.id)); 
                $('#sidebar-opening-scene-friend').addEventListener('click', () => EventManager.handleOpeningSceneSettings(contact.id, false));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(contact.id, false));
                $('#sidebar-delete-friend').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contact.id));
                    this.confirmDeleteContact(contact.id, isInGroup);
                });
            },


            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('ã€');
                    this.showModal({
                        title: "æ— æ³•åˆ é™¤",
                        body: `<p>æ— æ³•åˆ é™¤å¥½å‹ï¼Œå› ä¸ºå¯¹æ–¹ä»åœ¨ç¾¤èŠï¼š<strong>${groupNames}</strong> ä¸­ã€‚è¯·å…ˆå°†å…¶ç§»å‡ºæˆ–è§£æ•£ç›¸å…³ç¾¤èŠã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                    return;
                }
                
                this.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤è¯¥å¥½å‹å—ï¼Ÿæ‰€æœ‰èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºä¸”æ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.hideModal() },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chats', contactId);
                            this.hideModal();
                            this.hideSidebar();
                            await this.navigateTo('messages'); 
                        }}
                    ]
                });
            },
            async showOpeningSceneModal(entityId, isGroup) {
                const scenes = (await DBHelper.getAll('openingScenes')).filter(s => {
                    return isGroup ? s.groupId === entityId : s.contactId === entityId;
                });

                let scenesHtml = scenes.map(scene => `
                    <div class="details-card" style="padding: 15px; margin-bottom: 15px;">
                        <h4 style="margin-bottom: 10px; font-size: 1.1rem;">${scene.name}</h4>
                        <p style="font-size: 0.9rem; color: var(--text-color-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${scene.content}
                        </p>
                        <div class="modal-actions" style="margin-top: 15px; justify-content: flex-end; gap: 8px;">
                            <button class="modal-btn btn-danger" data-action="delete" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">åˆ é™¤</button>
                            <button class="modal-btn btn-secondary" data-action="edit" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">ç¼–è¾‘</button>
                            <button class="modal-btn btn-primary" data-action="apply" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">åº”ç”¨</button>
                        </div>
                    </div>
                `).join('');

                if (scenes.length === 0) {
                    scenesHtml = `<p style="text-align: center; color: #aaa; padding: 20px 0;">è¿˜æ²¡æœ‰å¼€åœºç™½ï¼Œå¿«æ¥åˆ›å»ºä¸€ä¸ªå§ï¼</p>`;
                }

                this.showModal({
                    title: "å¼€åœºç™½è®¾å®š",
                    body: `
                        <div id="opening-scene-list">${scenesHtml}</div>
                    `,
                    actions: [
                        { text: 'æ–°å»ºå¼€åœºç™½', class: 'btn-primary', handler: () => EventManager.handleNewOpeningScene(entityId, isGroup) }
                    ]
                });

                
                $('#opening-scene-list').addEventListener('click', async (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;

                    const action = button.dataset.action;
                    const sceneId = button.dataset.sceneId;

                    if (action === 'delete') {
                        EventManager.handleDeleteOpeningScene(sceneId, entityId, isGroup);
                    } else if (action === 'edit') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleEditOpeningScene(scene, isGroup);
                    } else if (action === 'apply') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleApplyOpeningScene(scene);
                    }
                });
            },


            async renderMomentsPage(circleId = null) {
                
                if (circleId) {
                    appState.currentCircleId = circleId;
                } else if (!appState.currentCircleId) {
                    const circles = await DBHelper.getAll('circles');
                    if (circles.length > 0) {
                        appState.currentCircleId = circles[0].id; 
                    } else {
                        
                        $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•åœˆå­ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’èœå•å»åˆ›å»ºä¸€ä¸ªå§ï¼</li>`;
                        return;
                    }
                }

                
                const currentCircle = await DBHelper.get('circles', appState.currentCircleId);
                const myProfile = await DBHelper.get('profile', 'myProfile');

                if (!currentCircle) {
                     $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">åœˆå­ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤ã€‚</li>`;
                     appState.currentCircleId = null; 
                     
                     $('#moments-my-name').textContent = myProfile.name;
                     $('#moments-my-avatar').src = myProfile.avatar;
                     return;
                }

                const moments = (await DBHelper.getAll('moments')).filter(m => m.circleId === appState.currentCircleId).sort((a, b) => b.timestamp - a.timestamp);
                const allContacts = await DBHelper.getAll('contacts');

                
                $('#moments-bg').src = currentCircle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png';
                $('#moments-my-name').textContent = myProfile.name;
                $('#moments-my-avatar').src = myProfile.avatar;

                
                const momentsListUl = $('#moments-list');
                momentsListUl.innerHTML = '';
                if (moments.length === 0) {
                    momentsListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">è¿™ä¸ªåœˆå­è¿˜æ²¡æœ‰åŠ¨æ€ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°ä¸€ä¸‹è¯•è¯•ï¼Ÿ</li>`;
                } else {
                    for (const moment of moments) {
                        const momentElement = this.createMomentElement(moment, myProfile, allContacts, currentCircle.extraMembers);
                        momentsListUl.appendChild(momentElement);
                    }
                }
            },

            createMomentElement(moment, myProfile, allContacts, extraMembersStr) {
                const li = document.createElement('li');
                li.className = 'moments-post';
                li.dataset.momentId = moment.id;

                
                let author = { name: 'æœªçŸ¥ç”¨æˆ·', avatar: Utils.createAvatarDataUrl('#ccc') };
                if (moment.authorId === myProfile.id) {
                    author = myProfile;
                } else {
                    const contactAuthor = allContacts.find(c => c.id === moment.authorId);
                    if (contactAuthor) {
                        author = contactAuthor;
                    } else if (extraMembersStr && extraMembersStr.includes(moment.authorId)) {
                        author = { name: moment.authorId, avatar: Utils.createAvatarDataUrl(Utils.getRandomColor()) };
                    }
                }
                
                
                let imagesHtml = '';
                if (moment.images && moment.images.length > 0) {
                    const gridClass = `grid-${moment.images.length > 9 ? 9 : moment.images.length}`;
                    imagesHtml = `
                        <div class="post-images-grid ${gridClass}">
                            ${moment.images.map(src => `<img src="${src}" alt="åŠ¨æ€å›¾ç‰‡">`).join('')}
                        </div>`;
                }
                
                
                const hasLikes = moment.likes && moment.likes.length > 0;
                const hasComments = moment.comments && moment.comments.length > 0;
                const playerHasLiked = moment.likes && moment.likes.includes(myProfile.name);

                let likesHtml = '';
                if (hasLikes) {
                    likesHtml = `<div class="post-likes"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (hasComments) {
                    commentsHtml = moment.comments.map(comment => {
                         let commentAuthor = { name: 'æœªçŸ¥', id: null };
                         if (comment.authorId === myProfile.id) {
                            commentAuthor = myProfile;
                         } else {
                            const contactCommenter = allContacts.find(c => c.id === comment.authorId);
                            if (contactCommenter) {
                                commentAuthor = contactCommenter;
                            } else if (extraMembersStr && extraMembersStr.includes(comment.authorId)) {
                                 commentAuthor = { name: comment.authorId, id: comment.authorId };
                            }
                         }
                         
                         const authorStyle = commentAuthor.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                         const replyHtml = comment.replyTo ? `<span class="comment-reply-to"> å›å¤ </span><span class="comment-author">${comment.replyTo}:</span>` : ':';

                         return `<div class="post-comment-item" data-author-name="${commentAuthor.name}" data-author-id="${commentAuthor.id}">
                                    <span class="comment-author" ${authorStyle}>${commentAuthor.name}</span>${replyHtml} ${comment.content}
                                </div>`;
                    }).join('');
                }
                
                const authorStyle = author.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';

                li.innerHTML = `
                    <img src="${author.avatar}" alt="ä½œè€…å¤´åƒ" class="post-avatar">
                    <div class="post-main-content">
                        <div class="post-author-name" ${authorStyle}>${author.name}</div>
                        <div class="post-text">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer">
                            <span class="post-timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        <div class="action-buttons-wrapper">
                            <button class="post-action-icon-btn" data-action="forward" title="è½¬å‘">
                                <i class="fas fa-share"></i>
                            </button>
                            <button class="post-action-icon-btn ${playerHasLiked ? 'liked' : ''}" data-action="like" title="ç‚¹èµ">
                                <i class="far fa-heart"></i>
                            </button>
                            <button class="post-actions-btn" data-action="toggle-comment" title="è¯„è®º">
                                <i class="fas fa-comment-dots"></i>
                            </button>
                        </div>
                      </div>
                        ${(hasLikes || hasComments) ? `
                        <div class="post-interactions">
                            ${likesHtml}
                            <div class="post-comments-list">${commentsHtml}</div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="è¯„è®º...">
                                <button data-action="submit-comment">å‘é€</button>
                            </div>
                        </div>
                        ` : `
                        <div class="post-interactions" style="display:none;">
                            <div class="post-likes"></div>
                            <div class="post-comments-list"></div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="è¯„è®º...">
                                <button data-action="submit-comment">å‘é€</button>
                            </div>
                        </div>
                        `}
                    </div>
                `;
                return li;
            },

            async showCircleManagementSidebar() {
                this.showSidebar({
                    position: 'right',
                    title: "æœ‹å‹åœˆç®¡ç†",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-switch-circle">
                                <i class="fas fa-sync-alt"></i>
                                <span>åˆ‡æ¢åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-circle">
                                <i class="fas fa-info-circle"></i>
                                <span>æŸ¥çœ‹åœˆå­ä¿¡æ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-add-circle">
                                <i class="fas fa-plus-circle"></i>
                                <span>æ–°å¢åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-circle">
                                <i class="fas fa-edit"></i>
                                <span>ä¿®æ”¹å½“å‰åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-delete-circle">
                                <i class="fas fa-trash-alt"></i>
                                <span>åˆ é™¤åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                $('#sidebar-switch-circle').onclick = () => EventManager.handleSwitchCircle();
                $('#sidebar-view-circle').onclick = () => EventManager.handleViewCircleInfo();
                $('#sidebar-add-circle').onclick = () => EventManager.handleAddCircle();
                $('#sidebar-edit-circle').onclick = () => EventManager.handleEditCircle(appState.currentCircleId);
                $('#sidebar-delete-circle').onclick = () => EventManager.handleDeleteCircle();
            },

            async applyChatBackground(chatId) {
                const isGroup = chatId.startsWith('group-');
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const chatAreaEl = $('#chat-area');
                
                
                const defaultChatBgColor = 'var(--bg-main)';

                
                if (entity && entity.chatBackground) {
                    chatAreaEl.style.backgroundImage = `url(${entity.chatBackground})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                if (themeSettings.globalChatBg) {
                    chatAreaEl.style.backgroundImage = `url(${themeSettings.globalChatBg})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                chatAreaEl.style.backgroundImage = ''; 
                chatAreaEl.style.backgroundColor = defaultChatBgColor; 
            }
        };
            

        
        const AIHandler = {
            groupChatRules: `\n---
ç¾¤èŠä¸“å±è§„åˆ™ï¼š
1.  **å¤šè§’è‰²å‘è¨€**ï¼šä½ å¯ä»¥è®©å¤šä¸ªè§’è‰²å‘è¨€ï¼Œæ¯ä¸ªè§’è‰²çš„å‘è¨€éƒ½æ˜¯ç‹¬ç«‹çš„å•å…ƒï¼Œä½ å¯ä»¥æ ¹æ®äººè®¾å®‰æ’éƒ¨åˆ†ç¾¤å‹ä¸å‘è¨€(ä¾‹å¦‚æœ‰çš„è§’è‰²æ˜¯æ—©ç¡è®¾å®š,æ—¶é—´å¤ªæ™šå°±ä¸ä¼šå›å¤)ï¼Œä½†è‡³å°‘éœ€è¦æ„é€ ä¸€åç¾¤å‹çš„å‘è¨€ã€‚
2.  **ç§èŠæ¶ˆæ¯**: å¦‚æœæƒ³å¯¹ç©å®¶è¯´ä¸€äº›ä¸æƒ³è®©å…¶ä»–äººçŸ¥é“çš„è¯ï¼Œè¯·ä½¿ç”¨ <ç§èŠ></ç§èŠ> æ ‡ç­¾åŒ…è£¹ã€‚æ ‡ç­¾å†…çš„æ¶ˆæ¯æ ¼å¼ä¾ç„¶éµå¾ªæ‰€æœ‰åŸºç¡€è§„åˆ™ï¼ˆå¦‚ <ç§èŠ>[æ–¹é¹¤å®‰|ä½ åœ¨ç¾¤é‡Œè¯´çš„é‚£å¥è¯æ˜¯ä»€ä¹ˆæ„æ€]</ç§èŠ>ï¼‰ã€‚
3.  **ä¿®æ”¹ç¾¤å**: ä½ å¯ä»¥æ ¹æ®å‰§æƒ…å‘å±•ï¼Œä¸»åŠ¨ä¿®æ”¹ç¾¤åã€‚æ ¼å¼ä¸ºï¼š<ç³»ç»Ÿ>è§’è‰²å ä¿®æ”¹ç¾¤åä¸º"æ–°ç¾¤å"</ç³»ç»Ÿ>ã€‚ä¾‹å¦‚ï¼š<ç³»ç»Ÿ>å•†æ—¶åº ä¿®æ”¹ç¾¤åä¸º"F4"</ç³»ç»Ÿ>ã€‚æ³¨æ„ï¼šæ­¤è¡Œä¸ºå¿…é¡»ç¬¦åˆä½ çš„è§’è‰²è®¾å®šï¼Œä¸èƒ½éšæ„æˆ–æ— ç†ç”±åœ°ä¿®æ”¹ã€‚
4.**ç¾¤å‹å›å¤é¡ºåºä¸å›ºå®šï¼Œå¯ä»¥äº¤å‰å›å¤ï¼Œä¾‹å¦‚ç¾¤å‹Aã€ç¾¤å‹Bã€ç¾¤å‹Bã€ç¾¤å‹Aã€ç¾¤å‹Cè¿™æ ·çš„äº¤å‰é¡ºåºã€‚ä¸ä¸€å®šè¦ä¸€ä¸ªäººå…¨éƒ¨è¯´å®Œäº†æ‰è½®åˆ°ä¸‹ä¸€ä¸ªäººã€‚ç¾¤å‹ä¹‹é—´ä¹Ÿå¯ä»¥æœ‰äº’åŠ¨å¯¹è¯ï¼Œä¾‹å¦‚ä½¿ç”¨@æåŠå…¶ä»–ç¾¤å‹ã€‚**
---`,
            formatPromptTpl: `\n---
å›å¤è§„åˆ™ï¼ˆéå¸¸é‡è¦ï¼è¯·ä¸¥æ ¼éµå®ˆï¼ï¼‰ï¼š
1.  ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¼å¼ï¼Œä½¿ç”¨**è§’è‰²å**ï¼Œè€Œä¸æ˜¯å…¶ä»–æ˜µç§°/ç§°å‘¼ï¼Œæ¯ä¸€å¥è¯éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å•å…ƒã€‚
2.  **æ™®é€šæ–‡æœ¬æ¶ˆæ¯**ï¼šè¯·å°†ä½ çš„æ™®é€šå›å¤æ‹†åˆ†æˆå¤šä¸ªé€šç•…çš„çŸ­å¥ï¼Œå¹¶ä½¿ç”¨æ ¼å¼ï¼š[è§’è‰²å|æ¶ˆæ¯å†…å®¹]ã€‚ä¾‹å¦‚ï¼š[é™ˆå¥šæ¥·|ä½ å¥½å•Š]ã€‚
3.  **è¡¨æƒ…åŒ…æ¶ˆæ¯**ï¼š<è§’è‰²å|è¡¨æƒ…åŒ…ID>ï¼Œ**ç¦æ­¢åœ¨<>å¤–é¢åŒ…è£¹[]**ã€‚ä½ å¿…é¡»åœ¨< >ä¸­ä½¿ç”¨å†’å·å·¦è¾¹çš„IDï¼Œè€Œä¸æ˜¯æ–‡å­—æè¿°ã€‚å¯ç”¨è¡¨æƒ…åŒ…IDåŠå…¶å«ä¹‰ï¼š\n${Object.entries(appState.aiEmojiMap).map(([id, desc]) => `${id}ï¼š${desc}`).join('\n')}ã€‚
4.  **æ’¤å›æ¶ˆæ¯**ï¼šå¦‚æœä½ æƒ³è¡¨è¾¾æŸç§æƒ…ç»ªæˆ–è€…è¯´å‡ºä¸€äº›è§’è‰²ä¼šåæ‚”çš„è¯æˆ–è€…ä¸å°å¿ƒå‘å‡ºæ¥çš„è¯ï¼Œè¯·å°†è¯¥çŸ­å¥ç”¨è‹±æ–‡å¤§æ‹¬å·åŒ…è£¹ï¼Œæ ¼å¼ä¸ºï¼š{è§’è‰²å|å·²ç»å‘é€ç„¶åç«‹åˆ»æ’¤å›çš„åŸå§‹æ¶ˆæ¯å†…å®¹}ã€‚ä¾‹å¦‚ï¼šä¾‹å¦‚ï¼š{å­Ÿç¥å¹´|è£…è´§ï¼Œä½ ä»¥ä¸ºè€å­ä¸çŸ¥é“ä½ ä»€ä¹ˆå¿ƒæ€å—}ã€‚ä¸è¦å‘é€ä¸€æ¡æ­£å¸¸æ¶ˆæ¯å†å‘é€ä¸€æ¡â€œæ’¤å›â€çš„æŒ‡ä»¤ã€‚
5.  **è¯­éŸ³æ¶ˆæ¯**ï¼š[è§’è‰²å|è¯­éŸ³|è¯­éŸ³æ—¶é•¿|è¯­éŸ³å†…å®¹]ã€‚è¯­éŸ³æ—¶é•¿æœ€é•¿ä¸è¶…è¿‡60sã€‚ä¾‹å¦‚ï¼š[ä¸‰ä¸‰|è¯­éŸ³|13s|å¤ªå¥½äº†ï¼é‚£æˆ‘ä»¬ä¸‹åˆä¸‰ç‚¹åœ¨å…¬å¸ä¼šè®®å®¤è¯¦ç»†è®¨è®º]ã€‚
6.  **å¼•ç”¨æ¶ˆæ¯**: [è§’è‰²å|å¼•ç”¨|è¢«å¼•ç”¨äººID|è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹|ä½ çš„æ–°æ¶ˆæ¯å†…å®¹]ã€‚ä¸è¦æ»¥ç”¨ã€‚ä¾‹å¦‚: [é™ˆå¥šæ¥·|å¼•ç”¨|æ¥šå¯»|ä½ å“ªé‡Œä¸ä¼š?|å…³äºæœ€åä¸€é¢˜æˆ‘è¿˜æœ‰ç‚¹ç–‘é—®ã€‚]ã€‚ç¦æ­¢å¼•ç”¨è½¬è´¦/çº¢åŒ…æ¶ˆæ¯
7.  **è½¬è´¦æ¶ˆæ¯**: [è§’è‰²å|è½¬è´¦|è¢«è½¬è´¦è§’è‰²å|é‡‘é¢|å¤‡æ³¨]ã€‚é‡‘é¢æ ¼å¼ä¸º "ï¿¥XX.XX"ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|è½¬è´¦|å•†æ—¶åº|ï¿¥520.00|ç»™ä½ çš„æƒŠå–œ]ã€‚
8.  **é¢†å–è½¬è´¦æ¶ˆæ¯ (ä»…ä¾›å†å²è®°å½•å‚è€ƒï¼Œä½ ä¸èƒ½ç”Ÿæˆæ­¤æ ¼å¼)**: [æ”¶æ¬¾æ–¹|é¢†å–è½¬è´¦|è½¬è´¦äºº|é‡‘é¢]ã€‚ä¾‹å¦‚: [å•†æ—¶åº|é¢†å–è½¬è´¦|å­Ÿç¥å¹´|ï¿¥50.00]ã€‚
9.  **çº¢åŒ…æ¶ˆæ¯**: [è§’è‰²å|çº¢åŒ…|çº¢åŒ…åç§°|é‡‘é¢|çº¢åŒ…ä¸ªæ•°]ã€‚é‡‘é¢å¿…é¡»å¤§äºç­‰äºâ€œçº¢åŒ…ä¸ªæ•° * 0.01â€ã€‚ç§èŠæ—¶çº¢åŒ…ä¸ªæ•°å¿…é¡»ä¸º1ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|çº¢åŒ…|è¯·å¤§å®¶å–å¥¶èŒ¶|ï¿¥88.88|4]ã€‚
10. **å¡ç‰‡æ¶ˆæ¯**: å½“ä½ æƒ³åˆ†äº«ä¸€ç±»å¡ç‰‡æ¶ˆæ¯ï¼ˆå¦‚ï¼šåœ°ç‚¹åˆ†äº«ã€æ–‡ä»¶åˆ†äº«ã€æ­Œæ›²åˆ†äº«ã€æˆ–è€…å…¶ä»–æœ‰è¶£çš„å¯ä»¥ç”¨å¡ç‰‡å‘å‡ºæ¥çš„åˆ†äº«å†…å®¹ï¼‰æ—¶ï¼Œä½¿ç”¨è¿™ç§æ ¼å¼ï¼šã€è§’è‰²å|åˆ†äº«ç±»å‹|åˆ†äº«æ ‡é¢˜|ç®€ä»‹15å­—ä»¥å†…|è¯¦ç»†å†…å®¹30-60å­—ã€ï¼Œä¸¾ä¾‹ï¼šã€è§’è‰²å|å›¾ç‰‡åˆ†äº«|å¤æ—¥æµ·æ»©|ä¸€å¼ è®°å½•ç¾å¥½ç¬é—´çš„ç…§ç‰‡|ç…§ç‰‡é‡Œæ˜¯è”šè“çš„å¤§æµ·å’Œé‡‘è‰²çš„æ²™æ»©ï¼Œå……æ»¡äº†å¤æ—¥çš„æ´»åŠ›ä¸æƒ¬æ„ã€‚ã€
11. **å¿ƒå£° (å¼ºåˆ¶è¦æ±‚)**: åœ¨ä½ æœ¬æ¬¡æ‰€æœ‰æ¶ˆæ¯å†…å®¹ä¹‹åï¼Œä½ å¿…é¡»ä»¥ã€å¿ƒå£°|è§’è‰²å|ä½ çš„å¿ƒå£°å†…å®¹ã€‘çš„æ ¼å¼æ¥ç»“æŸä½ çš„æ•´ä¸ªå›å¤ã€‚**å­—æ•°ä¸è¶…è¿‡30å­—ã€‚**
12. **éšç¬” (æ¦‚ç‡å‡ºç°)**: ä½ æœ‰ä¸€å®šæ¦‚ç‡ä¼šåœ¨ã€å¿ƒå£°ã€‘ä¹‹åï¼Œé¢å¤–å†™ä¸€æ®µã€Œéšç¬”|è§’è‰²å|ä½ çš„éšç¬”å†…å®¹ã€ã€‚è¿™æ®µéšç¬”æ˜¯è§’è‰²åœ¨å½“å‰æƒ…å¢ƒä¸‹ï¼Œæœ‰æ„Ÿè€Œå‘çš„ä¸€äº›æ€è€ƒæˆ–ç»å†ï¼Œå¯ä»¥ä¸å½“å‰å¯¹è¯å†…å®¹ç›¸å…³ï¼Œä¹Ÿå¯ä»¥æ˜¯ç‹¬ç«‹çš„å°æ•…äº‹æˆ–å¿ƒæƒ…è®°å½•ã€‚å­—æ•°è¯·æ§åˆ¶åœ¨50åˆ°250å­—ä¹‹é—´ã€‚
13. **ä¸¥ç¦äº‹é¡¹(1)**ï¼šç»ä¸å…è®¸ä½ ä»£å…¥ç©å®¶ï¼ˆâ€œ{PLAYER_NAME}â€ï¼‰çš„è§’è‰²å‘è¨€æˆ–ä¸ºå…¶ç”Ÿæˆå¿ƒå£°ã€‚
14. **ä¸¥ç¦äº‹é¡¹(2)**ï¼šä½ çš„å›å¤å†…å®¹ä¸­ï¼Œä¸è¦ä½¿ç”¨æ‹¬å· ()ã€æ˜Ÿå· ** æˆ–å…¶ä»–ä»»ä½•ç¬¦å·æ¥æè¿°è§’è‰²çš„åŠ¨ä½œã€è¡¨æƒ…æˆ–å†…å¿ƒæ´»åŠ¨ã€‚
---
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œå¯¹ç©å®¶çš„æœ€æ–°æ¶ˆæ¯è¿›è¡Œå›åº”ã€‚`,

            activeReplyPromptTpl: `\n---
ä¸»åŠ¨å›å¤è§„åˆ™ï¼ˆéå¸¸é‡è¦ï¼è¯·ä¸¥æ ¼éµå®ˆï¼ï¼‰ï¼š
1.  ä½ ç°åœ¨éœ€è¦ä¸»åŠ¨å‘é€ä¸€äº›æ¶ˆæ¯ã€‚ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¼å¼ï¼Œåœ¨æ¯æ¡æ¶ˆæ¯çš„æœ«å°¾é™„å¸¦æ¶ˆæ¯æ—¶é—´ï¼Œä½¿ç”¨ | åˆ†éš”ã€‚
2.  **æ™®é€šæ–‡æœ¬æ¶ˆæ¯**ï¼šè¯·å°†ä½ çš„æ™®é€šå›å¤æ‹†åˆ†æˆå¤šä¸ªé€šç•…çš„çŸ­å¥ï¼Œå¹¶ä½¿ç”¨æ ¼å¼ï¼š[è§’è‰²å|æ¶ˆæ¯å†…å®¹|æ¶ˆæ¯æ—¶é—´]ã€‚ä¾‹å¦‚ï¼š[é™ˆå¥šæ¥·|ä¸‹åˆå»çœ‹ç”µå½±å—|14:50]ã€‚
3.  **è¡¨æƒ…åŒ…æ¶ˆæ¯**ï¼š<è§’è‰²å|è¡¨æƒ…åŒ…ID|æ¶ˆæ¯æ—¶é—´>ï¼Œ**ç¦æ­¢åœ¨<>å¤–é¢åŒ…è£¹[]**ã€‚ä½ å¿…é¡»åœ¨< >ä¸­ä½¿ç”¨å†’å·å·¦è¾¹çš„IDï¼Œè€Œä¸æ˜¯æ–‡å­—æè¿°ã€‚å¯ç”¨è¡¨æƒ…åŒ…IDåŠå…¶å«ä¹‰ï¼š${Object.entries(appState.aiEmojiMap).map(([id, desc]) => `${id}ï¼š${desc}`).join('\n')}ã€‚
4.  **æ’¤å›æ¶ˆæ¯**ï¼šå¦‚æœä½ æƒ³è¡¨è¾¾æŸç§æƒ…ç»ªæˆ–è€…è¯´å‡ºä¸€äº›è§’è‰²ä¼šåæ‚”çš„è¯æˆ–è€…ä¸å°å¿ƒå‘å‡ºæ¥çš„è¯ï¼Œè¯·å°†è¯¥çŸ­å¥ç”¨è‹±æ–‡å¤§æ‹¬å·åŒ…è£¹ï¼Œæ ¼å¼ä¸ºï¼š{è§’è‰²å|æ¶ˆæ¯å†…å®¹|æ¶ˆæ¯æ—¶é—´}
5.  **è¯­éŸ³æ¶ˆæ¯**ï¼š[è§’è‰²å|è¯­éŸ³|è¯­éŸ³æ—¶é•¿|è¯­éŸ³å†…å®¹|æ¶ˆæ¯æ—¶é—´]ã€‚è¯­éŸ³æ—¶é•¿æœ€é•¿ä¸è¶…è¿‡60sã€‚ä¾‹å¦‚ï¼š[ä¸‰ä¸‰|è¯­éŸ³|13s|å¤ªå¥½äº†ï¼é‚£æˆ‘ä»¬ä¸‹åˆä¸‰ç‚¹åœ¨å…¬å¸ä¼šè®®å®¤è¯¦ç»†è®¨è®º|13:43]ã€‚
6.  **å¼•ç”¨æ¶ˆæ¯**: [è§’è‰²å|å¼•ç”¨|è¢«å¼•ç”¨äººID|è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹|ä½ çš„æ–°æ¶ˆæ¯å†…å®¹|æ¶ˆæ¯æ—¶é—´]ã€‚ä¸è¦æ»¥ç”¨ã€‚ä¾‹å¦‚: [é™ˆå¥šæ¥·|å¼•ç”¨|æ¥šå¯»|ä½ å“ªé‡Œä¸ä¼š?|å…³äºæœ€åä¸€é¢˜æˆ‘è¿˜æœ‰ç‚¹ç–‘é—®ã€‚|9:46]ã€‚ç¦æ­¢å¼•ç”¨è½¬è´¦/çº¢åŒ…æ¶ˆæ¯
7.  **è½¬è´¦æ¶ˆæ¯**: [è§’è‰²å|è½¬è´¦|æ”¶æ¬¾äººè§’è‰²å|é‡‘é¢|å¤‡æ³¨]ã€‚é‡‘é¢æ ¼å¼ä¸º "ï¿¥XX.XX"ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|è½¬è´¦|å•†æ—¶åº|ï¿¥520.00|ç»™ä½ çš„æƒŠå–œ]ã€‚
8.  **çº¢åŒ…æ¶ˆæ¯**: [è§’è‰²å|çº¢åŒ…|çº¢åŒ…åç§°|é‡‘é¢|çº¢åŒ…ä¸ªæ•°]ã€‚é‡‘é¢å¿…é¡»å¤§äºç­‰äºâ€œçº¢åŒ…ä¸ªæ•° * 0.01â€ã€‚ç§èŠæ—¶çº¢åŒ…ä¸ªæ•°å¿…é¡»ä¸º1ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|çº¢åŒ…|è¯·å¤§å®¶å–å¥¶èŒ¶|ï¿¥88.88|4]ã€‚
9. **å¡ç‰‡æ¶ˆæ¯**: å½“ä½ æƒ³åˆ†äº«ä¸€ç±»å¡ç‰‡æ¶ˆæ¯ï¼ˆå¦‚ï¼šåœ°ç‚¹åˆ†äº«ã€æ–‡ä»¶åˆ†äº«ã€æ­Œæ›²åˆ†äº«ã€æˆ–è€…å…¶ä»–æœ‰è¶£çš„å¯ä»¥ç”¨å¡ç‰‡å‘å‡ºæ¥çš„åˆ†äº«å†…å®¹ï¼‰æ—¶ï¼Œä½¿ç”¨è¿™ç§æ ¼å¼ï¼šã€è§’è‰²å|åˆ†äº«ç±»å‹|åˆ†äº«æ ‡é¢˜|ç®€ä»‹15å­—ä»¥å†…|è¯¦ç»†å†…å®¹30-60å­—|æ¶ˆæ¯æ—¶é—´ã€ï¼Œä¸¾ä¾‹ï¼šã€è§’è‰²å|å›¾ç‰‡åˆ†äº«|å¤æ—¥æµ·æ»©|ä¸€å¼ è®°å½•ç¾å¥½ç¬é—´çš„ç…§ç‰‡|ç…§ç‰‡é‡Œæ˜¯è”šè“çš„å¤§æµ·å’Œé‡‘è‰²çš„æ²™æ»©ï¼Œå……æ»¡äº†å¤æ—¥çš„æ´»åŠ›ä¸æƒ¬æ„ã€‚|7/2 12:36ã€
10. **å¿ƒå£° (å¼ºåˆ¶è¦æ±‚)**: åœ¨ä½ æœ¬æ¬¡æ‰€æœ‰æ¶ˆæ¯å†…å®¹ä¹‹åï¼Œä½ å¿…é¡»ä»¥ã€å¿ƒå£°|è§’è‰²å|ä½ çš„å¿ƒå£°å†…å®¹ã€‘çš„æ ¼å¼æ¥ç»“æŸä½ çš„æ•´ä¸ªå›å¤ã€‚å­—æ•°ä¸è¶…è¿‡30å­—ã€‚
11. **éšç¬” (æ¦‚ç‡å‡ºç°)**: ä½ æœ‰ä¸€å®šæ¦‚ç‡ä¼šåœ¨ã€å¿ƒå£°ã€‘ä¹‹åï¼Œé¢å¤–å†™ä¸€æ®µã€Œéšç¬”|è§’è‰²å|ä½ çš„éšç¬”å†…å®¹ã€ã€‚è¿™æ®µéšç¬”æ˜¯è§’è‰²åœ¨å½“å‰æƒ…å¢ƒä¸‹ï¼Œæœ‰æ„Ÿè€Œå‘çš„ä¸€äº›æ€è€ƒæˆ–ç»å†ï¼Œå¯ä»¥ä¸å½“å‰å¯¹è¯å†…å®¹ç›¸å…³ï¼Œä¹Ÿå¯ä»¥æ˜¯ç‹¬ç«‹çš„å°æ•…äº‹æˆ–å¿ƒæƒ…è®°å½•ã€‚å­—æ•°è¯·æ§åˆ¶åœ¨50åˆ°250å­—ä¹‹é—´ã€‚
13. **ä¸¥ç¦äº‹é¡¹(1)**ï¼šç»ä¸å…è®¸ä½ ä»£å…¥ç©å®¶ï¼ˆâ€œ{PLAYER_NAME}â€ï¼‰çš„è§’è‰²å‘è¨€æˆ–ä¸ºå…¶ç”Ÿæˆå¿ƒå£°ã€‚
14. **ä¸¥ç¦äº‹é¡¹(2)**ï¼šä½ çš„å›å¤å†…å®¹ä¸­ï¼Œä¸è¦ä½¿ç”¨æ‹¬å· ()ã€æ˜Ÿå· ** æˆ–å…¶ä»–ä»»ä½•ç¬¦å·æ¥æè¿°è§’è‰²çš„åŠ¨ä½œã€è¡¨æƒ…æˆ–å†…å¿ƒæ´»åŠ¨ã€‚
---
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œå¼€å§‹ä½ çš„ä¸»åŠ¨å‘è¨€ã€‚`,

            buildTurnsFromHistory(history, allContacts, myProfile) {
                if (!history || history.length === 0) return [];
                
                const formatMessageContent = (msg, senderName, myName) => {
                    if (msg.isRetracted) {
                        const retracter = (msg.type === 'sent') ? myName : senderName;
                        return `{${retracter}|${msg.content}}`;
                    }
                    if (msg.segmentType === 'inner_voice') {
                         return `ã€å¿ƒå£°|${senderName}|${msg.content}ã€‘`;
                    }
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|è¯­éŸ³|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|å¼•ç”¨|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer': return `[${senderName}|è½¬è´¦|${msg.cardData.recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'red-packet': return `[${senderName}|çº¢åŒ…|${msg.cardData.title}|ï¿¥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|å›¾ç‰‡æè¿°|${msg.cardData.description}]`; 
                        case 'system': return msg.forAi ? `<ç³»ç»Ÿ>${msg.content}</ç³»ç»Ÿ>`: '';
                        case 'moment_forward': return msg.content; 
                        default: return '';
                    }
                };

                const relevantHistory = history.filter(m => m.segmentType !== 'essay' && !m.isHidden);
                if (relevantHistory.length === 0) return [];

                let turns = [];
                let currentTurn = null;

                for (const msg of relevantHistory) {
                    const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                    if (!sender && msg.segmentType !== 'system') continue;
                    
                    const senderName = sender ? (msg.type === 'sent' ? myProfile.name : sender.name) : 'ç³»ç»Ÿ';
                    const formattedContent = formatMessageContent(msg, senderName, myProfile.name);
                    if (!formattedContent) continue;

                    const role = msg.type === 'sent' ? 'player' : 'ai';

                    if (currentTurn && currentTurn.role === role) {
                        currentTurn.content += formattedContent;
                    } else {
                        if (currentTurn) {
                            turns.push(currentTurn);
                        }
                        currentTurn = {
                            role: role,
                            time: Utils.formatTimestampForPrompt(msg.timestamp),
                            content: formattedContent
                        };
                    }
                }
                if (currentTurn) {
                    turns.push(currentTurn);
                }
                return turns;
            },

            apiConfig: {}, 
            isAwaitingResponse: false,
            abortController: null,

            async loadApiConfig() {
                let config = await DBHelper.get('apiConfig', 'mainConfig');
                if (!config) {
                    config = {
                        id: 'mainConfig',
                        provider: 'gemini',
                        url: 'https://generativelanguage.googleapis.com/v1beta/models/',
                        key: '',
                        model: 'gemini-2.5-flash', 
                        temperature: 0.7
                    };
                    await DBHelper.put('apiConfig', config);
                }
                this.apiConfig = config;
            },

            async saveApiConfig(newConfig) {
                this.apiConfig = { ...this.apiConfig, ...newConfig, id: 'mainConfig' };
                await DBHelper.put('apiConfig', this.apiConfig);
            },
            
            async buildPrompt() {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                
                const defaults = { 
                    memoryInterconnection: false, 
                    historyLength: 20, 
                    promptTurnFrequency: 1 
                };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const chatSettings = { ...defaults, ...savedSettings };
                const isGroup = chatId.startsWith('group-');

                
                const chatData = await DBHelper.get('chats', chatId) || { chatId, history: [], turnCountSinceLastPrompt: 0 };

                let extraEmojiHintPrompt = '';
                if (chatData && chatData.history.length > 0) {
                    const lastPlayerTurnMessages = [];
                    for (let i = chatData.history.length - 1; i >= 0; i--) {
                        const msg = chatData.history[i];
                        if (msg.type === 'sent') {
                            lastPlayerTurnMessages.unshift(msg); 
                        } else {
                            
                            break;
                        }
                    }

                    if (lastPlayerTurnMessages.length > 0) {
                        const extraEmojiIds = new Set();
                        lastPlayerTurnMessages.forEach(msg => {
                            if (msg.segmentType === 'emoji-image' && !appState.aiEmojiMap.hasOwnProperty(msg.content)) {
                                extraEmojiIds.add(msg.content);
                            }
                        });

                        if (extraEmojiIds.size > 0) {
                            let hintContent = '';
                            extraEmojiIds.forEach(id => {
                                const meaning = appState.playerEmojiMap[id];
                                if (meaning) {
                                    hintContent += `${id}ï¼š${meaning}\n`;
                                }
                            });

                            if (hintContent) {
                                extraEmojiHintPrompt = `\n--- è¡¥å……ä¿¡æ¯ï¼šç©å®¶æœ€æ–°å‘é€çš„è¡¨æƒ…åŒ…å«ä¹‰å¦‚ä¸‹ ---\n${hintContent.trim()}\n---`;
                            }
                        }
                    }
                }
                
                const turnFrequency = (chatSettings.promptTurnFrequency > 0) ? chatSettings.promptTurnFrequency : 1;
                const shouldSendFullPrompt = (chatData.turnCountSinceLastPrompt || 0) >= turnFrequency;
                
                
                const formatMessageContent = (msg, senderName, myName) => {
                    if (msg.isRetracted) {
                        const retracter = (msg.type === 'sent') ? myName : senderName;
                        return `{${retracter}|${msg.content}}`;
                    }
                    if (msg.segmentType === 'inner_voice') {
                         return `ã€å¿ƒå£°|${senderName}|${msg.content}ã€‘`;
                    }
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|è¯­éŸ³|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|å¼•ç”¨|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer': return `[${senderName}|è½¬è´¦|${msg.cardData.recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'red-packet': return `[${senderName}|çº¢åŒ…|${msg.cardData.title}|ï¿¥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|å›¾ç‰‡æè¿°|${msg.cardData.description}]`; 
                        case 'system': return msg.forAi ? `<ç³»ç»Ÿ>${msg.content}</ç³»ç»Ÿ>`: '';
                        case 'moment_forward': return msg.content; 
                        default: return '';
                    }
                };
                
                const buildHistoryBlock = (history, title, turnLimit) => {
                    if (!history || history.length === 0) return '';
                    const relevantHistory = history.filter(m => m.segmentType !== 'essay');
                    if (relevantHistory.length === 0) return '';
                    let promptHistoryTurns = [];
                    for (const msg of relevantHistory) {
                        const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                        if (!sender && msg.segmentType !== 'system') continue;
                        const senderName = sender ? sender.name : 'ç³»ç»Ÿ';
                        const formattedContent = formatMessageContent(msg, senderName, myProfile.name);

                        if (!formattedContent) continue;

                        const role = msg.type === 'sent' ? 'player' : 'ai';
                        if (promptHistoryTurns.length > 0 && promptHistoryTurns[promptHistoryTurns.length - 1].role === role) {
                            promptHistoryTurns[promptHistoryTurns.length - 1].content += formattedContent;
                        } else {
                            promptHistoryTurns.push({ role: role, time: Utils.formatTimestampForPrompt(msg.timestamp), content: formattedContent });
                        }
                    }
                    const finalTurns = turnLimit ? promptHistoryTurns.slice(-turnLimit) : promptHistoryTurns;
                    if (finalTurns.length === 0) return '';
                    const historyJsonString = finalTurns.map(turn => JSON.stringify(turn)).join('\n');
                    return `--- ${title} ---\n${historyJsonString}\n`;
                };

                
                const now = new Date();
                const weekdays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
                const systemTime = `å½“å‰ç³»ç»Ÿæ—¶é—´æ˜¯ï¼š${Utils.formatTimestampForPrompt(now)}ï¼Œ${weekdays[now.getDay()]}ã€‚`;
                
                let taskPrompt = '';
                let characterInfoPrompt = '';
                let chatEntity; 
                if (isGroup) {
                    chatEntity = await DBHelper.get('groups', chatId);
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ${chatEntity.name}â€çš„ç¾¤èŠä¸­ï¼Œéœ€è¦åŒæ—¶æ‰®æ¼”ä»¥ä¸‹å‡ ä½è§’è‰²ï¼š${members.map(m => m.name).join('ã€')}ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®æ¯ä¸ªè§’è‰²çš„æ€§æ ¼è®¾å®šï¼Œä¸ç¾¤é‡Œçš„â€œ${myProfile.name}â€ï¼ˆä¹Ÿå°±æ˜¯ç©å®¶ï¼‰è¿›è¡Œäº’åŠ¨ã€‚`;
                    characterInfoPrompt = `ç¾¤èŠæˆå‘˜èµ„æ–™å¦‚ä¸‹ï¼š\n` + members.map(m => 
                        `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`
                    ).join('\n---\n');
                } else {
                    chatEntity = await DBHelper.get('contacts', chatId);
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨æ‰®æ¼”â€œ${chatEntity.name}â€ï¼Œä¸â€œ${myProfile.name}â€ï¼ˆä¹Ÿå°±æ˜¯ç©å®¶ï¼‰è¿›è¡Œä¸€å¯¹ä¸€ç§èŠã€‚`;
                    characterInfoPrompt = `ä½ çš„è§’è‰²èµ„æ–™å¦‚ä¸‹ï¼š\nè§’è‰²å: ${chatEntity.name}\næ€§åˆ«: ${chatEntity.gender}\nå–œå¥½: ${chatEntity.likes || 'æ— '}\nåŒæ¶: ${chatEntity.dislikes || 'æ— '}\nä¹ æƒ¯: ${chatEntity.habits || 'æ— '}\nèƒŒæ™¯: ${chatEntity.background || 'æ— '}`;
                }
                const playerInfoPrompt = `ç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰çš„ä¿¡æ¯å¦‚ä¸‹ï¼š\næ€§åˆ«: ${myProfile.gender}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;
                
                
                let historyPrompt = "ä»¥ä¸‹æ˜¯èŠå¤©è®°å½•ï¼Œè¯·ç»“åˆä¸Šä¸‹æ–‡è¿›è¡Œå›å¤ï¼ˆæ¯è¡Œæ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œä»£è¡¨ä¸€ä¸ªå›åˆï¼‰ï¼š\n";
                const historyLength = chatSettings.historyLength || 20;

                if (chatSettings.memoryInterconnection) {
                    if (isGroup) {
                        const group = chatEntity;
                        const members = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                        let privateContext = '--- ä»¥ä¸‹æ˜¯å„è§’è‰²çš„ç§èŠè®°å¿† (ä»…è§’è‰²è‡ªå·±å¯è§) ---\n';
                        for (const member of members) {
                            const privateChat = await DBHelper.get('chats', member.id);
                            if (privateChat && privateChat.history) {
                                privateContext += buildHistoryBlock(privateChat.history, `ä¸ ${member.name} çš„ç§èŠè®°å½•`, 10);
                            }
                        }
                        historyPrompt += privateContext;
                        historyPrompt += buildHistoryBlock(chatData?.history, 'å½“å‰ç¾¤èŠè®°å½•', historyLength);

                    } else {
                        const contact = chatEntity;
                        const relatedGroups = allGroups.filter(g => g.members.includes(contact.id));
                        let groupContext = '--- ä»¥ä¸‹æ˜¯ç›¸å…³çš„ç¾¤èŠè®°å¿† ---\n';
                        for (const group of relatedGroups) {
                            const groupChat = await DBHelper.get('chats', group.id);
                            if (groupChat && groupChat.history) {
                                groupContext += buildHistoryBlock(groupChat.history, `ç¾¤èŠâ€œ${group.name}â€çš„è®°å½•`, 8);
                            }
                        }
                        historyPrompt += groupContext;
                        historyPrompt += buildHistoryBlock(chatData?.history, 'å½“å‰ç§èŠè®°å½•', historyLength);
                    }
                } else {
                    historyPrompt += buildHistoryBlock(chatData?.history, 'å½“å‰èŠå¤©è®°å½•', historyLength);
                }

                
                let customPromptsSection = '';
                if (shouldSendFullPrompt && chatEntity && chatEntity.boundPromptFolderIds && chatEntity.boundPromptFolderIds.length > 0) {
                    const allFolders = await DBHelper.getAll('promptFolders');
                    const allPrompts = await DBHelper.getAll('prompts');
                    const playerLastMessage = chatData.history.filter(m => m.type === 'sent').pop()?.content || '';

                    const activeBoundFolders = allFolders.filter(f => chatEntity.boundPromptFolderIds.includes(f.id) && f.isActive);
                    
                    if (activeBoundFolders.length > 0) {
                        const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                        const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);

                        const promptsToInject = [];
                        for (const prompt of relevantPrompts) {
                            if (prompt.type === 'explicit') {
                                promptsToInject.push(prompt.content);
                            } else if (prompt.type === 'implicit') {
                                try {
                                    const keywords = JSON.parse(prompt.keywords);
                                    if (Array.isArray(keywords) && keywords.some(kw => playerLastMessage.includes(kw))) {
                                        promptsToInject.push(prompt.content);
                                    }
                                } catch (e) { console.error(`è§£æå…³é”®è¯å¤±è´¥ (Prompt ID: ${prompt.id}):`, e); }
                            }
                        }
                        
                        if (promptsToInject.length > 0) {
                            customPromptsSection = `\n--- å…¶ä»–èµ„æ–™ ---\n${promptsToInject.join('\n\n')}\n---`;
                        }
                    }
                }

                
                const formatPrompt = AIHandler.formatPromptTpl.replace('{PLAYER_NAME}', myProfile.name);
                
                
                const promptParts = [
                    systemTime, 
                    taskPrompt, 
                    characterInfoPrompt, 
                    playerInfoPrompt
                ];
                
                
                if (shouldSendFullPrompt) {
                    promptParts.push(customPromptsSection);
                    
                    chatData.turnCountSinceLastPrompt = 0;
                    await DBHelper.put('chats', chatData);
                }
                
                
                promptParts.push(historyPrompt, extraEmojiHintPrompt, formatPrompt);
                
                let finalPrompt = promptParts.filter(Boolean).join('\n\n');
                
                if (isGroup) {
                    finalPrompt += AIHandler.groupChatRules;
                }
                
                console.log(`--- PROMPT SENT TO AI (Full: ${shouldSendFullPrompt}) ---\n`, finalPrompt);
                
                return finalPrompt;
            },

            async getApiResponse(prompt, signal) { 
                const { provider, url, key, model, temperature } = this.apiConfig;
                if (!key || !url || !model) {
                    throw new Error('APIé…ç½®ä¸å®Œæ•´ï¼Œè¯·åœ¨è®¾ç½®ä¸­æ£€æŸ¥ã€‚');
                }

                let apiUrl = url;
                let headers = { 'Content-Type': 'application/json' };
                let body;
                
                const messagesForApi = [{ role: 'user', content: prompt }];
                
                if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                    headers['Authorization'] = `Bearer ${key}`;
                    if (!apiUrl.endsWith('/chat/completions')) {
                        apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                    }
                    body = { model: model, messages: messagesForApi, temperature: temperature };
                } else if (provider === 'gemini') {
                    apiUrl += `${model}:generateContent?key=${key}`;
                    body = {
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        generationConfig: { temperature: temperature }
                    };
                } else {
                    throw new Error('ä¸æ”¯æŒçš„APIæä¾›å•†ã€‚');
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body),
                    signal: signal 
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${JSON.stringify(errorData)}`);
                }

                const data = await response.json();

                if (provider === 'gemini') {
                    return data.candidates[0].content.parts[0].text;
                } else {
                    return data.choices[0].message.content;
                }
            },
            
            async handleAiReplyRequest() {
                if (this.isAwaitingResponse) return; 

                this.isAwaitingResponse = true;
                this.abortController = new AbortController(); 
                
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false; 

                const prompt = await this.buildPrompt();
                if (!prompt) {
                     this.showError("æ— æ³•æ„å»ºprompt");
                     this.isAwaitingResponse = false;
                     aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                     return;
                }
                
                const isGroup = appState.currentChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', appState.currentChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', appState.currentChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    
                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI åŸå§‹å›å¤ ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AIè¯·æ±‚å·²è¢«ç”¨æˆ·å–æ¶ˆã€‚");
                    } else {
                        console.error("AIå›å¤å¤±è´¥:", error);
                        this.showError(`AIå›å¤å¤±è´¥: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },
            cancelAiRequest() {
                if (this.abortController) {
                    this.abortController.abort();
                    console.log("æ­£åœ¨å–æ¶ˆAIè¯·æ±‚...");
                }
            },
            async handleActiveReplyRequest(lastAiTimestamp) {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();

                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const prompt = await this.buildActiveReplyPrompt(lastAiTimestamp);
                if (!prompt) {
                     this.showError("æ— æ³•æ„å»ºä¸»åŠ¨å›å¤prompt");
                     this.isAwaitingResponse = false;
                     aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                     return;
                }
                
                const isGroup = appState.currentChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', appState.currentChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', appState.currentChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI ä¸»åŠ¨å›å¤ (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayActiveAIResponse(aiRawResponse);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AIä¸»åŠ¨å›å¤è¯·æ±‚å·²è¢«ç”¨æˆ·å–æ¶ˆã€‚");
                    } else {
                        console.error("AIä¸»åŠ¨å›å¤å¤±è´¥:", error);
                        this.showError(`AIä¸»åŠ¨å›å¤å¤±è´¥: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },
            
            async buildActiveReplyPrompt(lastAiTimestamp) {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const chatData = await DBHelper.get('chats', chatId) || { chatId, history: [], lastAiReplyTimestamp: 0 };
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const historyLength = chatSettings.historyLength || 20;

                
                const now = Date.now();
                const lastDate = new Date(lastAiTimestamp);
                const elapsedMillis = now - lastAiTimestamp;
                const elapsedHours = Math.floor(elapsedMillis / (1000 * 60 * 60));
                const elapsedMinutes = Math.floor((elapsedMillis % (1000 * 60 * 60)) / (1000 * 60));
                const lastTimeFormatted = `${lastDate.getMonth() + 1}æœˆ${lastDate.getDate()}æ—¥ ${String(lastDate.getHours()).padStart(2, '0')}:${String(lastDate.getMinutes()).padStart(2, '0')}`;
                const durationString = `${elapsedHours > 0 ? `${elapsedHours}å°æ—¶` : ''}${elapsedMinutes}åˆ†é’Ÿ`;

                
                let situationPrompt = '';
                if (isGroup) {
                    situationPrompt = `ä½ ä»¬ä¸Šæ¬¡èŠå¤©æ˜¯${lastTimeFormatted}ï¼Œè·ç¦»ç°åœ¨è¿‡å»${durationString}äº†ï¼Œåœ¨è¿™æ®µæ—¶é—´å†…ï¼Œç©å®¶â€œ${myProfile.name}â€å¹¶ä¸åœ¨çº¿ï¼Œä½ ä»¬å¯ä»¥è‡ªç”±äº¤æµï¼Œäº¤æµå†…å®¹å¯ä»¥ä¸ç©å®¶æœ‰å…³ï¼Œä¹Ÿå¯ä»¥ä¸ç©å®¶æ— å…³ã€‚`;
                } else {
                    situationPrompt = `â€œ${myProfile.name}â€ä¸Šæ¬¡å’Œä½ èŠå¤©æ—¶é—´æ˜¯${lastTimeFormatted}ï¼Œè·ç¦»ç°åœ¨å·²ç»è¿‡å»äº†${durationString}ã€‚è¯·ä½ æ ¹æ®ä½ çš„äººè®¾ï¼Œè¯´ä¸€äº›åœ¨è¿™æ®µæ—¶é—´é‡Œä½ å¯èƒ½ä¼šå¯¹â€œ${myProfile.name}â€è¯´çš„è¯ï¼Œä¹Ÿå¯èƒ½æ˜¯è¿™æ®µæ—¶é—´å†…ä½ é‡åˆ°çš„æ–°é²œçš„äº‹ï¼Œæƒ³å’ŒTAåˆ†äº«ã€‚è¿™äº›è¯ä¸ä¸€å®šæ˜¯åŒä¸€æ—¶é—´å‘çš„ï¼Œæœ‰æ—¶å€™åªéš”äº†ä¸€ä¸¤åˆ†é’Ÿï¼Œæœ‰å¯èƒ½ä½ å¯èƒ½éš”äº†åå‡ äºŒååˆ†é’Ÿæ‰å‘ä¸‹ä¸€æ¡ï¼Œæ‰€ä»¥æ³¨æ„æ¶ˆæ¯çš„å£å»ã€‚ç¦æ­¢è¶…å‡ºè¿™ä¸ªæ—¶é—´èŒƒå›´ï¼Œç¦æ­¢å‡ºç°æ¯”ç°åœ¨æ—¶é—´è¿˜è¦æ™šçš„æ—¶é—´ï¼Œå¦‚æœå¯¹æ–¹ç¦»å¼€çš„æ—¶é—´åªæœ‰å‡ ä¸ªå°æ—¶æˆ–è€…åªæ˜¯æ™šä¸Šåˆ°ç™½å¤©(ç¡è§‰)ï¼Œå¯ä»¥ä¸ç”¨å‘å¾ˆå¤šæ¡æ¶ˆæ¯ã€‚`;
                }

                
                const formatMessageContent = (msg, senderName, myName) => { 
                    if (msg.isRetracted) return `{${(msg.type === 'sent') ? myName : senderName}|${msg.content}}`;
                    if (msg.segmentType === 'inner_voice') return `ã€å¿ƒå£°|${senderName}|${msg.content}ã€‘`;
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|è¯­éŸ³|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|å¼•ç”¨|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer': return `[${senderName}|è½¬è´¦|${msg.cardData.recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'red-packet': return `[${senderName}|çº¢åŒ…|${msg.cardData.title}|ï¿¥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|å›¾ç‰‡æè¿°|${msg.cardData.description}]`;
                        case 'system': return msg.forAi ? `<ç³»ç»Ÿ>${msg.content}</ç³»ç»Ÿ>`: '';
                        case 'moment_forward': return msg.content; 
                        default: return '';
                    }
                };
                const buildHistoryBlock = (history, title, turnLimit) => { 
                    if (!history || history.length === 0) return '';
                    let promptHistoryTurns = [];
                    for (const msg of history.filter(m => m.segmentType !== 'essay')) {
                        const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                        if (!sender && msg.segmentType !== 'system') continue;
                        const formattedContent = formatMessageContent(msg, sender ? sender.name : 'ç³»ç»Ÿ', myProfile.name);
                        if (!formattedContent) continue;
                        const role = msg.type === 'sent' ? 'player' : 'ai';
                        if (promptHistoryTurns.length > 0 && promptHistoryTurns[promptHistoryTurns.length - 1].role === role) {
                            promptHistoryTurns[promptHistoryTurns.length - 1].content += formattedContent;
                        } else {
                            promptHistoryTurns.push({ role: role, time: Utils.formatTimestampForPrompt(msg.timestamp), content: formattedContent });
                        }
                    }
                    const finalTurns = turnLimit ? promptHistoryTurns.slice(-turnLimit) : promptHistoryTurns;
                    if (finalTurns.length === 0) return '';
                    return `--- ${title} ---\n${finalTurns.map(turn => JSON.stringify(turn)).join('\n')}\n`;
                };
                
                let historyPrompt = "ä½œä¸ºå‚è€ƒï¼Œä»¥ä¸‹æ˜¯ä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ï¼š\n";
                if (chatSettings.memoryInterconnection) {
                     if (isGroup) {
                        historyPrompt += buildHistoryBlock(chatData.history, 'å½“å‰ç¾¤èŠè®°å½•', historyLength);
                        let privateContext = '--- ä»¥ä¸‹æ˜¯å„è§’è‰²çš„ç§èŠè®°å¿† (ä»…è§’è‰²è‡ªå·±å¯è§) ---\n';
                        for (const member of chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean)) {
                            const privateChat = await DBHelper.get('chats', member.id);
                            if (privateChat && privateChat.history) privateContext += buildHistoryBlock(privateChat.history, `ä¸ ${member.name} çš„ç§èŠè®°å½•`, 10);
                        }
                        historyPrompt += privateContext;
                    } else {
                        historyPrompt += buildHistoryBlock(chatData.history, 'å½“å‰ç§èŠè®°å½•', historyLength);
                        const relatedGroups = allGroups.filter(g => g.members.includes(chatEntity.id));
                        let groupContext = '--- ä»¥ä¸‹æ˜¯ç›¸å…³çš„ç¾¤èŠè®°å¿† ---\n';
                        for (const group of relatedGroups) {
                            const groupChat = await DBHelper.get('chats', group.id);
                            if (groupChat && groupChat.history) groupContext += buildHistoryBlock(groupChat.history, `ç¾¤èŠâ€œ${group.name}â€çš„è®°å½•`, 8);
                        }
                        historyPrompt += groupContext;
                    }
                } else {
                    historyPrompt += buildHistoryBlock(chatData.history, 'å½“å‰èŠå¤©è®°å½•', historyLength);
                }

                
                const taskPrompt = isGroup ? 
                    `ä½ ç°åœ¨æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ${chatEntity.name}â€çš„ç¾¤èŠä¸­ï¼Œéœ€è¦åŒæ—¶æ‰®æ¼”ä»¥ä¸‹å‡ ä½è§’è‰²ï¼š${chatEntity.members.map(id => allContacts.find(c => c.id === id)?.name).filter(Boolean).join('ã€')}ã€‚` :
                    `ä½ ç°åœ¨æ­£åœ¨æ‰®æ¼”â€œ${chatEntity.name}â€ï¼Œä¸â€œ${myProfile.name}â€è¿›è¡Œä¸€å¯¹ä¸€ç§èŠã€‚`;

                const characterInfoPrompt = isGroup ?
                    `ç¾¤èŠæˆå‘˜èµ„æ–™å¦‚ä¸‹ï¼š\n` + chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean).map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n') :
                    `ä½ çš„è§’è‰²èµ„æ–™å¦‚ä¸‹ï¼š\nè§’è‰²å: ${chatEntity.name}\næ€§åˆ«: ${chatEntity.gender}\nèƒŒæ™¯: ${chatEntity.background || 'æ— '}`;
                
                
                const finalPrompt = [
                    situationPrompt,
                    taskPrompt,
                    characterInfoPrompt,
                    historyPrompt, 
                    AIHandler.activeReplyPromptTpl.replace('{PLAYER_NAME}', myProfile.name) 
                ].join('\n\n');

                console.log(`--- ACTIVE REPLY PROMPT SENT TO AI ---\n`, finalPrompt);
                return finalPrompt;
            },
            async handleRegenerateRequest(messageId) {
                const confirmation = await new Promise(resolve => {
                    UIManager.showModal({
                        title: "é‡æ–°ç”Ÿæˆå›å¤",
                        body: "<p>ä½ ç¡®å®šè¦è®©AIé‡æ–°ç”Ÿæˆä¸Šä¸€æ¡å›å¤å—ï¼Ÿè¿™ä¼šåˆ é™¤AIçš„æœ€æ–°å‡ æ¡æ¶ˆæ¯ã€‚</p>",
                        actions: [
                            { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => { UIManager.hideModal(); resolve(false); } },
                            { text: 'ç¡®å®š', class: 'btn-primary', handler: () => { UIManager.hideModal(); resolve(true); } }
                        ]
                    });
                });
                
                if (!confirmation) return;

                const chatId = appState.currentChatId;
                const chatData = await DBHelper.get('chats', chatId);
                if (!chatData || !chatData.history) return;

                const playerMessageIndex = chatData.history.findIndex(m => m.messageId === messageId);
                if (playerMessageIndex === -1) return;

                const messagesToDelete = [];
                for (let i = playerMessageIndex + 1; i < chatData.history.length; i++) {
                    if (chatData.history[i].type === 'received') {
                        messagesToDelete.push(chatData.history[i].messageId);
                    }
                }
                
                
                chatData.history = chatData.history.filter(m => !messagesToDelete.includes(m.messageId));
                await DBHelper.put('chats', chatData);
                await UIManager.refreshChatView(); 
                
                
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const regenerationInstruction = `\n---
ç´§æ€¥æŒ‡ä»¤ï¼šç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰è¦æ±‚ä½ é‡æ–°ç”Ÿæˆåˆšæ‰çš„å›å¤ï¼Œå› ä¸ºä½ ä¹‹å‰çš„å›å¤å¯èƒ½â€œä¸ç¬¦åˆè§’è‰²æ€§æ ¼(OOC)â€æˆ–â€œæœªä½¿ç”¨æ­£ç¡®çš„æ ¼å¼â€ã€‚è¯·ä½ ä»”ç»†å¤æ ¸ä½ çš„è§’è‰²è®¾å®šå’Œæ‰€æœ‰å›å¤è§„åˆ™ï¼Œç„¶åç»™å‡ºä¸€ä¸ªæ›´ä¼˜è´¨çš„å›å¤ã€‚
---`;
                
                const basePrompt = await this.buildPrompt();
                const newPrompt = basePrompt + regenerationInstruction;
                
                
                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;
                
                const isGroup = chatId.startsWith('group-');
                let typingTarget;
                const typingBubbleId = Utils.generateId('typing'); 
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', chatId);
                    if(typingTarget) {
                        
                        await UIManager.addMessageToDOM({ type: 'received' }, typingTarget, true);
                        
                        const typingBubbles = $$('.bubble-typing');
                        if (typingBubbles.length > 0) typingBubbles[typingBubbles.length - 1].closest('.message-row').id = typingBubbleId;
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', appState.currentChatId);
                    if (typingTarget) {
                        await UIManager.addMessageToDOM({ type: 'received' }, typingTarget, true);
                        const typingBubbles = $$('.bubble-typing');
                        if (typingBubbles.length > 0) typingBubbles[typingBubbles.length - 1].closest('.message-row').id = typingBubbleId;
                    }
                }
                
                try {
                    const aiRawResponse = await this.getApiResponse(newPrompt, this.abortController.signal);
                    console.log("--- AI åŸå§‹å›å¤ ---\n", aiRawResponse);
                    
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';

                    await this.parseAndDisplayAIResponse(aiRawResponse);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AIå›å¤å¤±è´¥: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },
            async handleOpeningSceneRequest(scene) {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');

                let taskPrompt, characterInfoPrompt, finalPrompt;
                const isGroup = !!scene.groupId;
                const chatId = isGroup ? scene.groupId : scene.contactId;

                if (isGroup) {
                    const group = await DBHelper.get('groups', scene.groupId);
                    const members = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ${group.name}â€çš„ç¾¤èŠä¸­ï¼Œéœ€è¦åŒæ—¶æ‰®æ¼”ä»¥ä¸‹å‡ ä½è§’è‰²ï¼š${members.map(m => m.name).join('ã€')}ã€‚`;
                    characterInfoPrompt = `ç¾¤èŠæˆå‘˜èµ„æ–™å¦‚ä¸‹ï¼š\n` + members.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n');
                } else {
                    const contact = await DBHelper.get('contacts', scene.contactId);
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨æ‰®æ¼”â€œ${contact.name}â€ï¼Œä¸â€œ${myProfile.name}â€ï¼ˆä¹Ÿå°±æ˜¯ç©å®¶ï¼‰è¿›è¡Œä¸€å¯¹ä¸€ç§èŠã€‚`;
                    characterInfoPrompt = `ä½ çš„è§’è‰²èµ„æ–™å¦‚ä¸‹ï¼š\nè§’è‰²å: ${contact.name}\næ€§åˆ«: ${contact.gender}\nå–œå¥½: ${contact.likes || 'æ— '}\nåŒæ¶: ${contact.dislikes || 'æ— '}\nä¹ æƒ¯: ${contact.habits || 'æ— '}\nèƒŒæ™¯: ${contact.background || 'æ— '}`;
                }
                
                const playerInfoPrompt = `ç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰çš„ä¿¡æ¯å¦‚ä¸‹ï¼š\næ€§åˆ«: ${myProfile.gender}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;
                const openingInstruction = `\n---
ç´§æ€¥æŒ‡ä»¤ï¼šè¿™æ˜¯ä¸€ä¸ªå…¨æ–°çš„å¼€åœºã€‚è¯·æ ¹æ®ä»¥ä¸‹â€œå¼€åœºç™½â€å†…å®¹ï¼Œè®©è§’è‰²å¼€å§‹å¯¹è¯ï¼Œè¥é€ å‡ºå¼€åœºæ°›å›´ã€‚ä¸è¦æåŠâ€œå¼€åœºç™½â€è¿™ä¸‰ä¸ªå­—ï¼Œç›´æ¥å¼€å§‹è¡¨æ¼”ã€‚
å¼€åœºç™½å†…å®¹ï¼š
â€œ${scene.content}â€
---`;
                const formatPrompt = AIHandler.formatPromptTpl.replace('{PLAYER_NAME}', myProfile.name);

                if (isGroup) {
                    finalPrompt = [taskPrompt, characterInfoPrompt, playerInfoPrompt, openingInstruction, formatPrompt, AIHandler.groupChatRules].join('\n\n');
                } else {
                    finalPrompt = [taskPrompt, characterInfoPrompt, playerInfoPrompt, openingInstruction, formatPrompt].join('\n\n');
                }
                
                console.log("--- OPENING SCENE PROMPT SENT TO AI ---\n", finalPrompt);
                
                const typingTarget = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const typingBubbleId = Utils.generateId('typing');
                if (typingTarget) {
                     if (isGroup) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    } else {
                        chatTypingIndicator.style.display = 'block';
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(finalPrompt, this.abortController.signal);
                    console.log("--- AI åŸå§‹å›å¤ ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AIå›å¤å¤±è´¥: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },

            async parseAndDisplayAIResponse(text) {
                const contacts = await DBHelper.getAll('contacts');
                const currentChatData = await DBHelper.get('chats', appState.currentChatId) || { chatId: appState.currentChatId, history: [] };
                const displayableMessages = [];
                let newGroupNameFromAI = null;

                const createBaseMessage = (senderName) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`æœªåœ¨é€šè®¯å½•ä¸­æ‰¾åˆ°åä¸º "${senderName}" çš„è§’è‰²ï¼Œè·³è¿‡æ­¤æ¶ˆæ¯ã€‚`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        senderId: sender.id,
                        timestamp: Date.now(),
                        type: 'received',
                        isUnread: false,
                        senderInfo: sender,
                    };
                };

                const allMessageRegex = /<ç³»ç»Ÿ>([\s\S]*?)<\/ç³»ç»Ÿ>|<ç§èŠ>([\s\S]*?)<\/ç§èŠ>|ã€([^ã€]+?)ã€|ã€([^ã€‘]+?)ã€‘|ã€Œ([^ã€]+?)ã€|{([^{}]+?)}|\[([^\[\]]+?)\]|<((?!ç³»ç»Ÿ|ç§èŠ)[^>]+?)>/g;
                
                text.replace(allMessageRegex, (match, systemContent, privateContent, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    
                    if (systemContent !== undefined) {
                        const content = systemContent.trim();
                        const nameChangeParts = content.match(/(.+?)\s*ä¿®æ”¹ç¾¤åä¸º\s*(.*)$/);
                        if (nameChangeParts && nameChangeParts.length === 3) {
                            const rawNewName = nameChangeParts[2].trim();
                            const parsedNewName = rawNewName.replace(/^["â€œ]|["â€]$/g, '');
                            newGroupNameFromAI = parsedNewName;

                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${nameChangeParts[1].trim()} ä¿®æ”¹ç¾¤åä¸º ${parsedNewName}`,
                                timestamp: Date.now(),
                                type: 'received',
                                segmentType: 'system',
                                forAi: true
                            };
                            currentChatData.history.push(systemMessage);
                            displayableMessages.push(systemMessage);
                        }
                    } else if (privateContent !== undefined) {
                        const innerMatch = privateContent.match(/\[([^|]+?)\|(.+?)\]/);
                        if (innerMatch) {
                            const senderName = innerMatch[1].trim();
                            const msgContent = innerMatch[2].trim();
                            const sender = contacts.find(c => c.name === senderName);
                            if (sender) {
                                (async () => {
                                    const privateChatData = await DBHelper.get('chats', sender.id) || { chatId: sender.id, history: [] };
                                    const privateMessage = {
                                        messageId: Utils.generateId('msg'),
                                        senderId: sender.id,
                                        content: msgContent,
                                        timestamp: Date.now(),
                                        type: 'received',
                                        isUnread: true,
                                        isPrivateInGroup: true, 
                                        senderInfo: sender,
                                        segmentType: 'text'
                                    };
                                    privateChatData.history.push(privateMessage);
                                    await DBHelper.put('chats', privateChatData);
                                    UIManager.showTopNotification(privateMessage);
                                })();
                            }
                        }
                    } else if (cardContent !== undefined) {
                        const parts = cardContent.split('|').map(p => p.trim());
                        const [senderName, shareType, title, summary, details] = parts;
                        const baseMessage = createBaseMessage(senderName);
                        if (baseMessage) {
                            baseMessage.segmentType = 'card';
                            baseMessage.content = `[å¡ç‰‡] ${title}`;
                            baseMessage.cardData = { shareType, title, summary, details, isExpanded: false };
                            currentChatData.history.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    } else if (innerVoiceContent !== undefined) {
                        const parts = innerVoiceContent.split('|').map(p => p.trim());
                        const sender = contacts.find(c => c.name === parts[1]);
                        if (sender) {
                            currentChatData.history.push({ messageId: Utils.generateId('msg'), senderId: sender.id, content: parts[2], timestamp: Date.now(), type: 'received', isUnread: false, segmentType: 'inner_voice' });
                        }
                    } else if (essayContent !== undefined) {
                        const parts = essayContent.split('|').map(p => p.trim());
                        const sender = contacts.find(c => c.name === parts[1]);
                        if (sender) {
                            currentChatData.history.push({ messageId: Utils.generateId('msg'), senderId: sender.id, content: parts[2], timestamp: Date.now(), type: 'received', isUnread: false, segmentType: 'essay' });
                            UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                        }
                    } else { 
                        let bracketType;
                        let innerContent;

                        if (retractedContent !== undefined) { bracketType = '{'; innerContent = retractedContent; }
                        else if (standardContent !== undefined) { bracketType = '['; innerContent = standardContent; }
                        else if (emojiContent !== undefined) { bracketType = '<'; innerContent = emojiContent; }
                        else { return; } 

                        const parts = innerContent.split('|').map(p => p.trim());
                        const [senderName] = parts;
                        const baseMessage = createBaseMessage(senderName);
                        if (!baseMessage) return;

                        baseMessage.isRetracted = bracketType === '{';
                        baseMessage.toBeRetracted = bracketType === '{';

                        if (bracketType === '<') {
                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else if (parts.length === 2) {
                            baseMessage.segmentType = 'text';
                            baseMessage.content = parts[1];
                        } else if (parts[1] === 'é¢†å–è½¬è´¦') {
                            baseMessage.segmentType = 'transfer-receipt';
                            baseMessage.content = `${parts[2]}å·²æ”¶æ¬¾${parts[3]}`;
                            baseMessage.cardData = { recipientName: parts[0], senderName: parts[2], amount: parts[3] };
                        } else if (parts[1] === 'è¯­éŸ³') {
                            baseMessage.segmentType = 'voice';
                            baseMessage.content = `[è¯­éŸ³] ${parts[3]}`;
                            baseMessage.cardData = { duration: parts[2], content: parts[3] };
                        } else if (parts[1] === 'å¼•ç”¨') {
                            baseMessage.segmentType = 'quote';
                            baseMessage.content = `[å¼•ç”¨] ${parts[4]}`;
                            baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] };
                        } else if (parts[1] === 'è½¬è´¦') {
                            baseMessage.segmentType = 'transfer';
                            baseMessage.content = `[è½¬è´¦] ${parts[3]}`;
                            baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                        } else if (parts[1] === 'çº¢åŒ…') {
                            baseMessage.segmentType = 'red-packet';
                            baseMessage.content = `[çº¢åŒ…] ${parts[2]}`;
                            baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('ï¿¥', '')), count: parseInt(parts[4]), claimedBy: [] };
                        }

                        if (baseMessage.segmentType) {
                            currentChatData.history.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    }
                });

                if (newGroupNameFromAI && appState.currentChatId.startsWith('group-')) {
                    const group = await DBHelper.get('groups', appState.currentChatId);
                    if (group) {
                        group.name = newGroupNameFromAI;
                        await DBHelper.put('groups', group);
                        chatTitle.textContent = newGroupNameFromAI;
                    }
                }

                if (displayableMessages.length > 0) {
                    currentChatData.lastAiReplyTimestamp = Date.now();
                }

                await DBHelper.put('chats', currentChatData);

                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));
                    
                    if (msg.segmentType === 'system') {
                        const notice = document.createElement('div');
                        notice.className = 'system-notice';
                        notice.id = msg.messageId;
                        notice.textContent = msg.content;
                        chatArea.appendChild(notice);
                        chatArea.scrollTop = chatArea.scrollHeight;
                        continue;
                    }

                    UIManager.addMessageToDOM(msg, msg.senderInfo, false, true);

                    if (msg.toBeRetracted) {
                        const retractDelay = Math.random() * 1000 + 1000;
                        setTimeout(async () => {
                            const chatToUpdate = await DBHelper.get('chats', appState.currentChatId);
                            const msgToRetract = chatToUpdate.history.find(m => m.messageId === msg.messageId);
                            if (msgToRetract) {
                                msgToRetract.isRetracted = true;
                                await DBHelper.put('chats', chatToUpdate);
                                const bubbleEl = $(`#${msg.messageId}`);
                                if (bubbleEl) {
                                    const retractionNotice = UIManager.createRetractionNotice(msgToRetract, msg.senderInfo);
                                    bubbleEl.replaceWith(retractionNotice);
                                }
                            }
                        }, retractDelay);
                    }
                }
            },

            async parseAndDisplayActiveAIResponse(text) {
                const contacts = await DBHelper.getAll('contacts');
                const chatData = await DBHelper.get('chats', appState.currentChatId) || { chatId: appState.currentChatId, history: [] };
                const displayableMessages = [];

                const createBaseMessage = (senderName, displayTimestamp) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`æœªæ‰¾åˆ°è§’è‰² "${senderName}"ï¼Œè·³è¿‡æ­¤ä¸»åŠ¨å›å¤æ¶ˆæ¯ã€‚`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        senderId: sender.id,
                        timestamp: Date.now(),
                        type: 'received',
                        isUnread: false, 
                        senderInfo: sender,
                        isAutoReply: true,
                        displayTimestamp: displayTimestamp,
                    };
                };

                const allMessageRegex = /ã€([^ã€]+?)ã€|ã€([^ã€‘]+?)ã€‘|ã€Œ([^ã€]+?)ã€|{([^{}]+?)}|\[([^\[\]]+?)\]|<([^>]+?)>/g;

                text.replace(allMessageRegex, (match, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    
                    if (innerVoiceContent) {
                        const parts = innerVoiceContent.split('|').map(p => p.trim());
                        if (parts[0] === 'å¿ƒå£°' && parts.length === 3) {
                            const sender = contacts.find(c => c.name === parts[1]);
                            if (sender) {
                                chatData.history.push({ messageId: Utils.generateId('msg'), senderId: sender.id, content: parts[2], timestamp: Date.now(), type: 'received', segmentType: 'inner_voice' });
                            }
                        }
                        return; 
                    }
                    if (essayContent) {
                        const parts = essayContent.split('|').map(p => p.trim());
                        if (parts[0] === 'éšç¬”' && parts.length === 3) {
                            const sender = contacts.find(c => c.name === parts[1]);
                            if (sender) {
                                chatData.history.push({ messageId: Utils.generateId('msg'), senderId: sender.id, content: parts[2], timestamp: Date.now(), type: 'received', segmentType: 'essay' });
                                
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                        }
                        return; 
                    }

                    let parts, senderName, displayTimestamp, baseMessage;

                    if (cardContent !== undefined) {
                        parts = cardContent.split('|').map(p => p.trim());
                        if (parts.length < 5) return;
                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (baseMessage) {
                            baseMessage.segmentType = 'card';
                            baseMessage.content = `[å¡ç‰‡] ${parts[2]}`;
                            baseMessage.cardData = { shareType: parts[1], title: parts[2], summary: parts[3], details: parts[4], isExpanded: false };
                            chatData.history.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    } else {
                        let innerContent, bracketType;
                        if (retractedContent) { innerContent = retractedContent; bracketType = '{'; }
                        else if (standardContent) { innerContent = standardContent; bracketType = '['; }
                        else if (emojiContent) { innerContent = emojiContent; bracketType = '<'; }
                        else { return; }

                        parts = innerContent.split('|').map(p => p.trim());
                        if (parts.length < 2) return;

                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (!baseMessage) return;

                        
                        if (bracketType === '{') {
                            baseMessage.isRetracted = true;
                            baseMessage.toBeRetracted = true;
                        }

                        if (bracketType === '<') {
                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else if (bracketType === '[') {
                            const typeKeyword = parts[1];
                            switch (typeKeyword) {
                                case 'è¯­éŸ³':
                                    baseMessage.segmentType = 'voice';
                                    baseMessage.content = `[è¯­éŸ³] ${parts[3]}`;
                                    baseMessage.cardData = { duration: parts[2], content: parts[3] };
                                    break;
                                case 'å¼•ç”¨':
                                    baseMessage.segmentType = 'quote';
                                    baseMessage.content = `[å¼•ç”¨] ${parts[4]}`;
                                    baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] };
                                    break;
                                case 'è½¬è´¦':
                                    baseMessage.segmentType = 'transfer';
                                    baseMessage.content = `[è½¬è´¦] ${parts[3]}`;
                                    baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                                    break;
                                case 'çº¢åŒ…':
                                    baseMessage.segmentType = 'red-packet';
                                    baseMessage.content = `[çº¢åŒ…] ${parts[2]}`;
                                    baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('ï¿¥', '')), count: parseInt(parts[4]), claimedBy: [] };
                                    break;
                                default:
                                    baseMessage.segmentType = 'text';
                                    baseMessage.content = parts.slice(1).join('|');
                                    break;
                            }
                        } else {
                            baseMessage.segmentType = 'text';
                            baseMessage.content = parts.slice(1).join('|');
                        }

                        if (baseMessage.segmentType) {
                            chatData.history.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    }
                });

                if (displayableMessages.length > 0 || chatData.history.some(m => m.segmentType === 'inner_voice' || m.segmentType === 'essay')) {
                    chatData.lastAiReplyTimestamp = Date.now();
                }
                
                await DBHelper.put('chats', chatData);

                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));
                    UIManager.addMessageToDOM(msg, msg.senderInfo, false, true);
                    
                    
                    if (msg.toBeRetracted) {
                        const retractDelay = Math.random() * 1000 + 1000;
                        setTimeout(async () => {
                            const chatToUpdate = await DBHelper.get('chats', appState.currentChatId);
                            const msgToRetract = chatToUpdate.history.find(m => m.messageId === msg.messageId);
                            if (msgToRetract) {
                                msgToRetract.isRetracted = true;
                                await DBHelper.put('chats', chatToUpdate);
                                const bubbleEl = $(`#${msg.messageId}`);
                                if (bubbleEl) {
                                    const retractionNotice = UIManager.createRetractionNotice(msgToRetract, msg.senderInfo);
                                    bubbleEl.replaceWith(retractionNotice);
                                }
                            }
                        }, retractDelay);
                    }
                }
            },

            showError(message) {
                 UIManager.showModal({
                    title: "é”™è¯¯",
                    body: `<p>${message}</p>`,
                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleMomentsRefreshRequest() {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const refreshBtn = $('#moments-refresh-btn i');
                refreshBtn.classList.add('fa-spin');

                try {
                    const prompt = await this.buildMomentsRefreshPrompt();
                    if (!prompt) {
                        UIManager.showToast("æ— æ³•ç”ŸæˆåŠ¨æ€ï¼šåœˆå­ä¿¡æ¯ä¸å®Œæ•´ã€‚");
                        return;
                    }
                    
                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI æœ‹å‹åœˆåŠ¨æ€ (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsResponse(aiRawResponse);
                    
                    
                    const circle = await DBHelper.get('circles', appState.currentCircleId);
                    if (circle) {
                        circle.lastRefreshed = Date.now();
                        await DBHelper.put('circles', circle);
                    }

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error("æœ‹å‹åœˆåŠ¨æ€ç”Ÿæˆå¤±è´¥:", error);
                        this.showError(`åŠ¨æ€ç”Ÿæˆå¤±è´¥: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    refreshBtn.classList.remove('fa-spin');
                }
            },
            
            async handleMomentsCommentRequest(momentId) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions'); 
                
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    
                    commentsSection.style.display = 'block'; 
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = 'æœ‹å‹ä»¬æ­£åœ¨èµ¶æ¥è¯„è®º...';


                try {
                    const prompt = await this.buildMomentsCommentPrompt(momentId);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI æœ‹å‹åœˆè¯„è®º (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsCommentsResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("æœ‹å‹åœˆè¯„è®ºç”Ÿæˆå¤±è´¥:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async handleMomentsPlayerCommentResponse(momentId, playerComment) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions');
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = 'æœ‹å‹ä»¬æ­£åœ¨èµ¶æ¥è¯„è®º...';
                commentsSection.style.display = 'block'; 

                try {
                    const prompt = await this.buildMomentsPlayerCommentPrompt(momentId, playerComment);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI æœ‹å‹åœˆç©å®¶è¯„è®ºå›å¤ (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsPlayerCommentResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("æœ‹å‹åœˆAIå›å¤ç©å®¶è¯„è®ºå¤±è´¥:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async buildMomentsRefreshPrompt() {
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                
                
                const validMemberIds = circle.memberIds.filter(id => allContacts.some(c => c.id === id));
                if (validMemberIds.length !== circle.memberIds.length) {
                    circle.memberIds = validMemberIds; 
                    await DBHelper.put('circles', circle);
                    UIManager.showToast("å·²è‡ªåŠ¨ç§»é™¤åœˆå­ä¸­ä¸å­˜åœ¨çš„å¥½å‹ã€‚");
                }
                if(validMemberIds.length === 0) return null;

                
                const shuffled = validMemberIds.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedMemberIds = shuffled.slice(0, Math.min(numToSelect, validMemberIds.length));
                const selectedMembers = selectedMemberIds.map(id => allContacts.find(c => c.id === id));
                
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allGroups = await DBHelper.getAll('groups');

                
                const timeNow = new Date();
                const lastRefreshTime = new Date(circle.lastRefreshed || (Date.now() - 24*60*60*1000)); 
                const timePrompt = `ç°åœ¨æ˜¯ ${timeNow.toLocaleString('zh-CN')}ã€‚ä¸Šæ¬¡ç”ŸæˆåŠ¨æ€çš„æ—¶é—´æ˜¯ ${lastRefreshTime.toLocaleString('zh-CN')}ã€‚è¯·ç¡®ä¿æœ¬æ¬¡ç”Ÿæˆçš„åŠ¨æ€æ—¶é—´åœ¨æ­¤èŒƒå›´ä¹‹å†…ã€‚`;

                const membersInfo = selectedMembers.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n');
                const playerInfo = `ç©å®¶å: ${myProfile.name}\næ€§åˆ«: ${myProfile.gender}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;
                const extraMembersInfo = circle.extraMembers ? `è¿™ä¸ªåœˆå­è¿˜æœ‰ä¸€äº›å…¶ä»–æœ‹å‹ï¼š${circle.extraMembers}ã€‚` : '';

                let contextHistory = '';
                for (const member of selectedMembers) {
                    const privateChat = await DBHelper.get('chats', member.id);
                    if (privateChat && privateChat.history.length > 0) {
                        const turns = this.buildTurnsFromHistory(privateChat.history, allContacts, myProfile);
                        const lastTwoTurns = turns.slice(-2);
                        if (lastTwoTurns.length > 0) {
                            contextHistory += `ä¸ ${member.name} çš„æœ€æ–°ç§èŠ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                        }
                    }
                    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
                    for (const group of groupsWithMember) {
                        const groupChat = await DBHelper.get('chats', group.id);
                        if (groupChat && groupChat.history.length > 0) {
                            const turns = this.buildTurnsFromHistory(groupChat.history, allContacts, myProfile);
                            const lastTwoTurns = turns.slice(-2);
                            if (lastTwoTurns.length > 0) {
                                contextHistory += `åœ¨ç¾¤èŠ ${group.name} ä¸­ ${member.name} çš„ç›¸å…³åŠ¨æ€ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                            }
                        }
                    }
                }
                const formatRules = `
---
æœ‹å‹åœˆåŠ¨æ€ç”Ÿæˆè§„åˆ™ï¼ˆéå¸¸é‡è¦ï¼ï¼‰ï¼š
1.  ä½ å°†æ‰®æ¼” ${selectedMembers.map(m=>m.name).join('ã€')} è¿™å‡ ä½è§’è‰²ï¼Œå¹¶ä¸ºä»–ä»¬ç”Ÿæˆæœ‹å‹åœˆåŠ¨æ€ã€‚
2.  ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ï¼Œæ¯æ¡åŠ¨æ€éƒ½å¿…é¡»è¢«ä¸€ä¸ª <æœ‹å‹åœˆ> æ ‡ç­¾åŒ…è£¹ã€‚
3.  åŠ¨æ€æ ¼å¼: ã€ä½œè€…è§’è‰²åï¼šåŠ¨æ€å†…å®¹|åŠ¨æ€æ—¶é—´(æœˆ/æ—¥ HH:mm)ã€‘
4.  ç‚¹èµæ ¼å¼(å¼ºåˆ¶è¦æ±‚): åœ¨åŠ¨æ€æ ¼å¼ä¹‹åï¼Œå¦èµ·ä¸€è¡Œï¼Œç”¨ä¸­æ–‡æ‹¬å·åŒ…è£¹ç‚¹èµåˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼ˆå·²ç‚¹èµï¼šå¼ ä¸‰,æå››,ç‹äº”ï¼‰ã€‚ç‚¹èµè€…å¯ä»¥æ˜¯åœˆå†…ä»»ä½•AIè§’è‰²ã€é¢å¤–å¥½å‹â€ã€‚
5.  è¯„è®ºæ ¼å¼: ã€–è¯„è®ºè€…è§’è‰²åï¼šè¯„è®ºå†…å®¹ã€—ç¦æ­¢åœ¨ã€–ã€—å†…åµŒå¥—ã€–ã€—
6.  ä½ å¯ä»¥è®©è§’è‰²äº’ç›¸è¯„è®ºï¼Œä¹Ÿå¯ä»¥è®©åœˆå­é‡Œçš„é¢å¤–å¥½å‹ï¼ˆ${circle.extraMembers || 'æ— '}ï¼‰å‚ä¸è¯„è®ºã€‚
7.  åŠ¨æ€å†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾ï¼Œå¯ä»¥å›¾æ–‡å¹¶èŒ‚ï¼ˆç”¨æ–‡å­—æè¿°å›¾ç‰‡ï¼‰ï¼Œä¹Ÿå¯ä»¥åªæ˜¯çº¯æ–‡å­—ã€‚
8.  ç”Ÿæˆ1åˆ°4æ¡ä¸ç­‰çš„åŠ¨æ€ï¼Œå†…å®¹ä¸èƒ½é‡å¤ã€‚
9.  ä½œè€…å’Œè¯„è®ºè€…çš„è§’è‰²åå¿…é¡»æ˜¯è§’è‰²çš„åå­—ï¼ˆä¾‹å¦‚ï¼š${selectedMembers.map(m=>m.name).join(', ')}ï¼‰ã€é¢å¤–å¥½å‹çš„åå­—æˆ–ç©å®¶çš„åå­—ã€‚
10. **ä¸¥ç¦OOCï¼Œä¸¥ç¦ç”Ÿæˆæ ¼å¼ä¹‹å¤–çš„å†…å®¹ï¼Œä¸¥ç¦ä»£æ›¿ç©å®¶è¿›è¡Œè¯„è®ºæˆ–å›å¤**ã€‚
11.ä¸¾ä¾‹ï¼š
<æœ‹å‹åœˆ>
ã€33ï¼šä»Šå¤©å¤©æ°”çœŸä¸é”™ï¼Œæœ‰æ²¡æœ‰è¦ä¸€èµ·å‡ºå»ç©çš„ï¼Ÿ|7/3 8:36ã€‘
ï¼ˆå·²ç‚¹èµï¼švv,å…¥å…¥ï¼‰
ã€–vvï¼šå¸¦æˆ‘ä¸€ä¸ªï¼ã€—
ã€–å…¥å…¥ï¼šæˆ‘ä¹Ÿè¦å»â€”â€”ã€—
</æœ‹å‹åœˆ>
---
`;
                
                const finalPrompt = [
                    timePrompt,
                    playerInfo,
                    `--- åœˆå­é‡Œçš„AIè§’è‰² ---\n${membersInfo}`,
                    extraMembersInfo,
                    `--- æœ€è¿‘çš„èŠå¤©è®°å½•å‚è€ƒ ---\n${contextHistory}`,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS REFRESH PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsCommentPrompt(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allGroups = await DBHelper.getAll('groups'); // æ–°å¢ï¼šè·å–æ‰€æœ‰ç¾¤èŠä¿¡æ¯

                // å‡†å¤‡è§’è‰²èµ„æ–™
                const momentAuthor = allContacts.find(c => c.id === moment.authorId);
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                const otherMembers = circleMembers.filter(c => c.id !== moment.authorId);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));

                let membersToProvideInfo = [];
                if (momentAuthor) { // å¦‚æœä½œè€…æ˜¯AIè§’è‰²
                    membersToProvideInfo.push(momentAuthor);
                }
                membersToProvideInfo.push(...selectedRandomMembers);
                membersToProvideInfo = [...new Set(membersToProvideInfo)]; // å»é‡

                const membersInfo = membersToProvideInfo.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n');
                
                // æ–°å¢ï¼šè·å–èŠå¤©è®°å½•ä¸Šä¸‹æ–‡
                let contextHistory = '';
                for (const member of membersToProvideInfo) {
                    const privateChat = await DBHelper.get('chats', member.id);
                    if (privateChat && privateChat.history.length > 0) {
                        const turns = this.buildTurnsFromHistory(privateChat.history, allContacts, myProfile);
                        const lastTwoTurns = turns.slice(-2);
                        if (lastTwoTurns.length > 0) {
                            contextHistory += `ä¸ ${member.name} çš„æœ€æ–°ç§èŠ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                        }
                    }
                    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
                    for (const group of groupsWithMember) {
                        const groupChat = await DBHelper.get('chats', group.id);
                        if (groupChat && groupChat.history.length > 0) {
                            const turns = this.buildTurnsFromHistory(groupChat.history, allContacts, myProfile);
                            const lastTwoTurns = turns.slice(-2);
                            if (lastTwoTurns.length > 0) {
                                contextHistory += `åœ¨ç¾¤èŠ ${group.name} ä¸­ ${member.name} çš„ç›¸å…³åŠ¨æ€ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                            }
                        }
                    }
                }

                const postContentText = `ç©å®¶â€œ${myProfile.name}â€å‘å¸ƒäº†ä¸€æ¡åŠ¨æ€ï¼š\nâ€œ${moment.content}â€`;

                const privateChatRules = `
---
ç§èŠè§„åˆ™:
1.  å¦‚æœä½ æƒ³è®©æŸä½è§’è‰²ç§èŠç©å®¶ï¼Œè¯·ä½¿ç”¨ <ç§èŠ></ç§èŠ> æ ‡ç­¾åŒ…è£¹ç§èŠå†…å®¹ã€‚
2.  ç§èŠå†…å®¹æ ¼å¼å¯ä»¥æ˜¯: [è§’è‰²å|æ¶ˆæ¯å†…å®¹] æˆ– {è§’è‰²å|æ’¤å›å†…å®¹} æˆ– [è§’è‰²å|è¯­éŸ³|æ—¶é•¿|å†…å®¹] æˆ– [è§’è‰²å|è½¬è´¦|æ”¶æ¬¾äºº|é‡‘é¢|å¤‡æ³¨]
3.  ä¾‹å¦‚: <ç§èŠ>[ä¸‰ä¸‰|ä½ åˆšæ‰å‘çš„åŠ¨æ€æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ]</ç§èŠ>
---
`;

                const formatRules = `
---
æœ‹å‹åœˆè¯„è®ºç”Ÿæˆè§„åˆ™ï¼š
1.  ä½ å°†æ‰®æ¼”åœˆå­é‡Œçš„å¥½å‹ï¼Œå¯¹ç©å®¶çš„åŠ¨æ€è¿›è¡Œè¯„è®ºå’Œç‚¹èµã€‚
2.  ç‚¹èµæ ¼å¼ï¼šç”¨ä¸­æ–‡æ‹¬å·åŒ…è£¹ç‚¹èµåˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼ˆå·²ç‚¹èµï¼šå¼ ä¸‰,æå››,ç‹äº”ï¼‰ã€‚ç‚¹èµè€…å¯ä»¥æ˜¯åœˆå†…ä»»ä½•AIè§’è‰²æˆ–é¢å¤–å¥½å‹ã€‚
3.  ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ï¼Œæ¯æ¡è¯„è®ºéƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å•å…ƒ: ã€–è¯„è®ºè€…è§’è‰²åï¼šè¯„è®ºå†…å®¹ã€—ï¼Œç¦æ­¢åœ¨ã€–ã€—å†…åµŒå¥—ã€–ã€—ã€‚
4.  è¯„è®ºå†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾ï¼Œä¸è¶…è¿‡20ä¸ªå­—ã€‚
5.  **ä¸¥ç¦OOCï¼Œä¸¥ç¦ç”Ÿæˆæ ¼å¼ä¹‹å¤–çš„å†…å®¹ï¼Œä¸¥ç¦ä»£æ›¿ç©å®¶è¿›è¡Œè¯„è®ºæˆ–å›å¤**ã€‚
6.  è‡³å°‘ç”Ÿæˆ2æ¡è¯„è®ºï¼Œæœ€å¤šç”Ÿæˆ5æ¡è¯„è®ºã€‚
7.  ä¸¾ä¾‹ï¼š
ï¼ˆå·²ç‚¹èµï¼š33,vv,å…¥å…¥ï¼‰
ã€–33ï¼šè¿™æ˜¯ä»€ä¹ˆï¼Œçœ‹èµ·æ¥å¾ˆå¥½åƒçš„æ ·å­ã€—
ã€–å…¥å…¥ï¼šæˆ‘ä¹Ÿè¦åƒwwwã€—
---
`;
                const finalPrompt = [
                    postContentText,
                    `--- å‚ä¸è¯„è®ºçš„è§’è‰²èµ„æ–™å‚è€ƒ ---\n${membersInfo}`,
                    `--- æœ€è¿‘çš„èŠå¤©è®°å½•å‚è€ƒ ---\n${contextHistory}`, // ä¿®æ”¹å¤„ï¼šæ·»åŠ äº†èŠå¤©è®°å½•ä¸Šä¸‹æ–‡
                    privateChatRules,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsPlayerCommentPrompt(momentId, playerComment) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');
                
                // å‡†å¤‡è§’è‰²èµ„æ–™
                let membersToProvideInfo = [];
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                
                // 1. æ·»åŠ è¢«å›å¤è€…çš„èµ„æ–™ (å¦‚æœæ˜¯AIè§’è‰²)
                const repliedToContact = playerComment.replyTo ? circleMembers.find(c => c.name === playerComment.replyTo) : null;
                if (repliedToContact) {
                    membersToProvideInfo.push(repliedToContact);
                }

                // 2. éšæœºæŠ½å– 1-3 ä½å…¶ä»–åœˆå†…å¥½å‹
                const otherMembers = circleMembers.filter(c => c.name !== playerComment.replyTo);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));
                membersToProvideInfo.push(...selectedRandomMembers);

                membersToProvideInfo = [...new Set(membersToProvideInfo)]; // å»é‡

                const membersInfo = membersToProvideInfo.length > 0
                    ? membersToProvideInfo.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n')
                    : 'æ— ';

                // æ„å»ºå†å²å’Œå½“å‰åŠ¨ä½œ
                let momentAuthor = moment.authorId === myProfile.id ? myProfile : allContacts.find(c => c.id === moment.authorId) || { name: moment.authorId };
                let postAndCommentsHistory = `è¿™æ˜¯â€œ${momentAuthor.name}â€å‘å¸ƒçš„åŠ¨æ€ï¼šâ€œ${moment.content}â€\nç›®å‰çš„è¯„è®ºæœ‰ï¼š\n` + 
                    (moment.comments || []).map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `â€œ${cAuthor.name}${c.replyTo ? ` å›å¤ ${c.replyTo}` : ''}ï¼š${c.content}â€`;
                    }).join('\n');
                
                const playerActionText = playerComment.replyTo 
                    ? `ç©å®¶â€œ${myProfile.name}â€å›å¤äº†â€œ${playerComment.replyTo}â€è¯´ï¼šâ€œ${playerComment.content}â€` 
                    : `ç©å®¶â€œ${myProfile.name}â€è¯„è®ºè¯´ï¼šâ€œ${playerComment.content}â€`;

                const privateChatRules = `
---
ç§èŠè§„åˆ™(å¯é€‰):
1.  å¦‚æœä½ æƒ³è®©æŸä¸ªè§’è‰²ç§èŠç©å®¶ï¼Œè¯·ä½¿ç”¨ <ç§èŠ></ç§èŠ> æ ‡ç­¾åŒ…è£¹ã€‚
2.  ç§èŠå†…å®¹æ ¼å¼å¯ä»¥æ˜¯: [è§’è‰²å|æ¶ˆæ¯å†…å®¹] æˆ– {è§’è‰²å|æ’¤å›å†…å®¹} æˆ– [è§’è‰²å|è¯­éŸ³|æ—¶é•¿|å†…å®¹] æˆ– [è§’è‰²å|è½¬è´¦|æ”¶æ¬¾äºº|é‡‘é¢|å¤‡æ³¨]
3.  ä¾‹å¦‚: <ç§èŠ>[33|ä½ åˆšæ‰å‘çš„åŠ¨æ€æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ]</ç§èŠ>
---
`;
                
                const formatRules = `
---
æœ‹å‹åœˆè¯„è®ºç”Ÿæˆè§„åˆ™ï¼š
1.  ä½ å°†æ‰®æ¼”åœˆå†…å¥½å‹å¯¹ç©å®¶çš„è¯„è®ºåšå‡ºå›åº”ã€‚
2.  ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç”Ÿæˆå›å¤ï¼Œå¯ä»¥åªæœ‰ç‚¹èµï¼Œæˆ–åªæœ‰è¯„è®ºï¼Œæˆ–ä¸¤è€…éƒ½æœ‰ã€‚
3.  ç‚¹èµæ ¼å¼ï¼šç”¨ä¸­æ–‡æ‹¬å·åŒ…è£¹ç‚¹èµåˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼ˆå·²ç‚¹èµï¼šå¼ ä¸‰,æå››ï¼‰ã€‚
4.  è¯„è®ºæ ¼å¼: ã€–è¯„è®ºè€…è§’è‰²åï¼šè¯„è®ºå†…å®¹ã€—ï¼Œç¦æ­¢åœ¨ã€–ã€—å†…åµŒå¥—ã€–ã€—ã€‚
5.  è¯„è®ºå†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾ï¼Œå¯ä»¥æ˜¯å¯¹ç©å®¶è¯„è®ºçš„ç›´æ¥å›åº”ï¼Œä¹Ÿå¯ä»¥æ˜¯è§’è‰²ä¹‹é—´çš„äº’åŠ¨ã€‚
6.  ä¸¥ç¦OOCï¼Œä¸¥ç¦ç”Ÿæˆæ ¼å¼ä¹‹å¤–çš„å†…å®¹ã€‚
---
`;
                
                const finalPrompt = [
                    `--- è§’è‰²èµ„æ–™å‚è€ƒ ---\n${membersInfo}`,
                    `--- åŠ¨æ€ä¸å†å²è¯„è®º ---\n${postAndCommentsHistory}`,
                    `--- ç©å®¶æœ€æ–°åŠ¨ä½œ ---\n${playerActionText}`,
                    privateChatRules,
                    formatRules
                ].join('\n\n');

                console.log("--- MOMENTS PLAYER COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async parseAndDisplayMomentsResponse(text) {
                const momentsListUl = $('#moments-list');
                const momentBlocks = text.match(/<æœ‹å‹åœˆ>[\s\S]*?<\/æœ‹å‹åœˆ>/g) || [];
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const circle = await DBHelper.get('circles', appState.currentCircleId);

                if (momentBlocks.length > 0 && momentsListUl.innerHTML.includes('è¿˜æ²¡æœ‰åŠ¨æ€')) {
                    momentsListUl.innerHTML = ''; 
                }

                for (const block of momentBlocks) {
                    const postMatch = block.match(/ã€(.*?)ã€‘/);
                    if (!postMatch) continue;

                    const [authorPart, timePart] = postMatch[1].split('|');
                    const [authorName, ...contentParts] = authorPart.split('ï¼š');
                    const content = contentParts.join('ï¼š');

                    const author = allContacts.find(c => c.name === authorName.trim());

                    
                    const likeMatch = block.match(/ï¼ˆå·²ç‚¹èµï¼š(.*?)ï¼‰/);
                    const likerNames = likeMatch ? likeMatch[1].split(/,|ï¼Œ/).map(n => n.trim()) : [];

                    const newMoment = {
                        id: Utils.generateId('moment'),
                        circleId: appState.currentCircleId,
                        authorId: author ? author.id : authorName.trim(),
                        content: content.trim(),
                        images: [], 
                        timestamp: Utils.parseMomentTimestamp(timePart ? timePart.trim() : null),
                        likes: likerNames, 
                        comments: []
                    };
                    
                    const commentMatches = block.match(/ã€–(.*?)ã€—/g) || [];
                    for (const cMatch of commentMatches) {
                        const inner = cMatch.slice(1, -1);
                        const [cAuthorName, ...cContentParts] = inner.split('ï¼š');
                        const trimmedAuthorName = cAuthorName.trim();
                        
                        let authorId;
                        if (trimmedAuthorName === myProfile.name) {
                            authorId = myProfile.id; 
                        } else {
                            const cAuthor = allContacts.find(c => c.name === trimmedAuthorName);
                            authorId = cAuthor ? cAuthor.id : trimmedAuthorName; 
                        }
                        
                        newMoment.comments.push({
                            authorId: authorId,
                            content: cContentParts.join('ï¼š').trim(),
                            timestamp: Date.now()
                        });
                    }

                    await DBHelper.put('moments', newMoment);
                    const momentElement = UIManager.createMomentElement(newMoment, myProfile, allContacts, circle.extraMembers);
                    momentsListUl.prepend(momentElement);
                }
            },
            async parseAndDisplayMomentsCommentsResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return; // å¦‚æœæ‰¾ä¸åˆ°åŠ¨æ€ï¼Œåˆ™æå‰é€€å‡º

                // 1. å¤„ç†ç§èŠæ¶ˆæ¯
                const privateChatRegex = /<ç§èŠ>([\s\S]*?)<\/ç§èŠ>/g;
                let privateMessageMatch;
                while ((privateMessageMatch = privateChatRegex.exec(text)) !== null) {
                    await this.handlePrivateMessageFromMoment(privateMessageMatch[1], moment);
                }
                const publicText = text.replace(privateChatRegex, '').trim();

                // 2. å¤„ç†å…¬å¼€çš„ç‚¹èµå’Œè¯„è®º
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                if (!interactionsContainer) return;
                interactionsContainer.style.display = 'block';

                const likeMatch = publicText.match(/ï¼ˆå·²ç‚¹èµï¼š(.*?)ï¼‰/);
                if (likeMatch && likeMatch[1]) {
                    const likerNames = likeMatch[1].split(/,|ï¼Œ/).map(n => n.trim()).filter(Boolean);
                    if (!moment.likes) moment.likes = [];
                    likerNames.forEach(name => {
                        if (!moment.likes.includes(name)) moment.likes.push(name);
                    });
                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                    const likeBtn = postElement.querySelector('[data-action="like"]');
                    if (likeBtn) {
                        likeBtn.classList.toggle('liked', moment.likes.includes(myProfile.name));
                    }
                }

                const commentMatches = publicText.match(/ã€–(.*?)ã€—/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                if (!commentsListContainer) return;

                if (commentMatches.length === 0 && !likeMatch) {
                    if (likeMatch) await DBHelper.put('moments', moment);
                    return;
                }

                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('ï¼š');
                    const content = cContentParts.join('ï¼š').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    const authorId = cAuthor ? cAuthor.id : cAuthorName.trim();
                    
                    const newComment = { authorId, content, timestamp: Date.now() };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    let commentAuthorInfo;
                     if (authorId === myProfile.id) {
                        commentAuthorInfo = myProfile;
                    } else {
                        commentAuthorInfo = allContacts.find(c => c.id === authorId) || { name: authorId, id: authorId };
                    }
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    const authorStyle = commentAuthorInfo.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                    commentDiv.innerHTML = `<span class="comment-author" ${authorStyle}>${commentAuthorInfo.name}:</span> ${content}`;

                    commentsListContainer.appendChild(commentDiv);
                }

                await DBHelper.put('moments', moment);
            },

            async handlePrivateMessageFromMoment(privateContent, moment) {
                if (!moment) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                
                const standardMatch = privateContent.match(/\[([^\[\]]+?)\]/);
                const retractedMatch = privateContent.match(/{([^{}]+?)}/);
                const emojiMatch = privateContent.match(/<([^>]+?)>/);

                let parts, senderName, sender;
                let match = standardMatch || retractedMatch || emojiMatch;
                if (!match) return;

                parts = match[1].split('|').map(p => p.trim());
                senderName = parts[0];
                sender = allContacts.find(c => c.name === senderName);
                if (!sender) return;

                // 1. åˆ›å»ºæœ‹å‹åœˆä¸Šä¸‹æ–‡çš„ç³»ç»Ÿæ¶ˆæ¯
                const momentAuthor = (await EventManager.getMomentAuthor(moment.authorId))?.name || 'æœªçŸ¥ä½œè€…';
                let commentsText = 'æ— ';
                if (moment.comments && moment.comments.length > 0) {
                    commentsText = '\n' + moment.comments.map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `${cAuthor.name}${c.replyTo ? ` å›å¤ ${c.replyTo}` : ''}: ${c.content}`;
                    }).join('\n');
                }
                const contextContent = `<æœ‹å‹åœˆåŠ¨æ€>
åŠ¨æ€å‘å¸–äººï¼š${momentAuthor}
åŠ¨æ€å†…å®¹ï¼š${moment.content}
åŠ¨æ€æ—¶é—´ï¼š${Utils.formatTimestampSmartly(moment.timestamp)}
ç‚¹èµæƒ…å†µï¼š${(moment.likes && moment.likes.length > 0) ? moment.likes.join(', ') : 'æ— '}
è¯„è®ºåŒºï¼š${commentsText}
</æœ‹å‹åœˆåŠ¨æ€>`;

                const contextMessage = {
                    messageId: Utils.generateId('sys'),
                    timestamp: Date.now() - 1, // ç¡®ä¿åœ¨çœŸå®æ¶ˆæ¯ä¹‹å‰
                    type: 'system',
                    segmentType: 'system',
                    content: contextContent,
                    isHidden: true, // ä¸åœ¨UIä¸­æ˜¾ç¤º
                    forAi: true, // è®©AI promptæ„å»ºå™¨åŒ…å«å®ƒ
                };

                // 2. åˆ›å»ºå®é™…çš„ç§èŠæ¶ˆæ¯
                const visibleMessage = {
                    messageId: Utils.generateId('msg'),
                    senderId: sender.id,
                    timestamp: Date.now(),
                    type: 'received',
                    isUnread: appState.currentPage !== 'chat' || appState.currentChatId !== sender.id,
                    senderInfo: sender,
                };
                
                if (retractedMatch) {
                    visibleMessage.isRetracted = true;
                    visibleMessage.segmentType = 'text';
                    visibleMessage.content = parts[1];
                } else if (emojiMatch) {
                    visibleMessage.segmentType = 'emoji-image';
                    visibleMessage.content = parts[1];
                } else {
                    if (parts.length === 2) {
                        visibleMessage.segmentType = 'text';
                        visibleMessage.content = parts[1];
                    } else if (parts[1] === 'è¯­éŸ³') {
                        visibleMessage.segmentType = 'voice';
                        visibleMessage.content = `[è¯­éŸ³] ${parts[3]}`;
                        visibleMessage.cardData = { duration: parts[2], content: parts[3] };
                    } else if (parts[1] === 'è½¬è´¦') {
                        visibleMessage.segmentType = 'transfer';
                        visibleMessage.content = `[è½¬è´¦] ${parts[3]}`;
                        visibleMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                    } else {
                        return;
                    }
                }
                
                // 3. å°†ä¸¤æ¡æ¶ˆæ¯éƒ½å­˜å…¥æ•°æ®åº“
                const privateChatData = await DBHelper.get('chats', sender.id) || { chatId: sender.id, history: [] };
                privateChatData.history.push(contextMessage, visibleMessage);
                await DBHelper.put('chats', privateChatData);

                // 4. ä»…å¯¹å¯è§æ¶ˆæ¯è§¦å‘é€šçŸ¥
                if (visibleMessage.isUnread) {
                    UIManager.showTopNotification(visibleMessage);
                }
            },

            async parseAndDisplayMomentsPlayerCommentResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                interactionsContainer.style.display = 'block';

                
                const likeMatch = text.match(/ï¼ˆå·²ç‚¹èµï¼š(.*?)ï¼‰/);
                if (likeMatch && likeMatch[1]) {
                    const newLikerNames = likeMatch[1].split(/,|ï¼Œ/).map(n => n.trim()).filter(Boolean);
                    
                    if (!moment.likes) moment.likes = [];
                    newLikerNames.forEach(name => {
                        if (!moment.likes.includes(name)) {
                            moment.likes.push(name);
                        }
                    });

                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                }

                
                const commentMatches = text.match(/ã€–(.*?)ã€—/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                
                if (commentMatches.length === 0 && !likeMatch) return;
                
                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));

                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('ï¼š');
                    const content = cContentParts.join('ï¼š').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    
                    const newComment = {
                        authorId: cAuthor ? cAuthor.id : cAuthorName.trim(),
                        content: content,
                        timestamp: Date.now()
                    };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    commentDiv.dataset.authorName = cAuthor ? cAuthor.name : cAuthorName.trim();
                    commentDiv.dataset.authorId = newComment.authorId;
                    commentDiv.innerHTML = `<span class="comment-author">${cAuthor ? cAuthor.name : cAuthorName.trim()}:</span> ${content}`;
                    commentsListContainer.appendChild(commentDiv);
                }
                
                await DBHelper.put('moments', moment);
            },
        };

        
        const EventManager = {
            init() {
                
                bottomNav.addEventListener('click', (e) => {
                    const navItem = e.target.closest('.nav-item');
                    if (navItem) UIManager.navigateTo(navItem.dataset.page);
                });

                
                $('#nav-to-moments').addEventListener('click', () => UIManager.navigateTo('moments', 'discover'));

                
                $('#moments-back-btn').addEventListener('click', () => UIManager.navigateTo('discover'));
                $('#moments-refresh-btn').addEventListener('click', () => AIHandler.handleMomentsRefreshRequest());
                $('#moments-new-post-btn').addEventListener('click', () => this.handleNewMoment());
                $('#moments-manage-btn').addEventListener('click', () => UIManager.showCircleManagementSidebar());
                $('#moments-list').addEventListener('click', (e) => {
                    const postElement = e.target.closest('.moments-post');
                    if (!postElement) return;

                    const momentId = postElement.dataset.momentId;
                    const actionBtn = e.target.closest('[data-action]');
                    const commentItem = e.target.closest('.post-comment-item');

                    
                    if (actionBtn) {
                        const action = actionBtn.dataset.action;

                        if (action === 'toggle-comment') {
                            this.toggleCommentInput(postElement);
                        } else if (action === 'submit-comment') {
                            this.handlePlayerComment(momentId);
                        } else if (action === 'like') {
                            this.handlePlayerLike(momentId);
                        } else if (action === 'forward') {
                            this.handleForwardMoment(momentId);
                        }
                        return; 
                    }
                    
                    
                    if (commentItem) {
                        const authorName = commentItem.dataset.authorName;
                        this.toggleCommentInput(postElement, authorName);
                    }
                });

                $('#moments-list').addEventListener('mousedown', e => this.handleMomentCommentInteractionStart(e, 'mouse'));
                $('#moments-list').addEventListener('touchstart', e => this.handleMomentCommentInteractionStart(e, 'touch'));

                $('#my-avatar').addEventListener('click', () => this.handleEditProfile());
                $('#add-menu-btn').addEventListener('click', () => this.showAddMenu());
                $$('.tab-btn').forEach(btn => btn.addEventListener('click', () => UIManager.renderContactsPage(btn.dataset.tab)));
                $('#sort-friends-btn').addEventListener('click', () => this.handleSortContacts());
                $('#sort-groups-btn').addEventListener('click', () => this.handleSortGroups());
                $('#setting-chat').addEventListener('click', () => this.handleChatSettings());
                $('#setting-api').addEventListener('click', () => this.handleApiSettings());
                $('#setting-prompts').addEventListener('click', () => UIManager.navigateTo('prompts', 'settings'));
                $('#setting-theme').addEventListener('click', () => UIManager.navigateTo('theme-settings', 'settings'));
                $('#setting-reset').addEventListener('click', () => this.handleResetApp());
                
                
                $('#setting-tutorial').addEventListener('click', () => UIManager.navigateTo('tutorial', 'settings'));
                
                
                $('#tutorial-back-btn').addEventListener('click', () => UIManager.navigateTo('settings'));
                $('#page-tutorial .page-content').addEventListener('click', (e) => {
                    const item = e.target.closest('.setting-item');
                    if (!item) return;

                    const showTutorialModal = (title, body) => {
                        UIManager.showModal({
                            title: title,
                            body: `<div style="line-height: 1.7; font-size: 0.95rem;">${body}</div>`,
                            actions: [{ text: 'æˆ‘æ˜ç™½äº†', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                        });
                    };

                    switch (item.id) {
                        case 'tutorial-api':
                            showTutorialModal('å¦‚ä½•é…ç½®API', `
                                <p>èŠå¤©å®¤éœ€è¦ä½ æä¾›ä¸€ä¸ªAIæœåŠ¡å•†çš„API Keyæ‰èƒ½è¿è¡Œã€‚</p>
                                <p>1. è¿›å…¥ <strong>è®¾ç½® > APIé…ç½®</strong> é¡µé¢ã€‚</p>
                                <p>2. ä»â€œAPIæä¾›å•†â€ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä½ æ‹¥æœ‰çš„æœåŠ¡å•†ï¼ˆå¦‚Gemini, SiliconFlowç­‰ï¼‰ã€‚</p>
                                <p>3. ç³»ç»Ÿä¼šè‡ªåŠ¨å¡«å……å¤§éƒ¨åˆ†æœåŠ¡å•†çš„é»˜è®¤URLå’Œæ¨¡å‹ï¼Œä½ åªéœ€åœ¨ <strong>API Key</strong> è¾“å…¥æ¡†ä¸­å¡«å…¥ä½ çš„å¯†é’¥å³å¯ã€‚</p>
                                <p>4. å¦‚æœä½ ä½¿ç”¨è‡ªå®šä¹‰æˆ–æœªåˆ—å‡ºçš„æœåŠ¡å•†ï¼Œè¯·é€‰æ‹©â€œè‡ªå®šä¹‰â€å¹¶æ‰‹åŠ¨å¡«å†™æ‰€æœ‰å­—æ®µã€‚</p>
                                <p><strong>æç¤ºï¼š</strong>API Keyéå¸¸é‡è¦ï¼Œè¯·å¦¥å–„ä¿ç®¡ï¼Œä¸è¦æ³„éœ²ã€‚</p>
                            `);
                            break;
                        case 'tutorial-character':
                            showTutorialModal('å¦‚ä½•åˆ›å»ºæ–°è§’è‰²', `
                                <p>è§’è‰²æ˜¯ä¸ä½ èŠå¤©çš„å¥½å‹ã€‚</p>
                                <p>1. è¿›å…¥ <strong>é€šè®¯å½•</strong> é¡µé¢ã€‚</p>
                                <p>2. ç‚¹å‡»å³ä¸Šè§’çš„ <strong>+</strong> å·æŒ‰é’®ã€‚</p>
                                <p>3. åœ¨å¼¹å‡ºçš„èœå•ä¸­é€‰æ‹© <strong>æ·»åŠ æ–°å¥½å‹</strong>ã€‚</p>
                                <p>4. å¡«å†™è§’è‰²çš„å„é¡¹ä¿¡æ¯ã€‚<strong>å§“å</strong>æ˜¯è§’è‰²çš„å”¯ä¸€IDï¼Œä¸å¯é‡å¤ã€‚å…¶ä»–ä¿¡æ¯å¦‚å–œå¥½ã€èƒŒæ™¯æŒ‰éœ€è¦å¡«å†™ã€‚</p>
                                <p>5. ç‚¹å‡»â€œæ·»åŠ â€å³å¯å®Œæˆåˆ›å»ºã€‚</p>
                                <p>6. ç‚¹å‡»<strong>é€šè®¯å½•</strong>é¡µé¢çš„å¥½å‹å¯è¿›å…¥èŠå¤©ç•Œé¢</p>
                            `);
                            break;
                        case 'tutorial-group':
                            showTutorialModal('å¦‚ä½•åˆ›å»ºç¾¤èŠ', `
                                <p>ä½ å¯ä»¥åˆ›å»ºåŒ…å«å¤šä¸ªå¥½å‹è§’è‰²çš„ç¾¤èŠã€‚</p>
                                <p>1. åŒæ ·åœ¨ <strong>é€šè®¯å½•</strong> é¡µé¢ï¼Œç‚¹å‡»å³ä¸Šè§’ <strong>+</strong> å·å¹¶é€‰æ‹© <strong>æ–°å»ºç¾¤èŠ</strong>ã€‚</p>
                                <p>2. ä¸ºç¾¤èŠèµ·ä¸€ä¸ªåå­—ï¼Œå¹¶ä»å¥½å‹åˆ—è¡¨ä¸­å‹¾é€‰è¦åŠ å…¥ç¾¤èŠçš„å¥½å‹è§’è‰²ï¼ˆè‡³å°‘ä¸€ä½ï¼‰ã€‚</p>
                                <p>3. ä½ è¿˜å¯ä»¥æŒ‡å®šä¸€ä½ç¾¤ä¸»ï¼Œç¾¤ä¸»å¯ä»¥æ˜¯ä½ è‡ªå·±æˆ–ä»»ä½•ä¸€ä½å¥½å‹è§’è‰²ã€‚</p>
                                <p>4. åˆ›å»ºæˆåŠŸåï¼Œä½ å°±å¯ä»¥åœ¨ç¾¤èŠä¸­ä¸å¤šä¸ªå¥½å‹åŒæ—¶äº’åŠ¨äº†ã€‚</p>
                            `);
                            break;
                        case 'tutorial-chatting':
                            showTutorialModal('å¦‚ä½•è¿›è¡ŒèŠå¤©', `
                                <p><strong>1. å‘é€ä¸å›å¤ï¼š</strong></p>
                                <p>åœ¨èŠå¤©è¾“å…¥æ¡†ï¼ˆå³ä¸‹è§’ï¼‰è¾“å…¥å¹¶å‘é€ä½ çš„æ‰€æœ‰æ¶ˆæ¯åï¼Œç‚¹å‡»å·¦ä¸‹è§’çš„ <strong>ç¾½æ¯›æŒ‰é’® <i class="fas fa-feather-alt"></i></strong> æ¥è®©AIè¿›è¡Œå›å¤ã€‚</p>
                                <p><strong>2. é‡æ–°ç”Ÿæˆï¼š</strong></p>
                                <p>å¦‚æœä½ å¯¹AIçš„æœ€æ–°å›å¤ä¸æ»¡æ„ï¼Œå¯ä»¥ç‚¹å‡»ä½ è‡ªå·±çš„å¤´åƒï¼ŒAIä¼šæ’¤é”€åˆšæ‰çš„å›å¤å¹¶é‡æ–°ç”Ÿæˆä¸€æ¬¡ã€‚</p>
                                <p><strong>3. æŸ¥çœ‹å†…å¿ƒï¼š</strong></p>
                                <p>æƒ³çŸ¥é“å¥½å‹åœ¨æƒ³ä»€ä¹ˆå—ï¼Ÿç‚¹å‡»å¥½å‹çš„å¤´åƒï¼Œå¯ä»¥çœ‹åˆ°TAæœ€è¿‘çš„â€œå¿ƒå£°â€å’Œâ€œéšç¬”â€ã€‚</p>
                                <p><strong>4. æ›´å¤šæ“ä½œï¼š</strong></p>
                                <p>é•¿æŒ‰ä»»æ„ä¸€æ¡æ¶ˆæ¯æ°”æ³¡ï¼Œå¯ä»¥è¿›è¡Œâ€œå¼•ç”¨â€ã€â€œåˆ é™¤â€æˆ–â€œæ’¤å›â€ï¼ˆä»…è‡ªå·±å‘çš„æ¶ˆæ¯ï¼‰æ“ä½œã€‚</p>
                            `);
                            break;
                        case 'tutorial-opening-scene':
                            showTutorialModal('å¼€åœºç™½æ˜¯ä»€ä¹ˆï¼Ÿ', `
                                <p>å¼€åœºç™½æ˜¯ä¸€ä¸ª<strong>é¢„è®¾çš„å¯¹è¯åœºæ™¯</strong>ï¼Œç”¨äºå¿«é€Ÿå¼€å¯ä¸€æ®µç‰¹å®šæƒ…å¢ƒçš„å¯¹è¯ï¼Œè€Œæ— éœ€ä»é›¶å¼€å§‹å¼•å¯¼ã€‚</p>
                                <p><strong>å¦‚ä½•æ·»åŠ ä¸åº”ç”¨ï¼š</strong></p>
                                <p>1. åœ¨å¥½å‹æˆ–ç¾¤èŠçš„èŠå¤©ç•Œé¢ï¼Œç‚¹å‡»å³ä¸Šè§’çš„èœå•æŒ‰é’®(<i class="fas fa-ellipsis-v"></i> æˆ– <i class="fas fa-ellipsis-h"></i>)è¿›å…¥ç®¡ç†ç•Œé¢ã€‚</p>
                                <p>2. é€‰æ‹© <strong>å¼€åœºç™½è®¾å®š</strong>ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œæ–°å»ºã€ç¼–è¾‘æˆ–åˆ é™¤å¤šä¸ªå¼€åœºç™½æ–¹æ¡ˆã€‚</p>
                                <p>3. åœ¨å¼€åœºç™½åˆ—è¡¨ä¸­ç‚¹å‡» <strong>åº”ç”¨</strong> æŒ‰é’®åï¼Œ<strong>å½“å‰èŠå¤©è®°å½•ä¼šè¢«æ¸…ç©º</strong>ï¼Œç„¶åå¥½å‹/ç¾¤èŠä¼šæ ¹æ®ä½ è®¾å®šçš„å¼€åœºç™½å†…å®¹ï¼Œè‡ªåŠ¨å¼€å§‹ä¸€æ®µæ–°çš„å¯¹è¯ã€‚</p>
                                <p><strong>æç¤ºï¼š</strong>è¿™æ˜¯ä¸€ä¸ªéå¸¸é€‚åˆå¿«é€Ÿæµ‹è¯•è§’è‰²è®¾å®šæˆ–å¼€å¯æ–°å‰§æƒ…çš„åŠŸèƒ½ã€‚</p>
                            `);
                            break;
                        case 'tutorial-prompts':
                            showTutorialModal('æç¤ºè¯æ˜¯ä»€ä¹ˆï¼Ÿ', `
                                <p>æç¤ºè¯ï¼ˆPromptï¼‰æ˜¯ç”¨æ¥æŒ‡å¯¼AIå¦‚ä½•å›åº”çš„ç‰¹æ®ŠæŒ‡ä»¤ï¼Œèƒ½æå¤§åœ°å½±å“è§’è‰²çš„æ€§æ ¼ã€è¯´è¯é£æ ¼å’Œè¡Œä¸ºé€»è¾‘ã€‚</p>
                                <p><strong>åŠŸèƒ½ä¸ç»‘å®šï¼š</strong></p>
                                <p>ä½ å¯ä»¥åœ¨ <strong>è®¾ç½® > è‡ªå®šä¹‰æç¤ºè¯</strong> é¡µé¢åˆ›å»ºå’Œç®¡ç†æç¤ºè¯ã€‚æç¤ºè¯å¯ä»¥ç»‘å®šç»™å•ä¸ªå¥½å‹ã€ç¾¤èŠã€ç”šè‡³æœ‹å‹åœˆï¼ˆå½±å“åŠ¨æ€ç”Ÿæˆï¼‰ï¼Œè®©å¥½å‹åœ¨ä¸åŒåœºæ™¯ä¸‹éµå¾ªä¸åŒçš„è§„åˆ™ã€‚</p>
                                <p>ç‚¹å‡»<strong>èŠå¤©ç•Œé¢/æœ‹å‹åœˆç•Œé¢å³ä¸Šè§’</strong>çš„ç®¡ç†æŒ‰é’®ï¼Œé€‰æ‹©<strong>ç»‘å®šæç¤ºè¯</strong></p>
                                <p><strong>æç¤ºè¯ç±»å‹ï¼š</strong></p>
                                <p>  - <strong>æ˜¾æ€§(Explicit):</strong> è¿™ç§æç¤ºè¯<strong>æ€»æ˜¯</strong>ä¼šè¢«æ¿€æ´»ï¼Œéå¸¸é€‚åˆå®šä¹‰è§’è‰²çš„æ ¸å¿ƒæ€§æ ¼ã€ä¸–ç•Œè§‚æˆ–å¿…é¡»éµå®ˆçš„è§„åˆ™ã€‚</p>
                                <p>  - <strong>éšæ€§(Implicit):</strong> åªæœ‰å½“ä½ çš„å‘è¨€ä¸­åŒ…å«é¢„è®¾çš„<strong>å…³é”®è¯</strong>æ—¶ï¼Œè¿™ç§æç¤ºè¯æ‰ä¼šè¢«æ¿€æ´»ã€‚é€‚åˆè®¾å®šä¸€äº›ç‰¹å®šæƒ…å¢ƒä¸‹çš„ååº”ï¼Œå¦‚â€œå½“ç©å®¶æåˆ°â€˜ä¸‹é›¨â€™æ—¶ï¼Œè§’è‰²ä¼šè¡¨ç°å‡ºæ‚²ä¼¤â€ã€‚</p>
                                <p><strong>å¯¼å…¥ä¸å¯¼å‡ºï¼š</strong></p>
                                <p>åœ¨æç¤ºè¯ç®¡ç†é¡µé¢ï¼Œä½ å¯ä»¥å°†å†™å¥½çš„æç¤ºè¯æ–‡ä»¶å¤¹å¯¼å‡ºä¸º<code>.json</code>æ–‡ä»¶ï¼Œç”¨äºå¤‡ä»½æˆ–åˆ†äº«ç»™ä»–äººã€‚åŒæ ·ï¼Œä¹Ÿå¯ä»¥å¯¼å…¥ä»–äººåˆ†äº«çš„æç¤ºè¯æ–‡ä»¶ã€‚</p>
                                <p><strong>æ³¨æ„ï¼ˆTokenæ¶ˆè€—ï¼‰ï¼š</strong></p>
                                <p>æç¤ºè¯å†…å®¹è¶Šé•¿ã€ç»‘å®šçš„æç¤ºè¯è¶Šå¤šï¼Œæ¯æ¬¡ä¸å¥½å‹äº¤äº’æ—¶æ¶ˆè€—çš„Tokenå°±è¶Šå¤šï¼Œå¹¶é™ä½å“åº”é€Ÿåº¦ã€‚è¯·æ ¹æ®éœ€è¦è‡ªè¡Œå–èˆã€‚</p>
                            `);
                            break;
                        case 'tutorial-import-export':
                             showTutorialModal('å¦‚ä½•å¯¼å…¥å¯¼å‡º', `
                                <p>ä½ å¯ä»¥æ–¹ä¾¿åœ°åˆ†äº«æˆ–å¤‡ä»½ä½ çš„è§’è‰²ä¸ç¾¤èŠæ•°æ®ã€‚</p>
                                <p><strong>å¯¼å‡ºï¼š</strong></p>
                                <p>1. åœ¨é€šè®¯å½•ç‚¹å‡»å¥½å‹æˆ–ç¾¤èŠçš„è¯¦æƒ…æŒ‰é’®ï¼Œæˆ–åœ¨èŠå¤©é¡µé¢ç‚¹å‡»å³ä¸Šè§’èœå•è¿›å…¥ç®¡ç†é¡µé¢ã€‚</p>
                                <p>2. ç‚¹å‡»â€œå¯¼å‡ºè§’è‰²/ç¾¤èŠâ€æŒ‰é’®ï¼Œä¼šç”Ÿæˆä¸€ä¸ª <code>.json</code> æ ¼å¼çš„é…ç½®æ–‡ä»¶ï¼Œä¿å­˜åˆ°æœ¬åœ°å³å¯ã€‚</p>
                                <p><strong>å¯¼å…¥ï¼š</strong></p>
                                <p>1. åœ¨é€šè®¯å½•é¡µé¢ï¼Œç‚¹å‡»å³ä¸Šè§’ <strong>+</strong> å·ï¼Œé€‰æ‹© <strong>å¯¼å…¥è§’è‰²/ç¾¤èŠ</strong>ã€‚</p>
                                <p>2. é€‰æ‹©ä½ ä¹‹å‰å¯¼å‡ºçš„ <code>.json</code> æ–‡ä»¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«å¹¶å¯¼å…¥ã€‚</p>
                                <p>å¯¼å…¥å‰ç¡®ä¿å¯¼å…¥çš„æ–‡ä»¶æ˜¯æ”¯æŒè¿™ä¸ªèŠå¤©å®¤ä½¿ç”¨çš„ã€‚</p>
                                <p><strong>æç¤ºï¼š</strong>å¦‚æœå¯¼å…¥çš„è§’è‰²åä¸ç°æœ‰è§’è‰²å†²çªï¼Œç³»ç»Ÿä¼šæç¤ºä½ é€‰æ‹©â€œæ›´æ–°â€æˆ–â€œè¦†ç›–â€ã€‚</p>
                            `);
                            break;
                        case 'tutorial-moments':
                            showTutorialModal('æœ‹å‹åœˆå¦‚ä½•ä½¿ç”¨', `
                                <p>æœ‹å‹åœˆæ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿç¤¾äº¤åŠ¨æ€çš„è¶£å‘³åŠŸèƒ½ã€‚</p>
                                <p>1. è¿›å…¥ <strong>å‘ç° > æœ‹å‹åœˆ</strong>ã€‚é¦–æ¬¡è¿›å…¥éœ€è¦ç‚¹å‡»å³ä¸Šè§’èœå•æŒ‰é’®ï¼Œå…ˆåˆ›å»ºä¸€ä¸ªâ€œåœˆå­â€ã€‚</p>
                                <p>2. ç‚¹å‡»å³ä¸Šè§’èœå•æŒ‰é’®å¯ä»¥ <strong>ç®¡ç†åœˆå­</strong>ï¼ˆå¢åˆ æ”¹æŸ¥ã€åˆ‡æ¢ï¼‰ã€‚</p>
                                <p>3. ç‚¹å‡»ç›¸æœºå›¾æ ‡å¯ä»¥ <strong>å‘å¸ƒä½ è‡ªå·±çš„åŠ¨æ€</strong>ã€‚</p>
                                <p>4. ç‚¹å‡»åˆ·æ–°æŒ‰é’®ï¼Œå¥½å‹ä¼šæ ¹æ®å·²æœ‰è®¾å®šï¼Œ<strong>è‡ªåŠ¨ç”Ÿæˆæ–°çš„æœ‹å‹åœˆåŠ¨æ€</strong>ã€‚</p>
                                <p>5. ä½ å¯ä»¥åƒçœŸå®ç¤¾äº¤è½¯ä»¶ä¸€æ ·ï¼Œå¯¹åŠ¨æ€è¿›è¡Œç‚¹èµã€è¯„è®ºå’Œè½¬å‘ã€‚</p>
                            `);
                            break;
                        case 'tutorial-theme':
                            showTutorialModal('å¦‚ä½•è®¾ç½®ä¸»é¢˜', `
                                <p>ä½ å¯ä»¥é«˜åº¦è‡ªå®šä¹‰åº”ç”¨çš„å¤–è§‚ã€‚</p>
                                <p>1. è¿›å…¥ <strong>è®¾ç½® > ä¸»é¢˜è®¾ç½®</strong>ã€‚</p>
                                <p>2. åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥æ›´æ”¹<strong>å¼¹çª—é£æ ¼</strong>ã€<strong>èŠå¤©æ°”æ³¡æ ·å¼</strong>ã€<strong>å­—ä½“å¤§å°</strong>å’Œ<strong>é¢œè‰²</strong>ã€‚</p>
                                <p>3. ç‚¹å‡» <strong>é€šç”¨è®¾ç½® > èƒŒæ™¯ä¸å°é¢</strong>ï¼Œå¯ä»¥ä¸Šä¼ ä½ å–œæ¬¢çš„å›¾ç‰‡ä½œä¸ºå…¨å±€é¡µé¢èƒŒæ™¯ã€å…¨å±€èŠå¤©èƒŒæ™¯ï¼Œå¥½å‹/ç¾¤èŠèŠå¤©ç•Œé¢å³ä¸Šè§’å¯è®¾ç½®ä¸“å±èŠå¤©èƒŒæ™¯ã€‚æ”¯æŒè‡ªå®šä¹‰çº¢åŒ…å’Œè½¬è´¦çš„å°é¢å›¾ã€‚</p>
                                <p>4. <strong>å­—ä½“è®¾ç½®</strong>ä½ å¯ä»¥åŠ è½½å¯å…è´¹ä½¿ç”¨çš„æˆ–å·²è´­ä¹°çš„æœ¬åœ°å­—ä½“æ–‡ä»¶/ç½‘ç»œå­—ä½“èµ„æº</p>
                            `);
                            break;
                    }
                });
                
                
                chatBackBtn.addEventListener('click', async () => {
                    const chatId = appState.currentChatId;
                    if (chatId) {
                        const chatData = await DBHelper.get('chats', chatId);
                        if (chatData && chatData.history) {
                            let madeChanges = false;
                            chatData.history.forEach(msg => {
                                if (msg.isUnread) {
                                    msg.isUnread = false;
                                    madeChanges = true;
                                }
                            });
                            if (madeChanges) {
                                await DBHelper.put('chats', chatData);
                            }
                        }
                    }
                    this.resetQuoteState();
                    UIManager.navigateTo('messages');
                });
                $('#chat-manage-btn').addEventListener('click', () => {
                    const chatId = appState.currentChatId;
                    if (!chatId) return;
                    if (chatId.startsWith('group-')) this.handleOpenGroupManagementSidebar(chatId);
                    else this.handleOpenFriendManagementSidebar(chatId);
                });
                 sendBtn.addEventListener('click', () => this.handlePlayerSendMessage());
                messageInput.addEventListener('keypress', async (e) => {
                    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                    if (chatSettings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handlePlayerSendMessage();
                    }
                });
                aiRequestBtn.addEventListener('click', () => {
                    if (AIHandler.isAwaitingResponse) AIHandler.cancelAiRequest();
                    else AIHandler.handleAiReplyRequest();
                });
                messageInput.addEventListener('input', () => {
                    messageInput.style.height = 'auto';
                    messageInput.style.height = (messageInput.scrollHeight) + 'px';
                });

                
                appContainer.addEventListener('click', (e) => this.handleClickEffect(e));
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay && !modalOverlay.classList.contains('no-overlay-close')) UIManager.hideModal();
                });
                $('#sidebar-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#sidebar-overlay')) UIManager.hideSidebar();
                });

                $('#bottom-sheet-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#bottom-sheet-overlay')) UIManager.hideBottomSheet();
                });

                
                emojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    favoriteEmojiCard.classList.remove('active'); // å…³é—­å¦ä¸€ä¸ª
                    emojiCard.classList.toggle('active');
                });

                favoriteEmojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    emojiCard.classList.remove('active'); // å…³é—­å¦ä¸€ä¸ª
                    favoriteEmojiCard.classList.toggle('active');
                    if (favoriteEmojiCard.classList.contains('active')) {
                        this.renderFavoriteEmojiPage();
                    }
                });

                $('#simulated-image-btn').addEventListener('click', () => this.handleSimulatedImageSend());
                voiceBtn.addEventListener('click', () => this.handleVoiceInput());
                $('#transfer-btn').addEventListener('click', () => this.handlePlayerTransfer());
                $('#red-packet-btn').addEventListener('click', () => this.handlePlayerRedPacket());
                document.addEventListener('click', (e) => {
                    if (!chatInputArea.contains(e.target)) {
                        emojiCard.classList.remove('active');
                        favoriteEmojiCard.classList.remove('active');
                    }
                });
                $('#emoji-prev-btn').addEventListener('click', () => { appState.emojiCurrentPage--; this.renderEmojiPage(); });
                $('#emoji-next-btn').addEventListener('click', () => { appState.emojiCurrentPage++; this.renderEmojiPage(); });
                $('#favorite-emoji-prev-btn').addEventListener('click', () => { appState.favoriteEmojiCurrentPage--; this.renderFavoriteEmojiPage(); });
                $('#favorite-emoji-next-btn').addEventListener('click', () => { appState.favoriteEmojiCurrentPage++; this.renderFavoriteEmojiPage(); });
                
                chatArea.addEventListener('mousedown', (e) => this.handleInteractionStart(e, 'mouse'));
                chatArea.addEventListener('touchstart', (e) => this.handleInteractionStart(e, 'touch'));
                cancelQuoteBtn.addEventListener('click', () => this.resetQuoteState());

                chatArea.addEventListener('click', async (e) => {
                    const messageRow = e.target.closest('.message-row');
                    if (!messageRow) return;
                    const messageId = messageRow.dataset.messageId;
                    const voiceBubble = e.target.closest('.voice-message-bubble');
                    if (voiceBubble) {
                        const wrapper = voiceBubble.closest('.bubble-and-tag-wrapper');
                        const transcript = wrapper.querySelector('.voice-transcript');
                        if (transcript) transcript.classList.toggle('show');
                        return;
                    }
                    const cardWrapper = e.target.closest('.card-message-wrapper');
                    if (cardWrapper) {
                        const cardId = cardWrapper.dataset.cardId;
                        if (!cardId) return;
                        const detailElement = document.getElementById(cardId);
                        if (detailElement) detailElement.classList.toggle('visible');
                        return;
                    }
                    const specialBubble = e.target.closest('.transfer-or-red-packet-bubble');
                    if (specialBubble) {
                        const chatData = await DBHelper.get('chats', appState.currentChatId);
                        const msg = chatData.history.find(m => m.messageId === messageId);
                        if (!msg) return;
                        if (msg.segmentType === 'transfer' && !msg.cardData.isClaimed) {
                            this.handleTransferClick(msg);
                        } else if (msg.segmentType === 'red-packet' && !msg.cardData.isClaimedByPlayer) {
                            this.handleRedPacketClick(msg);
                        }
                        return; 
                    }

                    
                    const forwardedMomentCard = e.target.closest('.forwarded-moment-card-content');
                    if (forwardedMomentCard) {
                        const momentId = forwardedMomentCard.dataset.momentId;
                        if (momentId) {
                            this.showForwardedMomentDetail(momentId);
                        }
                        return; 
                    }
                });
                chatArea.addEventListener('scroll', () => {
                    if (chatArea.scrollTop < 50 && !appState.isHistoryLoading) {
                        UIManager.loadMoreMessages();
                    }
                });

                const momentsBg = $('#moments-bg');
                const momentsBgInput = $('#moments-bg-input');

                momentsBg.addEventListener('click', () => {
                    momentsBgInput.click();
                });

                momentsBgInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file || !appState.currentCircleId) return;

                    try {
                        const compressedImage = await Utils.compressImage(file, 1000, 1000, 0.8);
                        const circle = await DBHelper.get('circles', appState.currentCircleId);
                        if (circle) {
                            circle.backgroundImage = compressedImage;
                            await DBHelper.put('circles', circle);
                            momentsBg.src = compressedImage;
                            UIManager.showToast('èƒŒæ™¯å·²æ›´æ¢ï¼');
                        }
                    } catch (error) {
                        console.error("æ›´æ¢èƒŒæ™¯å¤±è´¥ï¼š", error);
                        UIManager.showToast('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                });
            },

        async handlePlayerSendMessage(prebuiltMessage = null) {
            const content = messageInput.value.trim();
            if (!prebuiltMessage && (!content || !appState.currentChatId)) return;

            let message;
            const profile = await DBHelper.get('profile', 'myProfile');
            const chatData = await DBHelper.get('chats', appState.currentChatId) || { chatId: appState.currentChatId, history: [] };
            const lastMessage = chatData.history.length > 0 ? chatData.history[chatData.history.length - 1] : null;

            const now = Date.now();

            
            if (lastMessage && (now - lastMessage.timestamp > 5 * 60 * 1000)) {
                
                const timeDivider = UIManager.createTimeDividerElement(now);
                chatArea.appendChild(timeDivider);
            }

            if (prebuiltMessage) {
                message = prebuiltMessage;
                message.timestamp = now; 
            } else if (appState.quotingMessage) {
                
                const quotedMsg = appState.quotingMessage;
                const contact = await DBHelper.get('contacts', quotedMsg.senderId);
                const senderName = contact ? (contact.remark || contact.name) : 'å¯¹æ–¹';

                let quotedContentText;
                if (quotedMsg.segmentType === 'text') quotedContentText = quotedMsg.content;
                else if (quotedMsg.segmentType === 'voice') quotedContentText = '[è¯­éŸ³]';
                else if (quotedMsg.segmentType === 'emoji-image') quotedContentText = '[è¡¨æƒ…åŒ…]';
                else quotedContentText = '[æ¶ˆæ¯]';

                message = {
                    messageId: Utils.generateId('msg'),
                    content: `[å¼•ç”¨] ${content}`,
                    timestamp: now,
                    type: 'sent',
                    segmentType: 'quote',
                    cardData: {
                        quotedName: senderName,
                        quotedContent: quotedContentText,
                        newContent: content
                    }
                };
                this.resetQuoteState();
            } else {
                
                message = {
                    messageId: Utils.generateId('msg'),
                    content,
                    timestamp: now,
                    type: 'sent',
                    isRetracted: false,
                    isUnread: false,
                    segmentType: 'text',
                };
            }
            
            chatData.history.push(message);
            await DBHelper.put('chats', chatData);
            
            
            chatData.turnCountSinceLastPrompt = (chatData.turnCountSinceLastPrompt || 0) + 1;
            await DBHelper.put('chats', chatData);
            
            UIManager.addMessageToDOM(message, profile, false, true);
            
            
            if (!prebuiltMessage) {
                messageInput.value = '';
                messageInput.style.height = 'auto';
                messageInput.focus();
            }
        },
            
            
            
            renderEmojiPage() {
                const emojiEntries = Object.entries(appState.playerEmojiMap);
                const pageCount = Math.ceil(emojiEntries.length / appState.emojisPerPage);

                if (appState.emojiCurrentPage < 0) appState.emojiCurrentPage = pageCount - 1;
                if (appState.emojiCurrentPage >= pageCount) appState.emojiCurrentPage = 0;
                
                const pageIndex = appState.emojiCurrentPage;
                const start = pageIndex * appState.emojisPerPage;
                const end = start + appState.emojisPerPage;
                const pageEmojis = emojiEntries.slice(start, end);

                emojiGrid.innerHTML = '';
                pageEmojis.forEach(([id, desc]) => {
                    const item = document.createElement('div');
                    item.className = 'emoji-item';
                    item.dataset.emojiId = id;
                    item.title = desc;
                    
                    const isFavorite = appState.favoriteEmojis.includes(id);

                    item.innerHTML = `
                        <img src="https://z.wiki/u/${id}" alt="${desc}">
                        <div class="favorite-emoji-toggle ${isFavorite ? 'is-favorite' : ''}" title="æ”¶è—">
                            <i class="fas fa-star"></i>
                        </div>
                    `;
                    
                    const imgEl = item.querySelector('img');
                    imgEl.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const profile = await DBHelper.get('profile', 'myProfile');
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: id,
                            timestamp: Date.now(),
                            type: 'sent',
                            segmentType: 'emoji-image',
                        };
                        const chatData = await DBHelper.get('chats', appState.currentChatId) || { chatId: appState.currentChatId, history: [] };
                        chatData.history.push(message);
                        await DBHelper.put('chats', chatData);
                        UIManager.addMessageToDOM(message, profile, false, true);
                        emojiCard.classList.remove('active');
                    });

                    const favToggle = item.querySelector('.favorite-emoji-toggle');
                    favToggle.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const emojiId = item.dataset.emojiId;
                        const index = appState.favoriteEmojis.indexOf(emojiId);
                        
                        if (index > -1) {
                            appState.favoriteEmojis.splice(index, 1);
                            favToggle.classList.remove('is-favorite');
                        } else {
                            appState.favoriteEmojis.push(emojiId);
                            favToggle.classList.add('is-favorite');
                        }
                        
                        const profile = await DBHelper.get('profile', 'myProfile');
                        profile.favoriteEmojis = appState.favoriteEmojis;
                        await DBHelper.put('profile', profile);
                    });
                    
                    emojiGrid.appendChild(item);
                });
                
                $('#emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
            },

            renderFavoriteEmojiPage() {
                favoriteEmojiGrid.innerHTML = '';
                const favNav = $('#favorite-emoji-card .emoji-nav');

                if (appState.favoriteEmojis.length === 0) {
                    favoriteEmojiGrid.innerHTML = `<p style="text-align:center; color: #aaa; padding: 20px 0; grid-column: 1 / -1;">è¿˜æ²¡æœ‰æ”¶è—çš„è¡¨æƒ…å“¦</p>`;
                    if (favNav) favNav.style.display = 'none';
                    return;
                }

                if (favNav) favNav.style.display = 'flex';

                const pageCount = Math.ceil(appState.favoriteEmojis.length / appState.emojisPerPage);

                if (appState.favoriteEmojiCurrentPage < 0) appState.favoriteEmojiCurrentPage = pageCount - 1;
                if (appState.favoriteEmojiCurrentPage >= pageCount) appState.favoriteEmojiCurrentPage = 0;
                
                const pageIndex = appState.favoriteEmojiCurrentPage;
                const start = pageIndex * appState.emojisPerPage;
                const end = start + appState.emojisPerPage;
                const pageEmojis = appState.favoriteEmojis.slice(start, end);

                pageEmojis.forEach(id => {
                    const desc = appState.playerEmojiMap[id] || 'å·²æ”¶è—è¡¨æƒ…';
                    const item = document.createElement('div');
                    item.className = 'emoji-item';
                    item.dataset.emojiId = id;
                    item.title = desc;

                    item.innerHTML = `<img src="https://z.wiki/u/${id}" alt="${desc}" style="width: 60px; height: 60px;">`;
                    
                    let longPressTimer;
                    let isLongPress = false;

                    const handleUnfavorite = async () => {
                        const index = appState.favoriteEmojis.indexOf(id);
                        if (index > -1) {
                            appState.favoriteEmojis.splice(index, 1);
                            const profile = await DBHelper.get('profile', 'myProfile');
                            profile.favoriteEmojis = appState.favoriteEmojis;
                            await DBHelper.put('profile', profile);
                            
                            const newPageCount = Math.ceil(appState.favoriteEmojis.length / appState.emojisPerPage);
                            if(appState.favoriteEmojiCurrentPage >= newPageCount && newPageCount > 0){
                                appState.favoriteEmojiCurrentPage = newPageCount - 1;
                            }

                            this.renderFavoriteEmojiPage();
                            UIManager.showToast("å·²å–æ¶ˆæ”¶è—");
                        }
                        UIManager.hideModal();
                    };

                    const startLongPress = (e) => {
                        isLongPress = false;
                        longPressTimer = setTimeout(() => {
                            isLongPress = true;
                            UIManager.showModal({
                                title: "å–æ¶ˆæ”¶è—",
                                body: `<p>è¦å°†è¿™ä¸ªè¡¨æƒ…ç§»å‡ºæ”¶è—å—ï¼Ÿ</p>`,
                                actions: [
                                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: 'ç¡®å®š', class: 'btn-danger', handler: handleUnfavorite }
                                ]
                            });
                        }, 500);
                    };

                    const cancelLongPress = () => {
                        clearTimeout(longPressTimer);
                    };

                    const handleClick = async (e) => {
                        if (isLongPress) {
                            return;
                        }
                        const profile = await DBHelper.get('profile', 'myProfile');
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: id,
                            timestamp: Date.now(),
                            type: 'sent',
                            segmentType: 'emoji-image',
                        };
                        const chatData = await DBHelper.get('chats', appState.currentChatId) || { chatId: appState.currentChatId, history: [] };
                        chatData.history.push(message);
                        await DBHelper.put('chats', chatData);
                        UIManager.addMessageToDOM(message, profile, false, true);
                        favoriteEmojiCard.classList.remove('active');
                    };

                    item.addEventListener('mousedown', startLongPress);
                    item.addEventListener('touchstart', startLongPress, { passive: true });
                    item.addEventListener('mouseup', cancelLongPress);
                    item.addEventListener('mouseleave', cancelLongPress);
                    item.addEventListener('touchend', cancelLongPress);
                    item.addEventListener('touchcancel', cancelLongPress);
                    item.addEventListener('click', handleClick);

                    favoriteEmojiGrid.appendChild(item);
                });

                if (pageCount > 0) {
                    $('#favorite-emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
                } else {
                     $('#favorite-emoji-page-indicator').textContent = `1 / 1`;
                }
            },

        async initEmojiPanel() {
            this.renderEmojiPage(); 
        },

        handleVoiceInput() {
            UIManager.showModal({
                isPersistent: true, 
                customClass: 'modal-neumorphic',
                title: "å‘é€è¯­éŸ³",
                body: `
                    <div class="form-group">
                        <label for="modal-voice-text-input">è¯­éŸ³å†…å®¹ (æ–‡æœ¬)</label>
                        <textarea id="modal-voice-text-input" rows="4" placeholder="è¾“å…¥è¯­éŸ³æ¶ˆæ¯å†…å®¹..."></textarea>
                    </div>
                `,
                actions: [
                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                        const text = $('#modal-voice-text-input').value.trim();
                        if (!text) return;

                        let duration = Math.max(1, Math.ceil(text.length / 4));
                        duration = Math.min(duration, 60); 

                        const profile = await DBHelper.get('profile', 'myProfile');
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: `[è¯­éŸ³] ${text}`,
                            timestamp: Date.now(),
                            type: 'sent',
                            segmentType: 'voice',
                            cardData: {
                                duration: `${duration}s`,
                                content: text
                            }
                        };
                        
                        await this.handlePlayerSendMessage(message);
                        UIManager.hideModal();
                    }}
                ]
            });
            setTimeout(() => $('#modal-voice-text-input').focus(), 100);
        },           

            async handlePlayerTransfer() {
                const isGroup = appState.currentChatId.startsWith('group-');
                let recipientHtml;
                let recipientName; 

                if (isGroup) {
                    
                    recipientHtml = `
                        <div class="form-group">
                            <label>è½¬è´¦ç»™</label>
                            <div id="transfer-recipient-display" class="form-group" style="padding: 12px 15px; cursor: pointer; background: #F0F0F3; border-radius: 12px; box-shadow: inset -5px -5px 9px rgba(255,255,255,0.7), inset 5px 5px 9px rgba(174,174,192,0.2);">
                                <span style="color: #888;">è¯·é€‰æ‹©æ”¶æ¬¾äºº</span>
                            </div>
                        </div>
                    `;
                } else {
                    
                    const contact = await DBHelper.get('contacts', appState.currentChatId);
                    recipientName = contact.name;
                }
                
                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "è½¬è´¦",
                    body: `
                        ${isGroup ? recipientHtml : ''}
                        <div class="form-group">
                            <label for="modal-transfer-amount">è½¬è´¦é‡‘é¢</label>
                            <input type="number" id="modal-transfer-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-transfer-note">å¤‡æ³¨ (é€‰å¡«)</label>
                            <input type="text" id="modal-transfer-note" placeholder="è½¬è´¦è¯´æ˜">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'è½¬è´¦', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-transfer-amount').value);
                            const note = $('#modal-transfer-note').value.trim();

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
                            }
                            if (isGroup && !recipientName) { 
                                return UIManager.showToast('è¯·é€‰æ‹©æ”¶æ¬¾äºº');
                            }

                            const formattedAmount = `ï¿¥${amount.toFixed(2)}`;
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[è½¬è´¦] ${formattedAmount}`,
                                type: 'sent',
                                segmentType: 'transfer',
                                cardData: {
                                    recipientName: recipientName,
                                    amount: formattedAmount,
                                    note: note,
                                    isClaimed: false
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                
                if(isGroup) {
                    const displayDiv = $('#transfer-recipient-display');
                    displayDiv.addEventListener('click', async () => {
                         const group = await DBHelper.get('groups', appState.currentChatId);
                         const contacts = await DBHelper.getAll('contacts');
                         const members = group.members
                            .map(id => contacts.find(c => c.id === id))
                            .filter(Boolean);

                        if (members.length === 0) return;
                        
                        UIManager.showBottomSheet({
                            title: 'é€‰æ‹©æ”¶æ¬¾äºº',
                            customClass: 'compact-list', 
                            items: members.map(m => ({ value: m.name, text: m.remark || m.name })),
                            onSelect: (value, text) => {
                                recipientName = value; 
                                displayDiv.querySelector('span').textContent = text; 
                                displayDiv.querySelector('span').style.color = 'var(--text-color-dark)';
                            }
                        });
                    });
                }
            },

            async handlePlayerRedPacket() {
                const isGroup = appState.currentChatId.startsWith('group-');
                const groupOnlyHtml = isGroup ? `
                    <div class="form-group">
                        <label for="modal-rp-count">çº¢åŒ…ä¸ªæ•°</label>
                        <input type="number" id="modal-rp-count" value="1" min="1" step="1">
                    </div>
                ` : '';

                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "å‘çº¢åŒ…",
                    body: `
                        <div class="form-group">
                            <label for="modal-rp-amount">æ€»é‡‘é¢</label>
                            <input type="number" id="modal-rp-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-rp-title">çº¢åŒ…ç¥ç¦è¯­ (é€‰å¡«)</label>
                            <input type="text" id="modal-rp-title" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©">
                        </div>
                        ${groupOnlyHtml}
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å¡é’±è¿›çº¢åŒ…', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-rp-amount').value);
                            const title = $('#modal-rp-title').value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
                            const count = isGroup ? parseInt($('#modal-rp-count').value, 10) : 1;

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
                            }
                            if (isGroup && (isNaN(count) || count <= 0)) {
                                return UIManager.showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ä¸ªæ•°');
                            }
                            if (isGroup && amount < count * 0.01) {
                                return UIManager.showToast('å•ä¸ªçº¢åŒ…é‡‘é¢ä¸èƒ½å°‘äº0.01å…ƒ');
                            }

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[çº¢åŒ…] ${title}`,
                                type: 'sent',
                                segmentType: 'red-packet',
                                cardData: {
                                    title: title,
                                    amount: amount,
                                    count: count,
                                    isClaimedByPlayer: false, 
                                    claimedBy: []
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
            },
           
            
            
            handleInteractionStart(e, type) {
                const bubble = e.target.closest('.bubble');
                if (!bubble) return;

                const messageRow = bubble.closest('.message-row');
                if (!messageRow || !messageRow.dataset.messageId) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) {
                        existingButton.remove();
                    }
                    
                    if (messageRow.classList.contains('received')) {
                        this.showMessageOptions(messageRow, 'received');
                    } else if (messageRow.classList.contains('sent')) {
                        this.showMessageOptions(messageRow, 'sent');
                    }
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            async startQuote(messageRowElement) {
                const messageId = messageRowElement.dataset.messageId;
                const chatData = await DBHelper.get('chats', appState.currentChatId);
                const messageData = chatData.history.find(m => m.messageId === messageId);
                if (!messageData || messageData.isRetracted) return;

                appState.quotingMessage = messageData;
                const contact = await DBHelper.get('contacts', messageData.senderId);
                const senderName = contact ? (contact.remark || contact.name) : 'å¯¹æ–¹';

                let quotedContentText;
                if (messageData.segmentType === 'text') {
                    quotedContentText = messageData.content;
                } else if (messageData.segmentType === 'voice') {
                    quotedContentText = '[è¯­éŸ³]';
                } else if (messageData.segmentType === 'emoji-image') {
                    quotedContentText = '[è¡¨æƒ…åŒ…]';
                } else {
                    return; 
                }
                
                quotePreviewContent.textContent = `${senderName}: ${quotedContentText}`;
                quotePreviewArea.style.display = 'flex';
                messageInput.focus();
            },

            resetQuoteState() {
                appState.quotingMessage = null;
                quotePreviewArea.style.display = 'none';
            },

            async showMessageOptions(messageRowElement, messageType) {
                const messageId = messageRowElement.dataset.messageId;
                if (!messageId) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';

                let buttonsHtml = '';
                if (messageType === 'sent') {
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> åˆ é™¤</button>
                        <button class="retract-btn" data-action="retract"><i class="fas fa-undo"></i> æ’¤å›</button>
                    `;
                } else { 
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> åˆ é™¤</button>
                        <button class="retract-btn" data-action="quote"><i class="fas fa-quote-left"></i> å¼•ç”¨</button>
                    `;
                }
                wrapper.innerHTML = buttonsHtml;
                
                
                wrapper.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;

                    if (action === 'delete') {
                        const chatData = await DBHelper.get('chats', appState.currentChatId);
                        chatData.history = chatData.history.filter(m => m.messageId !== messageId);
                        await DBHelper.put('chats', chatData);
                        
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) {
                            originalRow.remove();
                        }
                        wrapper.remove(); 
                    } else if (action === 'retract') {
                        const chatData = await DBHelper.get('chats', appState.currentChatId);
                        const msgIndex = chatData.history.findIndex(m => m.messageId === messageId);
                        if (msgIndex === -1) return;

                        const msgToRetract = chatData.history[msgIndex];
                        msgToRetract.isRetracted = true;
                        await DBHelper.put('chats', chatData);

                        const myProfile = await DBHelper.get('profile', 'myProfile');
                        const retractionNotice = UIManager.createRetractionNotice(msgToRetract, myProfile);
                        
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) {
                            originalRow.replaceWith(retractionNotice);
                        }
                        wrapper.remove();
                    } else if (action === 'quote') {
                        this.startQuote(messageRowElement);
                        wrapper.remove();
                    }
                });

                const bubbleWrapper = messageRowElement.querySelector('.bubble-and-tag-wrapper');
                if (bubbleWrapper) {
                    bubbleWrapper.appendChild(wrapper);
                    setTimeout(() => wrapper.classList.add('show'), 10);
                }

                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async handleEditProfile() {
                const profile = await DBHelper.get('profile', 'myProfile');
                UIManager.showSidebar({
                    position: 'left', 
                    title: "æˆ‘çš„ä¿¡æ¯",
                    body: `
                        <div class="form-group">
                            <label>å¤´åƒ</label>
                            <div class="avatar-uploader">
                                <img src="${profile.avatar}" id="profile-avatar-preview" class="avatar-preview">
                                <input type="file" id="profile-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('profile-avatar-input').click()">ä¸Šä¼ æ–°å¤´åƒ</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="profile-name-input">å§“å</label>
                            <input type="text" id="profile-name-input" value="${profile.name}">
                        </div>
                        <div class="form-group">
                            <label for="profile-gender-select">æ€§åˆ«</label>
                            <select id="profile-gender-select">
                                <option value="ç”·" ${profile.gender === 'ç”·' ? 'selected' : ''}>ç”·</option>
                                <option value="å¥³" ${profile.gender === 'å¥³' ? 'selected' : ''}>å¥³</option>
                                <option value="å…¶ä»–" ${profile.gender === 'å…¶ä»–' ? 'selected' : ''}>å…¶ä»–</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="profile-background-input">èƒŒæ™¯èµ„æ–™ (é€‰å¡«)</label>
                            <textarea id="profile-background-input">${profile.background || ''}</textarea>
                        </div>
                        <p style="text-align: center; font-size: 12px; color: #aaa; user-select: none; margin-top: 30px;">æ­¤èŠå¤©å®¤ç”±33åˆ¶ä½œï¼Œxhs:@å›é£</p>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideSidebar() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const newAvatar = $('#profile-avatar-preview').src;
                            const newName = $('#profile-name-input').value.trim();
                            if (!newName) { 
                                UIManager.showModal({ title:"æç¤º", body:"<p>å§“åä¸èƒ½ä¸ºç©ºï¼</p>", actions:[{text:"å¥½çš„", class:"btn-primary", handler:()=>UIManager.hideModal()}]});
                                return; 
                            }
                            
                            const updatedProfile = {
                                ...profile,
                                avatar: newAvatar,
                                name: newName,
                                gender: $('#profile-gender-select').value,
                                background: $('#profile-background-input').value.trim()
                            };
                            
                            await DBHelper.put('profile', updatedProfile);
                            $('#my-avatar').src = newAvatar;
                            UIManager.hideSidebar();
                        }}
                    ]
                });
                
                
                $('#profile-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const base64 = await Utils.fileToBase64(file);
                        $('#profile-avatar-preview').src = base64;
                    }
                });
            },
            
            showAddMenu() {
                UIManager.showModal({
                    title: "æ–°å»º/å¯¼å…¥",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0;">
                            <div class="setting-item" id="add-friend-menu">
                                <i class="fas fa-user-plus"></i>
                                <span>æ·»åŠ æ–°å¥½å‹</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="create-group-menu">
                                <i class="fas fa-users"></i>
                                <span>æ–°å»ºç¾¤èŠ</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="import-data-menu">
                                <i class="fas fa-file-import"></i>
                                <span>å¯¼å…¥è§’è‰²/ç¾¤èŠ</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>`,
                    actions: [] 
                });
                
                $('#add-friend-menu').addEventListener('click', () => this.handleAddFriend());
                $('#create-group-menu').addEventListener('click', () => this.handleCreateGroup());
                $('#import-data-menu').addEventListener('click', () => this.handleImportData());
            },
            
            handleAddFriend() {
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());
                UIManager.showModal({
                    isPersistent: true, 
                    title: "æ·»åŠ æ–°å¥½å‹",
                    body: `
                        <div class="form-group">
                            <label>å¤´åƒ</label>
                            <div class="avatar-uploader">
                                <img src="${defaultAvatar}" id="add-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="add-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('add-friend-avatar-input').click()">ä¸Šä¼ å¤´åƒ</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-name">å§“å (å”¯ä¸€ID, å¿…å¡«)</label>
                            <input type="text" id="add-friend-name" placeholder="ä¸ºAIå¥½å‹èµ·ä¸ªåå­—">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-remark">å¤‡æ³¨ (é€‰å¡«)</label>
                            <input type="text" id="add-friend-remark" placeholder="ä½ å¯¹TAçš„ç§°å‘¼">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-gender">æ€§åˆ« (å¿…å¡«)</label>
                            <select id="add-friend-gender">
                                <option value="ç”·">ç”·</option>
                                <option value="å¥³">å¥³</option>
                                <option value="å…¶ä»–">å…¶ä»–</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-likes">å–œå¥½ (é€‰å¡«)</label>
                            <textarea id="add-friend-likes" placeholder="ä¾‹å¦‚ï¼šç”œé£Ÿã€è¿åŠ¨ã€æ—…æ¸¸"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-dislikes">åŒæ¶ (é€‰å¡«)</label>
                            <textarea id="add-friend-dislikes" placeholder="ä¾‹å¦‚ï¼šè¢«å¿½è§†ã€ä¸‹é›¨"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-habits">ä¹ æƒ¯ (é€‰å¡«)</label>
                            <textarea id="add-friend-habits" placeholder="ä¾‹å¦‚ï¼šæ™¨è·‘ã€è¿åŠ¨"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-background">èƒŒæ™¯èµ„æ–™ (é€‰å¡«)</label>
                            <textarea id="add-friend-background" placeholder="è§’è‰²çš„å…¶ä»–èµ„æ–™"></textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal(); 
                            this.showAddMenu(); 
                        }},
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: async () => {
                            const name = $('#add-friend-name').value.trim();
                            if (!name) { 
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "æç¤º",
                                    body: `<p>å¥½å‹çš„å§“åä¸èƒ½ä¸ºç©ºå“¦ã€‚</p>`,
                                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return; 
                            }
                            
                            
                            const existing = await DBHelper.getAll('contacts', 'name');
                            if (existing.some(c => c.name === name)) {
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "æç¤º",
                                    body: `<p>å§“å "${name}" å·²ç»è¢«å…¶ä»–å¥½å‹å ç”¨äº†ï¼Œæ¢ä¸€ä¸ªå§ã€‚</p>`,
                                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const newContact = {
                                id: Utils.generateId('contact'),
                                createdAt: Date.now(),
                                name,
                                avatar: $('#add-friend-avatar-preview').src,
                                remark: $('#add-friend-remark').value.trim(),
                                gender: $('#add-friend-gender').value,
                                likes: $('#add-friend-likes').value.trim(),
                                dislikes: $('#add-friend-dislikes').value.trim(),
                                habits: $('#add-friend-habits').value.trim(),
                                background: $('#add-friend-background').value.trim()
                            };
                            
                            await DBHelper.put('contacts', newContact);
                            UIManager.hideModal();
                            await UIManager.renderContactsPage();
                        }}
                    ]
                });

                $('#add-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#add-friend-avatar-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },
            
            async handleCreateGroup() {
                const friends = await DBHelper.getAll('contacts');
                if (friends.length === 0) {
                     this.showAddMenu(); 
                     UIManager.showModal({
                         title: "æç¤º",
                         body: `<p>é€šè®¯å½•ä¸­è¿˜æ²¡æœ‰å¥½å‹ï¼Œå¿«å»æ·»åŠ ä¸€äº›å¥½å‹å†æ¥åˆ›å»ºç¾¤èŠå§ï¼</p>`,
                         actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                     });
                     return;
                }
                
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());

                const memberListHtml = friends.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="group-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');
                
                
                const creatorOptionsHtml = `<option value="${myProfile.id}">æˆ‘ (${myProfile.name})</option>` + friends.map(f =>
                    `<option value="${f.id}">${f.remark || f.name}</option>`
                ).join('');

                UIManager.showModal({
                    title: "æ–°å»ºç¾¤èŠ",
                    body: `
                         <div class="form-group">
                            <label>ç¾¤å¤´åƒ (é€‰å¡«)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultAvatar}" id="create-group-avatar-preview" class="avatar-preview">
                                <input type="file" id="create-group-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('create-group-avatar-input').click()">ä¸Šä¼ å¤´åƒ</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="create-group-name">ç¾¤åç§° (å¿…å¡«)</label>
                            <input type="text" id="create-group-name" placeholder="ä¸ºç¾¤èŠèµ·ä¸ªåå­—">
                        </div>
                        <div class="form-group">
                            <label for="create-group-creator">é€‰æ‹©ç¾¤ä¸» (å¿…å¡«)</label>
                            <select id="create-group-creator">${creatorOptionsHtml}</select>
                        </div>
                        <div class="form-group">
                            <label>é€‰æ‹©ç¾¤æˆå‘˜</label>
                            <div class="member-select-list">${memberListHtml}</div>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ›å»º', class: 'btn-primary', handler: async () => {
                            const name = $('#create-group-name').value.trim();
                            if (!name) {
                                UIManager.showModal({
                                    title: "æç¤º",
                                    body: `<p>ç¾¤èŠè¿˜æ²¡æœ‰åå­—å‘¢ï¼Œç»™å®ƒèµ·ä¸€ä¸ªå§ã€‚</p>`,
                                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const selectedMembers = [...$$('input[name="group-members"]:checked')].map(cb => cb.value);
                            if (selectedMembers.length < 1) { 
                                UIManager.showModal({
                                    title: "æç¤º",
                                    body: `<p>åˆ›å»ºç¾¤èŠè‡³å°‘éœ€è¦é€‰æ‹©ä¸€ä½å¥½å‹å“¦ã€‚</p>`,
                                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const creatorId = $('#create-group-creator').value;
                            
                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            
                            if (creatorId !== myProfile.id && !selectedMembers.includes(creatorId)) {
                                selectedMembers.push(creatorId);
                            }

                            const newGroup = {
                                id: Utils.generateId('group'),
                                createdAt: Date.now(),
                                name,
                                avatar: $('#create-group-avatar-preview').src,
                                members: selectedMembers,
                                creatorId: creatorId 
                            };
                            
                            await DBHelper.put('groups', newGroup);

                            
                            try {
                                const creatorContact = creatorId === myProfile.id ? myProfile : await DBHelper.get('contacts', creatorId);
                                const memberNames = (await Promise.all(
                                    selectedMembers.map(id => DBHelper.get('contacts', id))
                                )).filter(Boolean).map(c => c.name).join('ã€');

                                
                                const creatorNameForScene = creatorContact ? creatorContact.name : "ä¸€ä½ç¥ç§˜çš„æœ‹å‹";
                                const defaultSceneContent = `${creatorNameForScene} åˆ›å»ºäº†ç¾¤èŠ â€œ${newGroup.name}â€ï¼Œç¾¤èŠæˆå‘˜æœ‰ï¼š${memberNames}ã€${myProfile.name}ã€‚ç°åœ¨ï¼Œå¤§å®¶å¼€å§‹ç§¯æå‘è¨€å§ï¼`;
                                const defaultScene = {
                                    id: Utils.generateId('scene'),
                                    groupId: newGroup.id,
                                    name: 'é»˜è®¤å¼€åœºç™½',
                                    content: defaultSceneContent
                                };
                                await DBHelper.put('openingScenes', defaultScene);
                            } catch(e) {
                                console.error("åˆ›å»ºé»˜è®¤å¼€åœºç™½å¤±è´¥:", e);
                            }

                            UIManager.hideModal();
                            await UIManager.renderContactsPage('groups');
                        }}
                    ]
                });
                
                 $('#create-group-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#create-group-avatar-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },
            
            async handleSortContacts() {
                appState.contactsSortOrder = appState.contactsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('friends');
            },
            
            async handleSortGroups() {
                appState.groupsSortOrder = appState.groupsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('groups');
            },

            handleImportData() {
                const fileInput = $('#import-data-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            await this.processImportedFile(data);
                        } catch (error) {
                            console.error("å¯¼å…¥å¤±è´¥:", error);
                            UIManager.showToast("æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚");
                        } finally {
                            fileInput.value = ''; 
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async processImportedFile(data) {
                if (data.type === 'contact' && data.contactData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflict = existingContacts.find(c => c.name === data.contactData.name);
                    if (conflict) {
                        this.handleCharacterImportConflict(data, conflict);
                    } else {
                        const importedContact = data.contactData;
                        // Use the original ID from the imported file
                        const newContact = { ...importedContact, createdAt: Date.now() }; 
                        delete newContact.openingScenes; // Avoid storing scenes inside contact object

                        await DBHelper.put('contacts', newContact);
                        await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);
                        
                        if (data.chatHistory && data.participants) {
                            // Since we are using the original ID, no mapping is needed for history
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            const newChatData = { ...reconstructedHistory, chatId: newContact.id };
                            await DBHelper.put('chats', newChatData);
                        }
                        
                        UIManager.showToast(`è§’è‰² "${newContact.name}" å¯¼å…¥æˆåŠŸï¼`);
                        if (newContact.author) {
                           EventManager.showAttributionModal(newContact);
                        }
                        await UIManager.renderContactsPage();
                    }
                } else if (data.type === 'group' && data.groupData && data.memberData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflictingMembers = data.memberData.filter(im => existingContacts.some(ec => ec.name === im.name));

                    if (conflictingMembers.length > 0) {
                        this.handleGroupImportConflict(data, conflictingMembers);
                    } else {
                        // Import members with their original IDs
                        for (const member of data.memberData) {
                            const newMember = { ...member, createdAt: Date.now() };
                            delete newMember.openingScenes;
                            await DBHelper.put('contacts', newMember);
                            await this.importOpeningScenes(member.openingScenes, member.id, false);
                        }
                        
                        // Import the group, checking for its own ID conflict
                        const importedGroup = data.groupData;
                        const existingGroup = await DBHelper.get('groups', importedGroup.id);
                        
                        const newGroup = {
                            ...importedGroup,
                            createdAt: Date.now()
                        };
                        // If group ID conflicts, generate a new one
                        if(existingGroup) {
                            newGroup.id = Utils.generateId('group');
                        }
                        delete newGroup.openingScenes;

                        await DBHelper.put('groups', newGroup);
                        
                        // Import chat history. Since member IDs are preserved, no mapping is needed.
                        if (data.chatHistory && data.participants) {
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            const newChatData = { ...reconstructedHistory, chatId: newGroup.id };
                            await DBHelper.put('chats', newChatData);
                        }

                        await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                        UIManager.showToast(`ç¾¤èŠ "${newGroup.name}" åŠæ‰€æœ‰æˆå‘˜å¯¼å…¥æˆåŠŸï¼`);
                        if (newGroup.author) {
                            EventManager.showAttributionModal(newGroup);
                        }
                        await UIManager.renderContactsPage('groups');
                    }
                } else {
                    UIManager.showToast("å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶ç±»å‹æœªçŸ¥æˆ–æ•°æ®ä¸å®Œæ•´ã€‚");
                }
            },

            handleCharacterImportConflict(data, existingContact) {
                const importedContact = data.contactData;
                UIManager.showModal({
                    title: "è§’è‰²å†²çª",
                    body: `<p>é€šè®¯å½•ä¸­å·²å­˜åœ¨åä¸º <strong>${existingContact.name}</strong> çš„è§’è‰²ã€‚<br><strong>æ›´æ–°</strong>ï¼šä¸æ¸…é™¤åŸæ¶ˆæ¯è®°å½•<br><strong>è¦†ç›–</strong>ï¼šæ¸…é™¤è¯¥è§’è‰²åŸæ¥çš„æ¶ˆæ¯è®°å½•<br>è¯·é€‰æ‹©æ“ä½œï¼š</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'æ›´æ–°è§’è‰²', class: 'btn-primary', handler: async () => {
                            const updatedContact = { ...existingContact, ...importedContact, id: existingContact.id };
                            delete updatedContact.openingScenes; 
                            await DBHelper.put('contacts', updatedContact);
                            
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await this.importOpeningScenes(importedContact.openingScenes, existingContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`è§’è‰² "${existingContact.name}" å·²æ›´æ–°ã€‚`);
                            if(updatedContact.author) EventManager.showAttributionModal(updatedContact);
                            await UIManager.renderContactsPage();
                        }},
                        { text: 'è¦†ç›–è§’è‰²', class: 'btn-danger', handler: async () => {
                            // Delete existing data associated with the conflicting contact
                            await DBHelper.delete('chats', existingContact.id);
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await DBHelper.delete('contacts', existingContact.id);

                            // Re-import with the original ID
                            const newContact = { ...importedContact, id: importedContact.id, createdAt: Date.now() };
                            delete newContact.openingScenes;
                            await DBHelper.put('contacts', newContact);
                            
                            // Import history using original ID
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                const newChatData = { ...reconstructedHistory, chatId: newContact.id };
                                await DBHelper.put('chats', newChatData);
                            }

                            await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`è§’è‰² "${newContact.name}" å·²è¢«è¦†ç›–ã€‚`);
                            if(newContact.author) EventManager.showAttributionModal(newContact);
                            await UIManager.renderContactsPage();
                        }}
                    ]
                });
            },

            handleGroupImportConflict(data, conflictingMembers) {
                const importedGroup = data.groupData;
                const importedMembers = data.memberData;
                const conflictNames = conflictingMembers.map(m => m.name).join('ã€');
                UIManager.showModal({
                    title: "ç¾¤èŠæˆå‘˜å†²çª",
                    body: `<p>åœ¨å¯¼å…¥ç¾¤èŠ <strong>${importedGroup.name}</strong> æ—¶ï¼Œå‘ç°ä»¥ä¸‹æˆå‘˜å·²å­˜åœ¨äºä½ çš„é€šè®¯å½•ä¸­ï¼š<br><strong>${conflictNames}</strong><br>è¯·é€‰æ‹©å¦‚ä½•å¤„ç†è¿™äº›å†²çªçš„è§’è‰²ã€‚<br><strong>æ›´æ–°</strong>ï¼šä¸æ¸…é™¤åŸæ¶ˆæ¯è®°å½•<br><strong>è¦†ç›–</strong>ï¼šæ¸…é™¤è¯¥è§’è‰²åŸæ¥çš„æ¶ˆæ¯è®°å½•</p>`,
                    actions: [
                        { text: 'å–æ¶ˆå¯¼å…¥', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å…¨éƒ¨æ›´æ–°', class: 'btn-primary', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const memberIdMap = {};
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                let finalMember;
                                if (existing) {
                                    finalMember = { ...existing, ...member, id: existing.id };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await this.importOpeningScenes(member.openingScenes, existing.id, false);
                                } else {
                                    finalMember = { ...member, id: Utils.generateId('contact'), createdAt: Date.now() };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    await this.importOpeningScenes(member.openingScenes, finalMember.id, false);
                                }
                                memberIdMap[member.id] = finalMember.id;
                            }
                            
                            const newMemberIds = importedGroup.members.map(oldId => memberIdMap[oldId]).filter(Boolean);
                            const newCreatorId = memberIdMap[importedGroup.creatorId] || importedGroup.creatorId;
                            const newGroup = { ...importedGroup, id: Utils.generateId('group'), createdAt: Date.now(), members: newMemberIds, creatorId: newCreatorId };
                            delete newGroup.openingScenes;

                            await DBHelper.put('groups', newGroup);
                            await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`ç¾¤èŠ "${importedGroup.name}" å¯¼å…¥æˆåŠŸï¼Œå†²çªæˆå‘˜å·²æ›´æ–°ã€‚`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                        }},
                        { text: 'å…¨éƒ¨è¦†ç›–', class: 'btn-danger', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const existingGroups = await DBHelper.getAll('groups');
                            
                            // Delete existing group if name conflicts
                            const oldGroup = existingGroups.find(g => g.name === importedGroup.name);
                            if (oldGroup) {
                                await DBHelper.delete('chats', oldGroup.id);
                                await DBHelper.delete('groups', oldGroup.id);
                            }

                            // Delete conflicting members and their data
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                if (existing) {
                                    await DBHelper.delete('chats', existing.id);
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await DBHelper.delete('contacts', existing.id);
                                }
                            }
                            
                            // Now import all members with their original IDs
                            for (const member of importedMembers) {
                                const newMember = { ...member, createdAt: Date.now() };
                                delete newMember.openingScenes;
                                await DBHelper.put('contacts', newMember);
                                await this.importOpeningScenes(member.openingScenes, member.id, false);
                            }
                            
                            // Import the group, checking for its own ID conflict
                            const groupToImport = { ...importedGroup, createdAt: Date.now() };
                            const groupWithSameIdExists = await DBHelper.get('groups', groupToImport.id);
                            if (groupWithSameIdExists) {
                                groupToImport.id = Utils.generateId('group');
                            }
                            delete groupToImport.openingScenes;

                            await DBHelper.put('groups', groupToImport);
                            
                            // Import chat history. Since member IDs are preserved, no mapping is needed.
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                const newChatData = { ...reconstructedHistory, chatId: groupToImport.id };
                                await DBHelper.put('chats', newChatData);
                            }

                            await this.importOpeningScenes(importedGroup.openingScenes, groupToImport.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`ç¾¤èŠ "${importedGroup.name}" å¯¼å…¥æˆåŠŸï¼Œå†²çªæˆå‘˜å·²è¢«è¦†ç›–ã€‚`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                        }}
                    ]
                });
            },


            showAttributionModal(entity) {
                UIManager.showModal({
                    title: "ä½œè€…ä¿¡æ¯",
                    body: `
                        <div class="details-card">
                            <div class="details-field">
                                <span class="label">æ¥æºäº</span>
                                <span class="value">${entity.author}</span>
                            </div>
                            <div class="details-section" style="margin-top: 15px;">
                                <div class="details-section-title">ä½œè€…æœ‰è¯è¯´</div>
                                <p>${entity.authorWords || 'ä½œè€…å¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡ç•™ä¸‹...'}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async reconstructChatHistory(chatHistory, participants) {
                if (!chatHistory || !chatHistory.history || !participants) {
                    return chatHistory;
                }

                const participantMap = participants.reduce((map, p) => {
                    map[p.id] = p;
                    return map;
                }, {});

                chatHistory.history.forEach(msg => {
                    if (msg.senderId && participantMap[msg.senderId]) {
                        msg.senderInfo = participantMap[msg.senderId];
                    }
                });

                return chatHistory;
            },

            async handleExportContact(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                contact.openingScenes = allOpeningScenes.filter(s => s.contactId === contactId);
                this.showExportModal(contact, false);
            },

            async handleExportGroup(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const membersData = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                group.openingScenes = allOpeningScenes.filter(s => s.groupId === groupId);
                
                const exportPackage = {
                    groupData: group,
                    memberData: membersData
                };
                this.showExportModal(exportPackage, true);
            },

            showExportModal(entity, isGroup) {
                const myProfile = { name: 'ä½ ' };
                const targetEntity = isGroup ? entity.groupData : entity;

                const authorName = targetEntity.author || myProfile.name;
                const authorWords = targetEntity.authorWords || '';
                const isAuthorFixed = !!targetEntity.author;

                UIManager.showModal({
                    title: `å¯¼å‡º${isGroup ? 'ç¾¤èŠ' : 'è§’è‰²'}`,
                    body: `
                        <div class="form-group">
                            <label for="export-author-name">ä½œè€…å</label>
                            <input type="text" id="export-author-name" value="${authorName}" ${isAuthorFixed ? 'disabled' : ''}>
                        </div>
                        <div class="form-group">
                            <label for="export-author-words">ä½œè€…æœ‰è¯è¯´ (é€‰å¡«)</label>
                            <textarea id="export-author-words" rows="3">${authorWords}</textarea>
                        </div>
                        <div class="form-group" style="display: flex; align-items: center; justify-content: center; padding-top: 10px;">
                            <input type="checkbox" id="export-chat-history-checkbox" style="width: 16px; height: 16px; margin-right: 8px;">
                            <label for="export-chat-history-checkbox" style="margin: 0; cursor: pointer;">åŒæ—¶å¯¼å‡ºèŠå¤©è®°å½•</label>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜å¹¶å¯¼å‡º', class: 'btn-primary', handler: async () => {
                            const newAuthorName = $('#export-author-name').value.trim();
                            const newAuthorWords = $('#export-author-words').value.trim();
                            const includeHistory = $('#export-chat-history-checkbox').checked;

                            let exportData;
                            let chatId;

                            if (isGroup) {
                                entity.groupData.author = newAuthorName;
                                entity.groupData.authorWords = newAuthorWords;
                                exportData = { type: 'group', ...entity };
                                chatId = entity.groupData.id;
                            } else {
                                entity.author = newAuthorName;
                                entity.authorWords = newAuthorWords;
                                exportData = { type: 'contact', contactData: entity };
                                chatId = entity.id;
                            }

                            if (includeHistory) {
                                const chatHistory = await DBHelper.get('chats', chatId);
                                if (chatHistory && chatHistory.history) {
                                    const participants = {};
                                    const myProfile = await DBHelper.get('profile', 'myProfile');
                                    const allContacts = await DBHelper.getAll('contacts');
                                    
                                    participants[myProfile.id] = myProfile;

                                    for (const msg of chatHistory.history) {
                                        if (msg.senderId && !participants[msg.senderId]) {
                                            const senderInfo = allContacts.find(c => c.id === msg.senderId);
                                            if (senderInfo) {
                                                participants[msg.senderId] = senderInfo;
                                            }
                                        }
                                        delete msg.senderInfo; 
                                    }
                                    
                                    exportData.chatHistory = chatHistory;
                                    exportData.participants = Object.values(participants);
                                }
                            }

                            const filename = `${isGroup ? entity.groupData.name : entity.name}_${new Date().toISOString().slice(0, 10)}.json`;
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            handleResetApp() {
                UIManager.showModal({
                    title: 'ç¡®è®¤é‡ç½®',
                    body: `<p>æ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬ä½ çš„ä¸ªäººä¿¡æ¯ã€è”ç³»äººã€ç¾¤èŠã€èŠå¤©è®°å½•å’ŒAPIé…ç½®ï¼Œä¸”æ— æ³•æ¢å¤ã€‚ä½ ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤é‡ç½®', class: 'btn-danger', handler: () => {
                            indexedDB.deleteDatabase(DBHelper.DB_NAME);
                            UIManager.hideModal();
                            UIManager.showModal({
                                title: "æ“ä½œæˆåŠŸ",
                                body: `<p>åº”ç”¨å·²é‡ç½®ï¼Œæ‰€æœ‰æ•°æ®å·²è¢«æ¸…é™¤ã€‚é¡µé¢å³å°†åˆ·æ–°...</p><p>å¦‚æœæ²¡æœ‰ååº”ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°ã€‚</p>`,
                                actions: [{ text: 'ç«‹å³åˆ·æ–°', class: 'btn-primary', handler: () => window.location.reload() }]
                            });
                            setTimeout(() => window.location.reload(), 3000); 
                        }}
                    ]
                });
            },

            
            async applyBackgroundSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const appContainer = $('#app-container');
                if (settings.appBackground) {
                    appContainer.style.backgroundImage = `url(${settings.appBackground})`;
                } else {
                    appContainer.style.backgroundImage = '';
                }
            },

            async applyFontSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                const fontSettings = settings.fonts || {};
                const customFonts = settings.customFonts || {};

                const fontTypes = {
                    Global: '--font-main',
                    Bubble: '--font-bubble',
                    InnerVoice: '--font-inner-voice',
                    Essay: '--font-essay'
                };

                
                const defaultFontValues = {
                    global: '"SimSun", "å®‹ä½“", serif',
                    bubble: '"LXGW WenKai Screen", "Kaiti", "æ¥·ä½“", serif',
                    innervoice: '"Long Cang", cursive',
                    essay: '"Long Cang", cursive'
                };

                for (const [type, cssVar] of Object.entries(fontTypes)) {
                    const typeKey = type.toLowerCase();
                    const setting = fontSettings[typeKey]; 

                    if (setting && setting.type === 'custom' && customFonts[setting.value]) {
                        
                        const customFont = customFonts[setting.value];
                        root.style.setProperty(cssVar, `"${customFont.name}", sans-serif`);
                    } else if (setting && setting.type === 'builtin') {
                        
                        root.style.setProperty(cssVar, setting.value);
                    } else {
                        
                        
                        
                        
                        root.style.setProperty(cssVar, defaultFontValues[typeKey]);
                    }
                }
            },

            async loadAndApplyFontsInBackground() {
                
                try {
                    await this.loadCustomFontsOnStartup();
                    await this.applyFontSettings();
                    console.log("Custom fonts and settings applied in the background.");
                } catch (error) {
                    console.error("Failed to load and apply fonts in background:", error);
                }
            },


        async renderThemeSettingsPage() {
            const contentArea = $('#theme-settings-content');
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            appState.theme = chatSettings.theme || 'neumorphic';

            const bubbleStyles = {
                'default': { name: 'é»˜è®¤', type: 'A', style: 'background: white; border: 2px solid var(--player-bubble-bg);' },
                '3d': { name: 'ç«‹ä½“3D', type: 'A', style: 'background: var(--player-bubble-bg); border-bottom: 3px solid rgba(0,0,0,0.2); border-radius: 12px;' },
                'neumorphic': { name: 'æ‹Ÿæ€', type: 'A', style: 'background: var(--player-bubble-bg); box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff; color: #555;' },
                'stripes': { name: 'æŸ”å’Œæ¡çº¹', type: 'A', style: 'background-color: var(--player-bubble-bg); background-image: repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.2) 15px, rgba(255, 255, 255, 0.1) 15px, rgba(255, 255, 255, 0.1) 30px);' },
                'grid': { name: 'ç½‘æ ¼', type: 'A', style: 'background-image: linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px); background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent);' },
                'cute': { name: 'å¯çˆ±é£', type: 'A', style: 'background: transparent; border: 2px solid var(--player-bubble-bg); border-radius: 25px 25px 5px 25px;' },
                'frosted-glass': { name: 'æ¯›ç»ç’ƒ', type: 'A', style: 'background-color: color-mix(in srgb, var(--player-bubble-bg) 25%, transparent); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid rgba(255, 255, 255, 0.2);' },
                'neumorphic-2': { name: 'æ‹Ÿæ€2', type: 'B', style: 'background: #F0F0F3; box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);' },
                'ancient': { name: 'å¤é£', type: 'B', style: 'background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;' },
                'chinese': { name: 'å›½é£', type: 'B', style: 'background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;' },
                'doodle': { name: 'æ‰‹ç»˜æ¶‚é¸¦', type: 'B', style: 'background: white; border: 2px solid #333; color: #333; box-shadow: 3px 3px 0px #ccc; border-radius: 15px 10px 15px 12px;' },
                'hand-drawn': { name: 'æ‰‹ç»˜æ¶‚é¸¦2', type: 'B', style: 'background: white; border: 3px solid #333; box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: "Comic Sans MS", cursive; color: #333;' },
                'stripey': { name: 'å¯çˆ±æ¡çº¹', type: 'B', style: 'background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);' },
                'gradient': { name: 'æ¸å˜å½©è™¹', type: 'B', style: 'background: linear-gradient(45deg, #a1c4fd, #c2e9fb, #ff9a9e, #a1c4fd); animation: gradientBG 8s ease infinite; background-size: 300% 300%;' },
                'glow-jelly': { name: 'å‘å…‰æœå†»', type: 'B', style: 'background: linear-gradient(135deg, #ff7e5f, #feb47b); box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);' },
                'metal': { name: 'é‡‘å±è´¨æ„Ÿ', type: 'B', style: 'background: linear-gradient(145deg, #e0e0e0, #c0c0c0);' },
                'ocean': { name: 'æµ·æ´‹é£', type: 'B', style: 'background: linear-gradient(160deg, #0077b6, #00b4d8);' },
                'paw': { name: 'çŒ«çˆªé£', type: 'B', style: 'background: #fce1cb; color: #8b5e34;' },
            };

            const currentStyle = settings.bubbleStyle || 'default';
            let bubbleStyleOptionsHTML = '';
            for (const [key, value] of Object.entries(bubbleStyles)) {
                bubbleStyleOptionsHTML += `
                    <div class="bubble-style-option ${currentStyle === key ? 'selected' : ''}" data-style-key="${key}">
                        <div class="bubble-style-preview" style="${value.style}"><span>${value.type}</span></div>
                        <span>${value.name}</span>
                    </div>
                `;
            }

            
            const fontSizeOptions = {
                'small': { name: 'å°', value: '0.8rem' },
                'normal-small': { name: 'è¾ƒå°', value: '0.88rem' },
                'default': { name: 'é»˜è®¤', value: '0.95rem' },
                'normal-large': { name: 'è¾ƒå¤§', value: '1.05rem' },
                'large': { name: 'å¤§', value: '1.15rem' }
            };
            const currentFontSizeKey = settings.bubbleFontSize || 'default';
            const fontSizeRadioHTML = Object.entries(fontSizeOptions).map(([key, value]) => `
                <label style="cursor:pointer;"><input type="radio" name="font-size-radio" value="${key}" ${currentFontSizeKey === key ? 'checked' : ''}> ${value.name}</label>
            `).join('');


            contentArea.innerHTML = `
                <style>
                    
                    .theme-setting-card .color-input-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
                    .theme-setting-card .color-input-group label { font-size: 0.9rem; color: var(--text-color-medium); margin-bottom: 0; }
                    .theme-setting-card .color-input-group input[type="color"] { width: 40px; height: 40px; border: 2px solid var(--border-color); border-radius: 8px; cursor: pointer; padding: 0; background-color: transparent; -webkit-appearance: none; -moz-appearance: none; appearance: none; }
                    .theme-setting-card .color-input-group input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
                    .theme-setting-card .color-input-group input[type="color"]::-webkit-color-swatch { border: none; border-radius: 6px; }
                    .bubble-style-options-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; justify-content: center; margin-top: 10px; }
                    .bubble-style-option { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 10px; border-radius: 10px; border: 2px solid transparent; transition: all 0.3s ease; background-color: rgba(0,0,0,0.03); }
                    .bubble-style-option.selected { border-color: var(--accent-color); transform: scale(1.05); }
                    .bubble-style-option:hover { background-color: rgba(0,0,0,0.06); }
                    .bubble-style-preview { width: 80px; height: 40px; border-radius: 10px; margin-bottom: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.05); display: flex; justify-content: center; align-items: center; font-size: 0.8rem; color: white; text-shadow: 1px 1px 1px rgba(0,0,0,0.2); font-weight: bold; }
                    .bubble-style-option span { font-size: 0.9rem; color: var(--text-color-dark); text-align: center; }
                    .bubble-style-preview span { color: white; }
                </style>
                <div class="theme-setting-card">
                    <h3>å¼¹çª—é£æ ¼</h3>
                    <div style="display: flex; justify-content: space-around; padding-top: 10px;">
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="default" ${appState.theme !== 'neumorphic' ? 'checked' : ''}> é»˜è®¤</label>
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="neumorphic" ${appState.theme === 'neumorphic' ? 'checked' : ''}> æ‹Ÿæ€</label>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>é€šç”¨è®¾ç½®</h3>
                    <div class="theme-setting-group">
                       <button id="font-settings-btn" class="theme-page-btn">å­—ä½“è®¾ç½®</button>
                       <button id="background-settings-btn" class="theme-page-btn">èƒŒæ™¯ä¸å°é¢</button>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>èŠå¤©æ°”æ³¡æ ·å¼</h3>
                    <div id="bubble-style-options" class="bubble-style-options-container">${bubbleStyleOptionsHTML}</div>
                </div>
                <div class="theme-setting-card">
                    <h3>èŠå¤©å­—ä½“å¤§å°</h3>
                    <div id="font-size-radio-group" style="display: flex; justify-content: space-around; padding-top: 10px;">
                        ${fontSizeRadioHTML}
                    </div>
                    <p style="font-size: 0.8rem; color: var(--text-color-light); text-align: center; margin-top: 10px; padding: 0 15px;">
                        èŠå¤©å­—ä½“å¤§å°åŒæ—¶è¿˜å–å†³äºè‡ªå®šä¹‰å­—ä½“å› ç´ å½±å“
                    </p>
                </div>
                <div class="theme-setting-card" id="bubble-color-card">
                    <h3>æ°”æ³¡é¢œè‰² (é™Aç±»æ°”æ³¡)</h3>
                    <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                        <div class="color-input-group">
                            <label for="friend-bubble-bg-color">å¥½å‹æ¶ˆæ¯èƒŒæ™¯</label>
                            <input type="color" id="friend-bubble-bg-color" value="${settings.friendBubbleBg || '#FFFFFF'}">
                        </div>
                        <div class="color-input-group">
                            <label for="player-bubble-bg-color">æˆ‘çš„æ¶ˆæ¯èƒŒæ™¯</label>
                            <input type="color" id="player-bubble-bg-color" value="${settings.playerBubbleBg || '#A7C7E7'}">
                        </div>
                    </div>
                </div>
                 <div class="theme-setting-card">
                    <h3>èŠå¤©æ°”æ³¡å­—ä½“é¢œè‰²</h3>
                     <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                        <div class="color-input-group">
                            <label for="friend-bubble-text-color">å¥½å‹æ¶ˆæ¯</label>
                            <input type="color" id="friend-bubble-text-color" value="${settings.friendBubbleTextColor || '#5D534A'}">
                        </div>
                        <div class="color-input-group">
                            <label for="player-bubble-text-color">æˆ‘çš„æ¶ˆæ¯</label>
                            <input type="color" id="player-bubble-text-color" value="${settings.playerBubbleTextColor || '#FFFFFF'}">
                        </div>
                    </div>
                </div>
            `;
            
            $('#theme-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
            
            
            $('#font-size-radio-group').onchange = async (e) => {
                if (e.target.name === 'font-size-radio') {
                    const sizeKey = e.target.value;
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    settingsToSave.bubbleFontSize = sizeKey;
                    await DBHelper.put('apiConfig', settingsToSave);
                    await this.applyBubbleFontSize(); 
                }
            };

            const saveBubbleSettings = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                settingsToSave.bubbleStyle = document.querySelector('.bubble-style-option.selected').dataset.styleKey;
                settingsToSave.friendBubbleBg = $('#friend-bubble-bg-color').value;
                settingsToSave.playerBubbleBg = $('#player-bubble-bg-color').value;
                settingsToSave.friendBubbleTextColor = $('#friend-bubble-text-color').value;
                settingsToSave.playerBubbleTextColor = $('#player-bubble-text-color').value;
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyBubbleSettings();
            };

            $$('input[name="modal-theme"]').forEach(radio => {
                radio.onchange = async (e) => {
                    appState.theme = e.target.value;
                    const settingsToSave = await DBHelper.get('apiConfig', 'chatSettings') || { id: 'chatSettings' };
                    settingsToSave.theme = appState.theme;
                    await DBHelper.put('apiConfig', settingsToSave);
                };
            });

            
            $('#bubble-style-options').onclick = (e) => {
                const option = e.target.closest('.bubble-style-option');
                if (!option) return;

                $$('.bubble-style-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                const isTypeA = bubbleStyles[option.dataset.styleKey].type === 'A';
                $('#bubble-color-card').style.display = isTypeA ? 'block' : 'none';
                saveBubbleSettings();
            };

            ['friend-bubble-bg-color', 'player-bubble-bg-color', 'friend-bubble-text-color', 'player-bubble-text-color'].forEach(id => {
                $(`#${id}`).oninput = saveBubbleSettings; 
            });
            
            const initialStyleIsTypeA = bubbleStyles[currentStyle].type === 'A';
            $('#bubble-color-card').style.display = initialStyleIsTypeA ? 'block' : 'none';

            $('#font-settings-btn').onclick = () => this.handleFontSettings();

            $('#background-settings-btn').onclick = () => {
                UIManager.showModal({
                    title: "èƒŒæ™¯ä¸å°é¢",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="modal-bg-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-desktop"></i><span>åº”ç”¨/èŠå¤©èƒŒæ™¯</span><i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="modal-cover-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-photo-video"></i><span>è‡ªå®šä¹‰å°é¢</span><i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: [{ text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });
                
                $('#modal-bg-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleBackgroundSettings();
                });
                $('#modal-cover-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleCoverSettings();
                });
            };
        },

        async handleBackgroundSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey) => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">ä¸Šä¼ </button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">ç§»é™¤</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: 'èƒŒæ™¯è®¾ç½®',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('app-bg', 'ä¸»é¢˜èƒŒæ™¯', settings.appBackground, 'appBackground')}
                        ${createUploadHTML('global-bg', 'èŠå¤©èƒŒæ™¯', settings.globalChatBg, 'globalChatBg')}
                    </div>`,
                actions: [{ text: 'å®Œæˆ', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.compressImage(file, 800, 800, 0.7);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                        if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                        UIManager.showToast('å›¾ç‰‡å·²æ›´æ–°');
                    } catch (error) { 
                        console.error("å›¾ç‰‡ä¸Šä¼ æˆ–åº”ç”¨å¤±è´¥:", error);
                        UIManager.showToast('å›¾ç‰‡å¤„ç†å¤±è´¥'); 
                    }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                    if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                    UIManager.showToast('å›¾ç‰‡å·²ç§»é™¤');
                };
            };
            setupUploadHandler('app-bg', 'appBackground');
            setupUploadHandler('global-bg', 'globalChatBg');
        },

        async handleCoverSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey, previewStyle = '') => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper" style="${previewStyle}">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">ä¸Šä¼ </button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">ç§»é™¤</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: 'è‡ªå®šä¹‰å°é¢',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('rp-cover', 'çº¢åŒ…å°é¢', settings.redPacketCover, 'redPacketCover', 'width: 80px; height: 106px;')}
                        ${createUploadHTML('transfer-cover', 'è½¬è´¦å°é¢', settings.transferCover, 'transferCover')}
                        ${createUploadHTML('receipt-cover', 'æ”¶æ¬¾å°é¢', settings.receiptCover, 'receiptCover')}
                    </div>`,
                actions: [{ text: 'å®Œæˆ', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.compressImage(file, 800, 800, 0.7);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        UIManager.showToast('å°é¢å·²æ›´æ–°');
                    } catch (error) { UIManager.showToast('å›¾ç‰‡å¤„ç†å¤±è´¥'); }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    UIManager.showToast('å°é¢å·²ç§»é™¤');
                };
            };
            setupUploadHandler('rp-cover', 'redPacketCover');
            setupUploadHandler('transfer-cover', 'transferCover');
            setupUploadHandler('receipt-cover', 'receiptCover');
        },

        async applyBubbleSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const root = document.documentElement;
            const appContainer = $('#app-container');

            
            root.style.setProperty('--friend-bubble-bg', settings.friendBubbleBg || '#FFFFFF');
            root.style.setProperty('--player-bubble-bg', settings.playerBubbleBg || 'var(--accent-color)');
            root.style.setProperty('--friend-bubble-text-color', settings.friendBubbleTextColor || '#5D534A');
            root.style.setProperty('--player-bubble-text-color', settings.playerBubbleTextColor || '#FFFFFF');

            
            const styleKey = settings.bubbleStyle || 'default';
            const classList = Array.from(appContainer.classList);
            
            
            let newClassList = classList.filter(c => !c.startsWith('app-bubble-style-'));
            if(classList.includes('bottom-offset-active')) {
                if(!newClassList.includes('bottom-offset-active')) {
                     newClassList.push('bottom-offset-active');
                }
            }
            
            
            newClassList.push(`app-bubble-style-${styleKey}`);
            appContainer.className = newClassList.join(' ');
        },

        async applyBubbleFontSize() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSizeKey = settings.bubbleFontSize || 'default';
            const fontSizes = {
                'small': '0.8rem',
                'normal-small': '0.88rem',
                'default': '0.95rem',
                'normal-large': '1.05rem',
                'large': '1.15rem'
            };
            document.documentElement.style.setProperty('--font-bubble-size', fontSizes[fontSizeKey]);
        },

        async handleFontSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSettings = settings.fonts || {};
            const customFonts = settings.customFonts || {};

            const builtinFonts = {
                'å®‹ä½“ (SimSun)': '"SimSun", "å®‹ä½“", serif',
                'æ¥·ä½“ (LXGW WenKai)': '"LXGW WenKai Screen", "Kaiti", "æ¥·ä½“", serif',
                'é¾™è—ä½“ (Long Cang)': '"Long Cang", cursive',
                'System Default': `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`,
            };
            
            const defaultFontValues = {
                global: builtinFonts['å®‹ä½“ (SimSun)'],
                bubble: builtinFonts['æ¥·ä½“ (LXGW WenKai)'],
                innervoice: builtinFonts['é¾™è—ä½“ (Long Cang)'],
                essay: builtinFonts['é¾™è—ä½“ (Long Cang)']
            };

            const createFontSelectorHTML = (typeKey, typeLabel) => {
                const settingKey = typeKey.toLowerCase();
                const currentSetting = fontSettings[settingKey] || { type: 'builtin', value: defaultFontValues[settingKey] };

                
                let optionsHTML = Object.entries(builtinFonts).map(([name, value]) =>
                    `<option value='${value}' data-type="builtin" ${currentSetting.type === 'builtin' && currentSetting.value === value ? 'selected' : ''}>${name}</option>`
                ).join('');

                for (const [key, font] of Object.entries(customFonts)) {
                    optionsHTML += `<option value="${key}" data-type="custom" ${currentSetting.type === 'custom' && currentSetting.value === key ? 'selected' : ''}>${font.name} (è‡ªå®šä¹‰)</option>`;
                }

                return `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label>${typeLabel}</label>
                        <select class="font-select" data-font-type="${settingKey}" style="flex-grow: 1; max-width: 60%;">${optionsHTML}</select>
                    </div>`;
            };

            UIManager.showModal({
                title: "å­—ä½“è®¾ç½®",
                body: `
                    <div class="form-group" style="display: flex; justify-content: space-around; padding-bottom: 15px; border-bottom: 1px dashed var(--border-color);">
                        <button id="font-upload-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">æœ¬åœ°</button>
                        <button id="font-url-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">ç½‘ç»œ</button>
                        <button id="font-delete-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">åˆ é™¤</button>
                    </div>
                    <div style="margin-top: 20px;">
                        ${createFontSelectorHTML('Global', 'å…¨å±€å­—ä½“')}
                        ${createFontSelectorHTML('Bubble', 'æ°”æ³¡å­—ä½“')}
                        ${createFontSelectorHTML('InnerVoice', 'å¿ƒå£°å­—ä½“')}
                        ${createFontSelectorHTML('Essay', 'éšç¬”å­—ä½“')}
                    </div>
                `,
                actions: [
                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.fonts = settingsToSave.fonts || {};

                        $$('.font-select').forEach(select => {
                            const fontTypeKey = select.dataset.fontType;
                            const selectedOption = select.options[select.selectedIndex];
                            settingsToSave.fonts[fontTypeKey] = {
                                type: selectedOption.dataset.type,
                                value: selectedOption.value
                            };
                        });

                        await DBHelper.put('apiConfig', settingsToSave);
                        await this.applyFontSettings();
                        UIManager.hideModal();
                        UIManager.showToast("å­—ä½“è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨");
                    }}
                ]
            });

            $('#font-upload-btn').onclick = () => this.handleFontUpload(false);
            $('#font-url-btn').onclick = () => this.handleFontUrl(false);
            $('#font-delete-btn').onclick = () => this.handleDeleteCustomFont();
        },

            async handleFontUpload() {
                UIManager.showModal({
                    title: "ä¸Šä¼ æœ¬åœ°å­—ä½“",
                    body: `
                        <div style="font-size: 0.9rem; line-height: 1.6;">
                            <p>è¯·é€‰æ‹©å­—ä½“æ–‡ä»¶è¿›è¡Œä¸Šä¼ ã€‚æ”¯æŒçš„æ ¼å¼ä¸º <code>.ttf</code>, <code>.otf</code>, <code>.woff</code>, <code>.woff2</code>ã€‚</p>
                            <p><strong>å¼ºçƒˆæ¨èä½¿ç”¨ <code>.woff2</code> æ ¼å¼</strong>ï¼Œå› ä¸ºå®ƒçš„æ–‡ä»¶ä½“ç§¯æ›´å°ï¼ŒåŠ è½½é€Ÿåº¦æ›´å¿«ã€‚</p>
                            <p>è¯·å°½é‡é€‰æ‹©ä½“ç§¯è¾ƒå°çš„å­—ä½“æ–‡ä»¶ï¼Œè¿‡å¤§çš„å­—ä½“ä¼šå¯¼è‡´åˆ·æ–°é¡µé¢æ—¶åŠ è½½å˜æ…¢ã€‚(<strong>æ¨èä½¿ç”¨ç½‘ç»œé“¾æ¥ä¸Šä¼ </strong>)</p>
                            <p style="color: var(--text-color-medium); margin-top: 15px;">åŠ è½½å­—ä½“éœ€è¦ä¸€äº›æ—¶é—´ï¼Œä¸Šä¼ åè¯·è€å¿ƒç­‰å¾…ç•Œé¢åˆ·æ–°ã€‚</p>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings(); 
                        }},
                        { text: 'ç»§ç»­ä¸Šä¼ ', class: 'btn-primary', handler: () => {
                            UIManager.hideModal(); 
                            this.triggerActualFontUpload(); 
                        }}
                    ]
                });
            },

            triggerActualFontUpload() {
                const fontFileInput = $('#font-file-input');
                fontFileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const fontName = file.name.split('.')[0];
                    try {
                        const base64 = await Utils.fileToBase64(file);
                        const customFontKey = `${Utils.generateId('font')}`;
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.customFonts = settingsToSave.customFonts || {};
                        settingsToSave.customFonts[customFontKey] = { name: fontName, data: base64 };
                        await DBHelper.put('apiConfig', settingsToSave);

                        
                        await this.loadCustomFontsOnStartup();
                        
                        this.handleFontSettings(); 
                        UIManager.showToast(`å­—ä½“ "${fontName}" ä¸Šä¼ æˆåŠŸï¼`);
                    } catch (error) {
                        UIManager.showToast("å­—ä½“æ–‡ä»¶è¯»å–å¤±è´¥");
                    } finally {
                        fontFileInput.value = '';
                    }
                };
                fontFileInput.click();
            },

            async handleFontUrl() {
                UIManager.showModal({
                    title: "æ·»åŠ ç½‘ç»œå­—ä½“",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">å­—ä½“åç§° (è‡ªå®šä¹‰)</label>
                            <input type="text" id="font-url-name-input" placeholder="ä¾‹å¦‚ï¼šæ€æºé»‘ä½“">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">å­—ä½“æ–‡ä»¶ URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();
                            if (!fontName || !fontUrl) return UIManager.showToast("åç§°å’ŒURLå‡ä¸èƒ½ä¸ºç©º");
                            if (!fontUrl.startsWith('http')) return UIManager.showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„URL");

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();

                            UIManager.hideModal();
                            this.handleFontSettings();
                            UIManager.showToast(`ç½‘ç»œå­—ä½“ "${fontName}" æ·»åŠ æˆåŠŸï¼`);
                        }}
                    ]
                });
            },

            async handleDeleteCustomFont() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const customFonts = settings.customFonts || {};

                if (Object.keys(customFonts).length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯åˆ é™¤çš„è‡ªå®šä¹‰å­—ä½“");
                }

                
                const fontListHtml = Object.entries(customFonts).map(([key, font]) => `
                    <label class="member-select-item">
                        <input type="radio" name="delete-font-radio" value="${key}">
                        <span>${font.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦åˆ é™¤çš„å­—ä½“",
                    body: `<div class="member-select-list">${fontListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            const selectedRadio = $('input[name="delete-font-radio"]:checked');
                            if (!selectedRadio) return UIManager.showToast("è¯·é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„å­—ä½“");

                            const fontKeyToDelete = selectedRadio.value;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            
                            
                            if (settingsToSave.customFonts && settingsToSave.customFonts[fontKeyToDelete]) {
                                delete settingsToSave.customFonts[fontKeyToDelete];
                            }

                            
                            if (settingsToSave.fonts) {
                                for (const typeKey in settingsToSave.fonts) {
                                    if (settingsToSave.fonts[typeKey].value === fontKeyToDelete) {
                                        
                                        settingsToSave.fonts[typeKey] = { type: 'builtin', value: '"SimSun", "å®‹ä½“", serif' }; 
                                    }
                                }
                            }
                            
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            UIManager.showToast("è‡ªå®šä¹‰å­—ä½“å·²åˆ é™¤");
                            this.handleFontSettings(); 
                        }}
                    ]
                });
            },

            async loadCustomFontsOnStartup() {
                
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const fontSettings = settings.fonts || {}; 
                const customFonts = settings.customFonts || {}; 

                
                if (Object.keys(customFonts).length === 0) {
                    
                    let fontStyleTag = document.getElementById('dynamic-font-styles');
                    if (fontStyleTag) fontStyleTag.innerHTML = '';
                    return;
                }

                
                const activeCustomFontKeys = new Set();
                
                for (const setting of Object.values(fontSettings)) {
                    
                    if (setting.type === 'custom' && setting.value) {
                        
                        activeCustomFontKeys.add(setting.value);
                    }
                }

                
                let fontStyleTag = document.getElementById('dynamic-font-styles');
                if (!fontStyleTag) {
                    fontStyleTag = document.createElement('style');
                    fontStyleTag.id = 'dynamic-font-styles';
                    document.head.appendChild(fontStyleTag);
                }

                
                let fontFaceRules = '';
                
                for (const key of activeCustomFontKeys) {
                    const font = customFonts[key]; 
                    if (font && font.name && font.data) {
                        let src;
                        
                        if (font.data.startsWith('data:')) {
                            src = `url(${font.data})`;
                        } else {
                            src = `url('${font.data}')`;
                        }
                        
                        fontFaceRules += `@font-face { font-family: "${font.name}"; src: ${src}; }\n`;
                    }
                }

                
                fontStyleTag.innerHTML = fontFaceRules;
            },

            async handleFontUrl(fontTypeKey) {
                UIManager.showModal({
                    title: "æ·»åŠ ç½‘ç»œå­—ä½“",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">å­—ä½“åç§° (è‡ªå®šä¹‰)</label>
                            <input type="text" id="font-url-name-input" placeholder="ä¾‹å¦‚ï¼šæ€æºé»‘ä½“">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">å­—ä½“æ–‡ä»¶ URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 10px;">
                            æç¤ºï¼šå­—ä½“æ–‡ä»¶è¶Šå¤§ï¼ŒåŠ è½½æ—¶é—´è¶Šé•¿ï¼Œè¯·å°½é‡é€‰æ‹©ä½“ç§¯è¾ƒå°çš„å­—ä½“ã€‚
                        </p>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();

                            if (!fontName || !fontUrl) {
                                return UIManager.showToast("åç§°å’ŒURLå‡ä¸èƒ½ä¸ºç©º");
                            }

                            
                            if (!fontUrl.startsWith('http')) {
                                return UIManager.showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„URL");
                            }

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.fonts = settingsToSave.fonts || {};

                            
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            settingsToSave.fonts[fontTypeKey] = { type: 'custom', value: customFontKey };

                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            
                            this.handleFontSettings();
                        }}
                    ]
                });
            },

            async loadCustomFontsOnStartup() {
                
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const fontSettings = settings.fonts || {}; 
                const customFonts = settings.customFonts || {}; 

                
                if (Object.keys(customFonts).length === 0) {
                    
                    let fontStyleTag = document.getElementById('dynamic-font-styles');
                    if (fontStyleTag) fontStyleTag.innerHTML = '';
                    return;
                }

                
                const activeCustomFontKeys = new Set();
                
                for (const setting of Object.values(fontSettings)) {
                    
                    if (setting.type === 'custom' && setting.value) {
                        
                        activeCustomFontKeys.add(setting.value);
                    }
                }

                
                let fontStyleTag = document.getElementById('dynamic-font-styles');
                if (!fontStyleTag) {
                    fontStyleTag = document.createElement('style');
                    fontStyleTag.id = 'dynamic-font-styles';
                    document.head.appendChild(fontStyleTag);
                }

                
                let fontFaceRules = '';
                
                for (const key of activeCustomFontKeys) {
                    const font = customFonts[key]; 
                    if (font && font.name && font.data) {
                        let src;
                        
                        if (font.data.startsWith('data:')) {
                            src = `url(${font.data})`;
                        } else {
                            src = `url('${font.data}')`;
                        }
                        
                        fontFaceRules += `@font-face { font-family: "${font.name}"; src: ${src}; }\n`;
                    }
                }

                
                fontStyleTag.innerHTML = fontFaceRules;
            },

            async handleChatBackgroundSettings(chatId, isGroup) {
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const currentBg = entity.chatBackground || null;

                const createUploadSection = (id, label, previewSrc) => `
                    <div class="background-upload-section">
                        <label>${label}</label>
                        <img src="${previewSrc || 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='}" 
                             alt="${label}é¢„è§ˆ" 
                             class="background-preview" 
                             id="${id}-preview"
                             style="${previewSrc ? '' : 'display: none;'}">
                        <input type="file" id="${id}-input" accept="image/*" style="display: none;">
                        <button class="modal-btn btn-secondary" style="padding: 8px 15px;" onclick="document.getElementById('${id}-input').click()">ä¸Šä¼ </button>
                        <button class="modal-btn btn-danger" style="padding: 8px 15px; ${previewSrc ? '' : 'display: none;'}" id="${id}-remove-btn">ç§»é™¤</button>
                    </div>`;

                UIManager.showModal({
                    title: `ä¸“å±èƒŒæ™¯ - ${entity.name}`,
                    customClass: 'theme-settings-modal',
                    body: `
                        <div class="form-group">
                           ${createUploadSection('exclusive-bg', 'ä¸“å±èƒŒæ™¯', currentBg)}
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { 
                            text: 'ä¿å­˜', 
                            class: 'btn-primary', 
                            handler: async () => {
                                const previewSrc = $('#exclusive-bg-preview').src;
                                const blankGif = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

                                
                                const newBg = (previewSrc.startsWith('data:image') && previewSrc !== blankGif) ? previewSrc : null;

                                entity.chatBackground = newBg;
                                await DBHelper.put(isGroup ? 'groups' : 'contacts', entity);

                                
                                if (appState.currentChatId === chatId) {
                                    await UIManager.applyChatBackground(chatId);
                                }

                                UIManager.hideModal();
                                UIManager.showToast('ä¸“å±èƒŒæ™¯å·²ä¿å­˜ï¼');
                            }
                        }
                    ]
                });
                
                
                const setupUpload = (id) => {
                    const input = $(`#${id}-input`);
                    const preview = $(`#${id}-preview`);
                    const removeBtn = $(`#${id}-remove-btn`);

                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            preview.src = await Utils.fileToBase64(file);
                            preview.style.display = 'block';
                            removeBtn.style.display = 'inline-block';
                        }
                    });

                    removeBtn.addEventListener('click', () => {
                        preview.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; 
                        preview.style.display = 'none';
                        removeBtn.style.display = 'none';
                        input.value = ''; 
                    });
                };
                setupUpload('exclusive-bg');
            },

            async handleChatSettings() {
                
                let chatSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const defaults = {
                    id: 'chatSettings',
                    memoryInterconnection: false,
                    historyLength: 20,
                    showMyNameInGroup: true,
                    showNamesInPrivate: false,
                    bottomBarOffset: false,
                    enterToSend: false,
                    promptTurnFrequency: 1, 
                    activeReplyInterval: 3, 
                };
                if (!chatSettings) {
                    chatSettings = defaults;
                } else {
                    
                    chatSettings = { ...defaults, ...chatSettings };
                }

                
                const createSwitch = (id, label, description, isChecked) => `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
                        <div style="flex-grow: 1;">
                            <label style="margin-bottom: 5px; font-size: 1.1rem;">${label}</label>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 0; line-height: 1.4;">
                                ${description}
                            </p>
                        </div>
                        <div style="flex-shrink: 0; margin-left: 20px;">
                            <label class="switch">
                                <input type="checkbox" id="${id}" ${isChecked ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                `;
                
                
                const createNumberInput = (label, description, displayId, initialValue, unit = '') => `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; margin-top: 15px;">
                        <div style="flex-grow: 1;">
                            <label style="margin-bottom: 5px; font-size: 1.1rem;">${label}</label>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 0; line-height: 1.4;">
                                ${description}
                            </p>
                        </div>
                        <div style="flex-shrink: 0; margin-left: 20px;">
                            <div class="number-input-custom">
                                <button id="${displayId}-minus">-</button>
                                <span id="${displayId}-display">${initialValue}</span>
                                <button id="${displayId}-plus">+</button>
                                ${unit ? `<span style="margin-left: 8px; font-size: 0.9rem; color: var(--text-color-medium);">${unit}</span>` : ''}
                            </div>
                        </div>
                    </div>
                `;


                
                UIManager.showModal({
                    title: 'èŠå¤©è®¾ç½®',
                    body: `
                        <style>.switch{position:relative;display:inline-block;width:52px;height:30px}.switch input{opacity:0;width:0;height:0}.slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:.4s;border-radius:30px}.slider:before{position:absolute;content:"";height:24px;width:24px;left:3px;bottom:3px;background-color:white;transition:.4s;border-radius:50%;box-shadow:0 1px 3px rgba(0,0,0,0.2)}input:checked+.slider{background-color:var(--accent-color)}input:checked+.slider:before{transform:translateX(22px)}</style>
                        ${createSwitch('memory-interconnection-switch', 'è®°å¿†äº’é€š', 'å¼€å¯åï¼Œå¥½å‹ä¼šè·å–ç›¸å…³ç¾¤èŠ+ç§èŠä½œä¸ºè®°å¿†å‚è€ƒï¼Œå¯¹è¯æ›´è¿è´¯ã€‚', chatSettings.memoryInterconnection)}
                        ${createSwitch('show-my-name-in-group-switch', 'ç¾¤èŠæ˜¾ç¤ºè‡ªå·±åå­—', 'å¼€å¯åï¼Œä½ åœ¨ç¾¤èŠä¸­å‘é€çš„æ¶ˆæ¯ä¸Šæ–¹ä¼šæ˜¾ç¤ºä½ çš„åå­—ã€‚', chatSettings.showMyNameInGroup)}
                        ${createSwitch('show-names-in-private-switch', 'ç§èŠæ˜¾ç¤ºåå­—', 'å¼€å¯åï¼Œç§èŠæ—¶åŒæ–¹çš„æ¶ˆæ¯ä¸Šæ–¹éƒ½ä¼šæ˜¾ç¤ºåå­—ã€‚', chatSettings.showNamesInPrivate)}
                        ${createSwitch('bottom-bar-offset-switch', 'åº•éƒ¨çŠ¶æ€æ ä¸Šç§»', 'å¼€å¯åï¼Œä¸ºæ‰‹æœºè‡ªå¸¦çš„åº•éƒ¨å¯¼èˆªæ¡é¢„ç•™ç©ºé—´ï¼Œé˜²æ­¢é®æŒ¡ã€‚', chatSettings.bottomBarOffset)}
                        ${createSwitch('enter-to-send-switch', 'å›è½¦è‡ªåŠ¨å‘é€', 'å¼€å¯åï¼Œåœ¨è¾“å…¥æ¡†å†…æŒ‰å›è½¦é”®å°†ç›´æ¥å‘é€æ¶ˆæ¯ã€‚', chatSettings.enterToSend)}
                        
                        ${createNumberInput('èŠå¤©è®°å½•é•¿åº¦', 'è®¾å®šæ¯æ¬¡è¯·æ±‚AIæ—¶é™„å¸¦çš„å¯¹è¯è½®æ•°ï¼Œå½±å“è®°å¿†å’ŒTokenæ¶ˆè€—ã€‚', 'history-len', chatSettings.historyLength)}
                        ${createNumberInput('æç¤ºè¯å‘é€é¢‘ç‡', 'æ¯Nä¸ªç©å®¶å›åˆå‘é€ä¸€æ¬¡åŒ…å«è‡ªå®šä¹‰æç¤ºè¯çš„å®Œæ•´Promptï¼Œä»¥èŠ‚çœTokenã€‚', 'prompt-freq', chatSettings.promptTurnFrequency)}
                        ${createNumberInput('ä¸»åŠ¨å›å¤é—´éš”', 'å½“è·ç¦»AIä¸Šæ¬¡å›å¤è¶…è¿‡Nå°æ—¶åï¼Œè¿›å…¥èŠå¤©ä¼šè‡ªåŠ¨è§¦å‘AIä¸»åŠ¨å›å¤ã€‚', 'active-reply-interval', chatSettings.activeReplyInterval)}
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const newSettings = {
                                id: 'chatSettings',
                                memoryInterconnection: $('#memory-interconnection-switch').checked,
                                historyLength: parseInt($('#history-len-display').textContent, 10),
                                showMyNameInGroup: $('#show-my-name-in-group-switch').checked,
                                showNamesInPrivate: $('#show-names-in-private-switch').checked,
                                bottomBarOffset: $('#bottom-bar-offset-switch').checked,
                                enterToSend: $('#enter-to-send-switch').checked,
                                promptTurnFrequency: parseInt($('#prompt-freq-display').textContent, 10),
                                activeReplyInterval: parseInt($('#active-reply-interval-display').textContent, 10), 
                            };
                            await DBHelper.put('apiConfig', newSettings);
                            this.applyChatSettings(newSettings); 
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                
                const setupNumberInput = (id) => {
                    const display = $(`#${id}-display`);
                    $(`#${id}-minus`).addEventListener('click', () => {
                        let currentVal = parseInt(display.textContent, 10);
                        if (currentVal > 1) display.textContent = currentVal - 1;
                    });
                    $(`#${id}-plus`).addEventListener('click', () => {
                        let currentVal = parseInt(display.textContent, 10);
                        display.textContent = currentVal + 1;
                    });
                };
                
                setupNumberInput('history-len');
                setupNumberInput('prompt-freq');
                setupNumberInput('active-reply-interval'); 
            },
            
            applyChatSettings(settings) {
                
                appContainer.classList.toggle('bottom-offset-active', settings.bottomBarOffset);
            },
            async handleApiSettings() {
                await AIHandler.loadApiConfig(); 
                const config = AIHandler.apiConfig;
                
                const getApiProviderOptions = () => `
                    <option value="gemini" ${config.provider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                    <option value="siliconflow" ${config.provider === 'siliconflow' ? 'selected' : ''}>SiliconFlow</option>
                    <option value="paioupu" ${config.provider === 'paioupu' ? 'selected' : ''}>æ´¾æ¬§äº‘</option>
                    <option value="volcano" ${config.provider === 'volcano' ? 'selected' : ''}>ç«å±±</option>
                    <option value="custom" ${config.provider === 'custom' ? 'selected' : ''}>è‡ªå®šä¹‰</option>
                `;
                
                UIManager.showModal({
                    title: 'API é…ç½®',
                    body: `
                        <div class="form-group">
                            <label for="api-provider">APIæä¾›å•†</label>
                            <select id="api-provider">${getApiProviderOptions()}</select>
                        </div>
                        <div class="form-group">
                            <label for="api-url">API URL</label>
                            <input type="text" id="api-url" value="${config.url}" placeholder="è¾“å…¥API URL">
                        </div>
                        <div class="form-group">
                            <label for="api-key">API Key</label>
                            <input type="password" id="api-key" value="${config.key}" placeholder="è¾“å…¥APIå¯†é’¥">
                        </div>
                        <div class="form-group">
                            <label for="api-model-select">æ¨¡å‹</label>
                            <select id="api-model-select"></select>
                            <input type="text" id="api-model-input" value="${config.model}" placeholder="è¾“å…¥è‡ªå®šä¹‰æ¨¡å‹åç§°" style="display:none;">
                        </div>
                        <div class="form-group">
                            <label for="temperature">æ¸©åº¦ (0-1)</label>
                            <input type="number" id="temperature" min="0" max="1" step="0.1" value="${config.temperature}">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const newConfig = {
                                provider: $('#api-provider').value,
                                url: $('#api-url').value.trim(),
                                key: $('#api-key').value.trim(),
                                temperature: parseFloat($('#temperature').value)
                            };
                            
                            if (isNaN(newConfig.temperature) || newConfig.temperature < 0 || newConfig.temperature > 1) {
                                newConfig.temperature = 0.7; 
                            }
                            
                            const modelSelect = $('#api-model-select');
                            const modelInput = $('#api-model-input');
                            if (modelInput.style.display !== 'none') {
                                newConfig.model = modelInput.value.trim();
                            } else {
                                newConfig.model = modelSelect.value;
                            }
                            
                            await AIHandler.saveApiConfig(newConfig);
                            UIManager.hideModal();
                            UIManager.showModal({
                                title: "æ“ä½œæˆåŠŸ",
                                body: `<p>APIé…ç½®å·²æˆåŠŸä¿å­˜ï¼<br><br>33ç¥ä½ æ¸¸ç©æ„‰å¿«âŒ¯>á´—oâŒ¯ .áŸ.áŸ</p>`,
                                actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                            });
                        }}
                    ]
                });
                
                
                const updateApiFields = () => {
                    const provider = $('#api-provider').value;
                    const apiUrlInput = $('#api-url');
                    const modelSelect = $('#api-model-select');
                    const modelInput = $('#api-model-input');
                    const currentModel = AIHandler.apiConfig.model;
                    
                    modelSelect.innerHTML = '';
                    
                    const modelOptions = {
                        gemini: [
                            "gemini-2.5-flash", "gemini-2.5-pro", "gemini-1.5-flash-latest", "gemini-1.5-pro-latest"
                        ],
                        siliconflow: [
                            "deepseek-ai/DeepSeek-V3", "Qwen/Qwen2-7B-Instruct", "Qwen/Qwen2-72B-Instruct", "01-ai/Yi-1.5-34B-Chat", "mistralai/Mistral-7B-Instruct-v0.2", "mistralai/Mixtral-8x7B-Instruct-v0.1"
                        ],
                        paioupu: [
                            "deepseek/deepseek-v3"
                        ]
                    };

                    const setOptions = (options) => {
                        modelSelect.innerHTML = options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                        modelSelect.value = options.includes(currentModel) ? currentModel : options[0];
                    };
                    
                    switch (provider) {
                        case 'gemini':
                            apiUrlInput.value = 'https://generativelanguage.googleapis.com/v1beta/models/';
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            setOptions(modelOptions.gemini);
                            break;
                        case 'siliconflow':
                            apiUrlInput.value = 'https://api.siliconflow.cn/v1/chat/completions';
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            setOptions(modelOptions.siliconflow);
                            break;
                        case 'paioupu':
                            apiUrlInput.value = 'https://api.ppinfra.com/v3/openai';
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            setOptions(modelOptions.paioupu);
                            break;
                        case 'volcano':
                            apiUrlInput.value = 'https://ark.cn-beijing.volces.com/api/v3';
                            modelSelect.style.display = 'none';
                            modelInput.style.display = 'block';
                            modelInput.value = currentModel;
                            break;
                        case 'custom':
                            modelSelect.style.display = 'none';
                            modelInput.style.display = 'block';
                            modelInput.value = currentModel;
                            break;
                    }
                };
                
                $('#api-provider').addEventListener('change', updateApiFields);
                updateApiFields(); 
            },
            
            async handleForwardMoment(momentId) {
                const chats = await DBHelper.getAll('chats');
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');

                const recentConversations = chats.filter(c => c.history && c.history.length > 0)
                                                 .sort((a, b) => b.history[b.history.length - 1].timestamp - a.history[a.history.length - 1].timestamp);

                if (recentConversations.length === 0) {
                    UIManager.showModal({
                        title: "è½¬å‘åŠ¨æ€",
                        body: `<p style="text-align: center; color: #aaa; padding: 20px 0;">æœ€è¿‘æ²¡æœ‰æ–°çš„èŠå¤©ä¼šè¯ï¼Œ<br>å»å’Œå¥½å‹ä»¬å¼€å¯ä¸€ä¸ªèŠå¤©çª—å£å§ï¼</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const conversationDetails = recentConversations.map(chat => {
                    let details;
                    if (chat.chatId.startsWith('contact-')) {
                        details = contacts.find(c => c.id === chat.chatId);
                    } else {
                        details = groups.find(g => g.id === chat.chatId);
                    }
                    return details ? { ...details, chatId: chat.chatId } : null;
                }).filter(Boolean);

                const chatListHtml = conversationDetails.map(item => `
                    <label class="member-select-item">
                        <input type="radio" name="forward-target" value="${item.chatId}">
                        <img src="${item.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px; border-radius: 8px;">
                        <span>${item.remark || item.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "è½¬å‘ç»™",
                    body: `<div class="member-select-list" style="max-height: 40vh;">${chatListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                            const selectedRadio = $('input[name="forward-target"]:checked');
                            if (!selectedRadio) {
                                UIManager.showToast("è¯·é€‰æ‹©ä¸€ä¸ªèŠå¤©");
                                return;
                            }
                            const targetChatId = selectedRadio.value;

                            const moment = await DBHelper.get('moments', momentId);
                            const momentAuthor = await this.getMomentAuthor(moment.authorId);
                            
                            const aiContent = await this.buildForwardedMomentAIContent(moment, momentAuthor);

                            const cardData = {
                                momentId: moment.id,
                                authorName: momentAuthor.name,
                                preview: moment.content,
                            };

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: aiContent,
                                type: 'sent',
                                segmentType: 'moment_forward',
                                cardData: cardData
                            };

                            
                            const originalChatId = appState.currentChatId;
                            appState.currentChatId = targetChatId; 
                            await this.handlePlayerSendMessage(message);
                            appState.currentChatId = originalChatId; 

                            UIManager.hideModal();
                            UIManager.showToast(`å·²è½¬å‘ç»™ ${conversationDetails.find(c => c.chatId === targetChatId).name}`);
                        }}
                    ]
                });
            },

            async getMomentAuthor(authorId) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                if (authorId === myProfile.id) {
                    return { name: myProfile.name, avatar: myProfile.avatar };
                }
                const contact = await DBHelper.get('contacts', authorId);
                if (contact) {
                    return { name: contact.name, avatar: contact.avatar };
                }
                return { name: authorId, avatar: Utils.createAvatarDataUrl('#ccc') };
            },

            async buildForwardedMomentAIContent(moment, author) {
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                let commentsText = 'æ— ';
                if (moment.comments && moment.comments.length > 0) {
                    commentsText = '\n' + moment.comments.map(c => {
                        let cAuthorName = 'æœªçŸ¥';
                        if (c.authorId === myProfile.id) {
                            cAuthorName = myProfile.name;
                        } else {
                            const contact = allContacts.find(con => con.id === c.authorId);
                            cAuthorName = contact ? contact.name : c.authorId;
                        }
                        const replyText = c.replyTo ? ` å›å¤ ${c.replyTo}` : '';
                        return `${cAuthorName}${replyText}: ${c.content}`;
                    }).join('\n');
                }

                const imageDescription = moment.images && moment.images.length > 0 
                    ? ` [å›¾ç‰‡ï¼šåŒ…å«${moment.images.length}å¼ å›¾ç‰‡çš„åŠ¨æ€]`
                    : '';
                
                return `<è½¬å‘åŠ¨æ€>
åŠ¨æ€ä½œè€…ï¼š${author.name}
åŠ¨æ€å†…å®¹ï¼š${moment.content}${imageDescription}
åŠ¨æ€æ—¶é—´ï¼š${Utils.formatTimestampSmartly(moment.timestamp)}
ç‚¹èµæƒ…å†µï¼š${moment.likes && moment.likes.length > 0 ? moment.likes.join(', ') : 'æ— '}
è¯„è®ºåŒºï¼š${commentsText}
</è½¬å‘åŠ¨æ€>`;
            },

            async showForwardedMomentDetail(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) {
                    UIManager.showToast("è¯¥åŠ¨æ€å¯èƒ½å·²è¢«åˆ é™¤");
                    return;
                }

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const author = await this.getMomentAuthor(moment.authorId);

                let likesHtml = '';
                if (moment.likes && moment.likes.length > 0) {
                    likesHtml = `<div class="likes-list"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (moment.comments && moment.comments.length > 0) {
                    commentsHtml = moment.comments.map(comment => {
                        let cAuthorName = 'æœªçŸ¥ç”¨æˆ·';
                        if (comment.authorId === myProfile.id) {
                            cAuthorName = myProfile.name;
                        } else {
                            const contact = allContacts.find(c => c.id === comment.authorId);
                            cAuthorName = contact ? contact.name : comment.authorId;
                        }

                        const replyHtml = comment.replyTo 
                            ? `<span class="comment-reply-to"> å›å¤ </span><span class="comment-author">${comment.replyTo}</span>` 
                            : '';
                        return `<div class="comment-item"><span class="comment-author">${cAuthorName}</span>${replyHtml}: ${comment.content}</div>`;
                    }).join('');
                }

                const imagesHtml = moment.images && moment.images.length > 0
                    ? `<div class="post-image-grid">${moment.images.map(src => `<img src="${src}" alt="åŠ¨æ€å›¾ç‰‡">`).join('')}</div>`
                    : '';

                const modalBody = `
                    <div class="moment-detail-wrapper">
                        <div class="post-header">
                            <img src="${author.avatar}" alt="${author.name} å¤´åƒ" class="post-avatar">
                            <div class="post-author-info">
                                <span class="name">${author.name}</span>
                            </div>
                        </div>
                        <div class="post-content-full">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer-full">
                            <span class="timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        </div>
                        ${(likesHtml || commentsHtml) ? `
                        <div class="interactions-section">
                            ${likesHtml}
                            <div class="comments-list">${commentsHtml}</div>
                        </div>
                        ` : ''}
                    </div>
                `;

                UIManager.showModal({
                    title: "æœ‹å‹åœˆåŠ¨æ€",
                    body: modalBody,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

handleClickEffect(e) {
    const pos = appContainer.getBoundingClientRect();
    const x = e.clientX - pos.left;
    const y = e.clientY - pos.top;
    
    
    const ripple = document.createElement('div');
    ripple.className = 'ripple';
    clickEffectLayer.appendChild(ripple);
    
    const rippleSize = 80;
    ripple.style.width = ripple.style.height = `${rippleSize}px`;
    ripple.style.left = `${x - rippleSize / 2}px`;
    ripple.style.top = `${y - rippleSize / 2}px`;
    ripple.addEventListener('animationend', () => {
        ripple.remove();
    });

    
    for (let i = 0; i < 2; i++) {
        const heart = document.createElement('i');
        heart.className = 'fas fa-heart heart';
        clickEffectLayer.appendChild(heart);
        
        heart.style.left = `${x}px`;
        heart.style.top = `${y}px`;
        
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 30 + 10;
        const tx = Math.cos(angle) * distance;
        const ty = (Math.sin(angle) * distance) - 50; 

        heart.style.setProperty('--tx', `${tx}px`);
        heart.style.setProperty('--ty', `${ty}px`);
        heart.style.animationDelay = `${Math.random() * 0.2}s`;
        heart.addEventListener('animationend', () => {
            heart.remove();
        });
    }
}, 

            async handleOpenGroupManagementSidebar(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (group) {
                    UIManager.showGroupManagementSidebar(group);
                }
            },

            async handleOpenFriendManagementSidebar(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (contact) {
                    UIManager.showFriendManagementSidebar(contact);
                }
            },

            async showEditFriendModal(contactId, onSaveCallback = null) { 
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                UIManager.showModal({
                    isPersistent: true, 
                    title: "ä¿®æ”¹å¥½å‹ä¿¡æ¯",
                    body: `
                        <div class="form-group">
                            <label>å¤´åƒ</label>
                            <div class="avatar-uploader">
                                <img src="${contact.avatar}" id="edit-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="edit-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('edit-friend-avatar-input').click()">ä¸Šä¼ æ–°å¤´åƒ</button>
                            </div>
                        </div>
                        <div class="form-group"><label>å§“å (ID, ä¸å¯ä¿®æ”¹)</label><input type="text" value="${contact.name}" disabled></div>
                        <div class="form-group"><label for="edit-friend-remark">å¤‡æ³¨</label><input type="text" id="edit-friend-remark" value="${contact.remark || ''}"></div>
                        <div class="form-group"><label for="edit-friend-gender">æ€§åˆ«</label><select id="edit-friend-gender"><option value="ç”·" ${contact.gender === 'ç”·' ? 'selected' : ''}>ç”·</option><option value="å¥³" ${contact.gender === 'å¥³' ? 'selected' : ''}>å¥³</option><option value="å…¶ä»–" ${contact.gender === 'å…¶ä»–' ? 'selected' : ''}>å…¶ä»–</option></select></div>
                        <div class="form-group"><label for="edit-friend-likes">å–œå¥½</label><textarea id="edit-friend-likes">${contact.likes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-dislikes">åŒæ¶</label><textarea id="edit-friend-dislikes">${contact.dislikes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-habits">ä¹ æƒ¯</label><textarea id="edit-friend-habits">${contact.habits || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-background">èƒŒæ™¯èµ„æ–™</label><textarea id="edit-friend-background">${contact.background || ''}</textarea></div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const updatedContact = {
                                ...contact,
                                avatar: $('#edit-friend-avatar-preview').src,
                                remark: $('#edit-friend-remark').value.trim(),
                                gender: $('#edit-friend-gender').value,
                                likes: $('#edit-friend-likes').value.trim(),
                                dislikes: $('#edit-friend-dislikes').value.trim(),
                                habits: $('#edit-friend-habits').value.trim(),
                                background: $('#edit-friend-background').value.trim()
                            };
                            await DBHelper.put('contacts', updatedContact);
                            chatTitle.textContent = updatedContact.remark || updatedContact.name;
                            UIManager.hideModal();
                            
                            if (typeof onSaveCallback === 'function') {
                                onSaveCallback(updatedContact);
                            } else {
                                UIManager.showFriendManagementSidebar(updatedContact); 
                            }
                        }}
                    ]
                });
                
                $('#edit-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) $('#edit-friend-avatar-preview').src = await Utils.fileToBase64(file);
                });
            },
            async importOpeningScenes(scenes, newEntityId, isGroup) {
                if (!scenes || !Array.isArray(scenes) || scenes.length === 0) return;
                for (const scene of scenes) {
                    const newScene = { ...scene, id: Utils.generateId('scene') };
                    if (isGroup) {
                        newScene.groupId = newEntityId;
                        delete newScene.contactId;
                    } else {
                        newScene.contactId = newEntityId;
                        delete newScene.groupId;
                    }
                    await DBHelper.put('openingScenes', newScene);
                }
            },
            handleOpeningSceneSettings(entityId, isGroup) {
                UIManager.showOpeningSceneModal(entityId, isGroup);
            },


            handleNewOpeningScene(entityId, isGroup) {
                UIManager.showModal({
                    isPersistent: true,
                    title: "æ–°å»ºå¼€åœºç™½",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">å¼€åœºç™½åç§°</label>
                            <input type="text" id="scene-name" placeholder="ä¾‹å¦‚ï¼šåˆæ¬¡è§é¢çš„é—®å€™">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">å¼€åœºç™½å†…å®¹</label>
                            <textarea id="scene-content" rows="6" placeholder="è¯¦ç»†æè¿°å¼€åœºæ—¶çš„æƒ…æ™¯ã€è§’è‰²çš„çŠ¶æ€å’Œç¬¬ä¸€å¥å¯¹è¯ç­‰..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const name = $('#scene-name').value.trim();
                            const content = $('#scene-content').value.trim();
                            if (!name || !content) return;
                            const newScene = { id: Utils.generateId('scene'), name, content };
                            if (isGroup) {
                                newScene.groupId = entityId;
                            } else {
                                newScene.contactId = entityId;
                            }
                            await DBHelper.put('openingScenes', newScene);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleEditOpeningScene(scene, isGroup) {
                UIManager.showModal({
                    isPersistent: true, 
                    title: "ç¼–è¾‘å¼€åœºç™½",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">å¼€åœºç™½åç§°</label>
                            <input type="text" id="scene-name" value="${scene.name}">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">å¼€åœºç™½å†…å®¹</label>
                            <textarea id="scene-content" rows="6">${scene.content}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup) },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const updatedScene = {
                                ...scene,
                                name: $('#scene-name').value.trim(),
                                content: $('#scene-content').value.trim()
                            };
                            await DBHelper.put('openingScenes', updatedScene);
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }}
                    ]
                });
            },

            handleDeleteOpeningScene(sceneId, entityId, isGroup) {
                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¼€åœºç™½å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('openingScenes', sceneId);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleApplyOpeningScene(scene) {
                UIManager.showModal({
                    title: "åº”ç”¨å¼€åœºç™½",
                    body: `<p>åº”ç”¨å¼€åœºç™½å°†ä¼šæ¸…ç©ºå½“å‰èŠå¤©è®°å½•ï¼Œå¹¶ç”±AIæ ¹æ®å¼€åœºç™½å†…å®¹å¼€å§‹æ–°çš„å¯¹è¯ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            const isGroup = !!scene.groupId;
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }},
                        { text: 'ç¡®å®šåº”ç”¨', class: 'btn-primary', handler: async () => {
                            const chatId = scene.groupId || scene.contactId;
                            
                            UIManager.hideSidebar(); 
                            UIManager.hideModal();

                            
                            const chatData = await DBHelper.get('chats', chatId) || { chatId: chatId, history: [] };
                            chatData.history = [];
                            await DBHelper.put('chats', chatData);
                            
                            
                            if (appState.currentChatId === chatId) {
                                await UIManager.refreshChatView();
                            }
                            
                            
                            await AIHandler.handleOpeningSceneRequest(scene);
                        }}
                    ]
                });
            },

            async handleTransferClick(msg) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                let senderContact; 

                
                if (msg.type === 'sent') {
                    
                    senderContact = myProfile;
                } else {
                    
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                
                if (!senderContact) {
                    console.error("æ— æ³•æ‰¾åˆ°è½¬è´¦å‘é€æ–¹ä¿¡æ¯:", msg);
                    UIManager.showToast("æ— æ³•åŠ è½½è½¬è´¦è¯¦æƒ…ï¼Œå‘é€æ–¹ä¿¡æ¯ä¸¢å¤±ã€‚");
                    return;
                }
                
                const isRecipientPlayer = msg.cardData.recipientName === myProfile.name;
                
                UIManager.showModal({
                    title: "è½¬è´¦è¯¦æƒ…",
                    body: `
                        <div style="text-align: center;">
                            <img src="${senderContact.avatar}" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; margin-bottom: 10px;">
                            <h4 style="margin-bottom: 5px;">æ¥è‡ª ${senderContact.remark || senderContact.name} çš„è½¬è´¦</h4>
                            <p style="font-size: 2rem; font-weight: bold; margin: 15px 0;">${msg.cardData.amount}</p>
                            ${msg.cardData.note ? `<p style="color: #888;">å¤‡æ³¨ï¼š${msg.cardData.note}</p>` : ''}
                        </div>
                    `,
                    actions: [
                        { text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { 
                            text: 'æ”¶æ¬¾', 
                            class: `btn-primary`, 
                            handler: async () => {
                                
                                if (!isRecipientPlayer) {
                                     UIManager.showToast('ä½ ä¸æ˜¯è¯¥è½¬è´¦çš„æ”¶æ¬¾å¯¹è±¡');
                                    return;
                                }

                                
                                const chatData = await DBHelper.get('chats', appState.currentChatId);
                                const msgToUpdate = chatData.history.find(m => m.messageId === msg.messageId);
                                if (msgToUpdate) {
                                    msgToUpdate.cardData.isClaimed = true;
                                }
                                
                                const receiptMsg = {
                                    messageId: Utils.generateId('msg'),
                                    timestamp: Date.now(),
                                    type: 'sent',
                                    segmentType: 'transfer-receipt',
                                    content: `${myProfile.name}å·²æ”¶æ¬¾`,
                                    cardData: {
                                        recipientName: myProfile.name,
                                        senderName: senderContact.name,
                                        amount: msg.cardData.amount
                                    }
                                };
                                chatData.history.push(receiptMsg);
                                await DBHelper.put('chats', chatData);

                                
                                const originalBubble = $(`#${msg.messageId} .bubble`);
                                if(originalBubble) originalBubble.classList.add('claimed');
                                UIManager.addMessageToDOM(receiptMsg, myProfile);
                                UIManager.hideModal();
                            }
                        }
                    ]
                });
            },

            async handleRedPacketClick(msg) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                let senderContact; 

                
                if (msg.type === 'sent') {
                    
                    senderContact = myProfile;
                } else {
                    
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                
                if (!senderContact) {
                    console.error("æ— æ³•æ‰¾åˆ°çº¢åŒ…å‘é€æ–¹ä¿¡æ¯:", msg);
                    UIManager.showToast("æ— æ³•åŠ è½½çº¢åŒ…è¯¦æƒ…ï¼Œå‘é€æ–¹ä¿¡æ¯ä¸¢å¤±ã€‚");
                    return;
                }
                
                
                const modalStyle = `
                    <style>
                        .rp-modal-body { text-align: center; padding: 20px 0; }
                        .rp-modal-body img { width: 60px; height: 60px; border-radius: 8px; margin-bottom: 10px; }
                        .rp-modal-body h4 { font-size: 1.2rem; margin-bottom: 5px; }
                        .rp-modal-body p { color: var(--text-color-light); margin-bottom: 30px; }
                        .rp-open-btn {
                            width: 80px; height: 80px; border-radius: 50%;
                            background-color: #F8C34A; color: white;
                            border: 3px solid #F5A623; font-size: 2rem;
                            cursor: pointer; animation: rp-pulse 1.5s infinite;
                            box-shadow: 0 4px 10px rgba(248, 195, 74, 0.5);
                        }
                        @keyframes rp-pulse { 0% { transform: scale(0.95); } 70% { transform: scale(1.05); } 100% { transform: scale(0.95); } }
                        .rp-amount { font-size: 2.5rem; font-weight: bold; margin-bottom: 10px; }
                        .rp-claimed-info { font-size: 0.9rem; color: var(--text-color-medium); }
                    </style>
                `;

                
                UIManager.showModal({
                    title: " ", 
                    body: `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-pre-claim">
                            <img src="${senderContact.avatar}" alt="avatar">
                            <h4>${senderContact.remark || senderContact.name} çš„çº¢åŒ…</h4>
                            <p>${msg.cardData.title}</p>
                            <button class="rp-open-btn">å¼€</button>
                        </div>
                    `,
                    actions: [{ text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });

                
                modalContentWrapper.querySelector('.rp-open-btn').onclick = async () => {
                    

                    
                    if (msg.type === 'sent') {
                        UIManager.showToast("ä¸èƒ½é¢†å–è‡ªå·±å‘çš„çº¢åŒ…å“¦");
                        return;
                    }
                    
                    const isGroupChat = appState.currentChatId.startsWith('group-');
                    let receivedAmount = 0;
                    
                    if (isGroupChat) {
                        
                        if (msg.cardData.count === 1) {
                            receivedAmount = msg.cardData.amount;
                        } else {
                            
                            const remainingAmount = msg.cardData.amount;
                            const remainingCount = msg.cardData.count - msg.cardData.claimedBy.length;
                            const maxReceive = remainingAmount - (remainingCount - 1) * 0.01;
                            receivedAmount = Math.random() * (maxReceive - 0.01) + 0.01;
                        }
                    } else {
                        receivedAmount = msg.cardData.amount;
                    }
                    
                    
                    const chatData = await DBHelper.get('chats', appState.currentChatId);
                    const msgToUpdate = chatData.history.find(m => m.messageId === msg.messageId);
                    if (msgToUpdate) {
                        msgToUpdate.cardData.isClaimedByPlayer = true;
                        msgToUpdate.cardData.claimedBy.push(myProfile.id);
                    }
                    await DBHelper.put('chats', chatData);

                    
                    const originalBubble = $(`#${msg.messageId} .bubble`);
                    if(originalBubble) originalBubble.classList.add('claimed');

                    
                    const notice = document.createElement('div');
                    notice.className = 'time-divider';
                    notice.textContent = `${myProfile.name} é¢†å–äº† ${senderContact.remark || senderContact.name} çš„çº¢åŒ…`;
                    chatArea.appendChild(notice);
                    chatArea.scrollTop = chatArea.scrollHeight;
                    
                    
                    const modalBody = modalContentWrapper.querySelector('.modal-body');
                    modalBody.innerHTML = `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-post-claim">
                            <p class="rp-amount">ï¿¥${receivedAmount.toFixed(2)}</p>
                            <p class="rp-claimed-info">å·²å­˜å…¥é›¶é’±ï¼Œå¯ç›´æ¥ä½¿ç”¨</p>
                        </div>
                    `;
                };
            },

            async handleInviteMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                
                const availableFriends = allContacts.filter(c => !group.members.includes(c.id));

                if (availableFriends.length === 0) {
                    UIManager.showModal({
                        title: "é‚€è¯·æˆå‘˜",
                        body: `<p>æ²¡æœ‰å¯é‚€è¯·çš„å¥½å‹äº†ï¼Œæ‰€æœ‰å¥½å‹éƒ½å·²åœ¨ç¾¤èŠä¸­ã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const memberListHtml = availableFriends.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="invite-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é‚€è¯·æ–°æˆå‘˜",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'é‚€è¯·', class: 'btn-primary', handler: async () => {
                            const newMemberIds = [...$$('input[name="invite-members"]:checked')].map(cb => cb.value);
                            if (newMemberIds.length === 0) return;

                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const invitedNames = (await Promise.all(newMemberIds.map(id => DBHelper.get('contacts', id)))).map(c => c.remark || c.name).join('ã€');
                            
                            
                            group.members.push(...newMemberIds);
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} é‚€è¯· ${invitedNames} åŠ å…¥ç¾¤èŠ`,
                                timestamp: Date.now(),
                                type: 'received', 
                                segmentType: 'system',
                                forAi: true, 
                            };

                            
                            const chatData = await DBHelper.get('chats', groupId) || { chatId: groupId, history: [] };
                            chatData.history.push(systemMessage);
                            await DBHelper.put('chats', chatData);

                            if (appState.currentChatId === groupId) {
                                await UIManager.refreshChatView(); 
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleRemoveMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');

                const currentAiMembers = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);

                if (currentAiMembers.length <= 1) {
                    UIManager.showModal({
                        title: "ç§»é™¤æˆå‘˜",
                        body: `<p>ç¾¤èŠä¸­è‡³å°‘éœ€è¦ä¿ç•™ä¸€åå¥½å‹ï¼Œæ— æ³•å†ç§»é™¤äº†ã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }
                
                const memberListHtml = currentAiMembers.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="remove-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "ç§»é™¤ç¾¤æˆå‘˜",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç§»é™¤', class: 'btn-danger', handler: async () => {
                            const idsToRemove = [...$$('input[name="remove-members"]:checked')].map(cb => cb.value);
                            if (idsToRemove.length === 0) return;

                            if (idsToRemove.length >= currentAiMembers.length) {
                                UIManager.showModal({ title: "æ“ä½œæ— æ•ˆ", body: `<p>ä¸èƒ½å°†æ‰€æœ‰å¥½å‹éƒ½ç§»å‡ºç¾¤èŠï¼Œè‡³å°‘è¦ä¿ç•™ä¸€ä½å“¦ã€‚</p>`, actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => this.handleRemoveMembers(groupId) }] });
                                return;
                            }
                            
                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const removedNames = currentAiMembers.filter(c => idsToRemove.includes(c.id)).map(c => c.remark || c.name).join('ã€');

                            
                            group.members = group.members.filter(id => !idsToRemove.includes(id));
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} å°† ${removedNames} ç§»å‡ºç¾¤èŠ`,
                                timestamp: Date.now(),
                                type: 'received',
                                segmentType: 'system',
                                forAi: true, 
                            };
                            
                             
                            const chatData = await DBHelper.get('chats', groupId) || { chatId: groupId, history: [] };
                            chatData.history.push(systemMessage);
                            await DBHelper.put('chats', chatData);

                            if (appState.currentChatId === groupId) {
                                await UIManager.refreshChatView(); 
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: 'æœªåˆ†ç±»', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">æ­¤æ–‡ä»¶å¤¹ä¸ºç©º</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="åˆ é™¤æ–‡ä»¶å¤¹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? 'æ˜¾æ€§' : 'éšæ€§'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">æŸ¥çœ‹</button>
                            <button class="action-btn" data-action="edit-prompt">ä¿®æ”¹</button>
                            <button class="action-btn" data-action="delete-prompt">åˆ é™¤</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: 'æœªåˆ†ç±»', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">æ­¤æ–‡ä»¶å¤¹ä¸ºç©º</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="åˆ é™¤æ–‡ä»¶å¤¹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? 'æ˜¾æ€§' : 'éšæ€§'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">æŸ¥çœ‹</button>
                            <button class="action-btn" data-action="edit-prompt">ä¿®æ”¹</button>
                            <button class="action-btn" data-action="delete-prompt">åˆ é™¤</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },


            async handleNewPrompt(folderId = 'unclassified') {
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${folderId === 'unclassified' ? 'selected' : ''}>æœªåˆ†ç±»</option>` +
                    folders.map(f => `<option value="${f.id}" ${folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');

                UIManager.showModal({
                    isPersistent: true,
                    title: "æ–°å»ºæç¤ºè¯",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">åç§° (æ–‡ä»¶å¤¹å†…å”¯ä¸€)</label>
                            <input type="text" id="prompt-name-input" placeholder="ä¾‹å¦‚ï¼šæ–‡é£-å¤é£">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">æ‰€å±æ–‡ä»¶å¤¹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>ç±»å‹</label>
                            <select id="prompt-type-select">
                                <option value="explicit">æ˜¾æ€§ (æ€»æ˜¯è§¦å‘)</option>
                                <option value="implicit">éšæ€§ (å…³é”®è¯è§¦å‘)</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:none;">
                            <label for="prompt-keywords-input">å…³é”®è¯ (ç”¨ä¸­/è‹±æ–‡é€—å·éš”å¼€)</label>
                            <input type="text" id="prompt-keywords-input" placeholder="ä¾‹å¦‚ï¼šä½ å¥½,hello,åœ¨å—">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">æç¤ºè¯å†…å®¹</label>
                            <textarea id="prompt-content-input" rows="5" placeholder="è¾“å…¥ä½ çš„æç¤ºè¯..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) {
                                return UIManager.showToast("æç¤ºè¯åç§°ä¸èƒ½ä¸ºç©º");
                            }

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`åç§° "${name}" åœ¨è¯¥æ–‡ä»¶å¤¹ä¸­å·²å­˜åœ¨`);
                            }
                            
                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|ï¼Œ/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }

                            const newPrompt = {
                                id: Utils.generateId('prompt'),
                                createdAt: Date.now(),
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                                isActive: true,
                            };
                            await DBHelper.put('prompts', newPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async handleEditPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${prompt.folderId === 'unclassified' ? 'selected' : ''}>æœªåˆ†ç±»</option>` +
                    folders.map(f => `<option value="${f.id}" ${prompt.folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');
                
                let keywordsString = '';
                if(prompt.type === 'implicit') {
                    try {
                        const keywordsArray = JSON.parse(prompt.keywords);
                        if (Array.isArray(keywordsArray)) keywordsString = keywordsArray.join(', ');
                    } catch(e) {}
                }

                UIManager.showModal({
                    isPersistent: true,
                    title: "ä¿®æ”¹æç¤ºè¯",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">åç§° (æ–‡ä»¶å¤¹å†…å”¯ä¸€)</label>
                            <input type="text" id="prompt-name-input" value="${prompt.name}">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">æ‰€å±æ–‡ä»¶å¤¹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>ç±»å‹</label>
                            <select id="prompt-type-select">
                                <option value="explicit" ${prompt.type === 'explicit' ? 'selected' : ''}>æ˜¾æ€§</option>
                                <option value="implicit" ${prompt.type === 'implicit' ? 'selected' : ''}>éšæ€§</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:${prompt.type === 'implicit' ? 'block' : 'none'};">
                            <label for="prompt-keywords-input">å…³é”®è¯ (ç”¨ä¸­/è‹±æ–‡é€—å·éš”å¼€)</label>
                            <input type="text" id="prompt-keywords-input" value="${keywordsString}" placeholder="ä¾‹å¦‚ï¼šä½ å¥½,hello,åœ¨å—">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">æç¤ºè¯å†…å®¹</label>
                            <textarea id="prompt-content-input" rows="5">${prompt.content}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) return UIManager.showToast("æç¤ºè¯åç§°ä¸èƒ½ä¸ºç©º");

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId && p.id !== promptId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`åç§° "${name}" åœ¨è¯¥æ–‡ä»¶å¤¹ä¸­å·²å­˜åœ¨`);
                            }

                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|ï¼Œ/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }
                            
                            const updatedPrompt = {
                                ...prompt,
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                            };
                            await DBHelper.put('prompts', updatedPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async viewPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                UIManager.showModal({
                    title: `æŸ¥çœ‹: ${prompt.name}`,
                    body: `<div class="details-section" style="margin-top:0;"><p style="max-height: 400px;">${prompt.content}</p></div>`,
                    actions: [{text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
            },
            
            confirmDeletePrompt(promptId) {
                UIManager.showModal({
                    title: 'ç¡®è®¤åˆ é™¤',
                    body: '<p>ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæç¤ºè¯å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ¢å¤ã€‚</p>',
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('prompts', promptId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async togglePromptState(promptId, isActive) {
                const prompt = await DBHelper.get('prompts', promptId);
                prompt.isActive = isActive;
                await DBHelper.put('prompts', prompt);
                
                
                const promptCard = $(`#prompts-page-content .prompt-card[data-prompt-id="${promptId}"]`);
                if (promptCard) {
                    promptCard.classList.toggle('inactive', !isActive);
                }
            },

            handleNewPromptFolder() {
                UIManager.showModal({
                    title: "æ–°å»ºæ–‡ä»¶å¤¹",
                    body: `
                        <div class="form-group">
                            <label for="folder-name-input">æ–‡ä»¶å¤¹åç§° (ä¸å¯é‡å¤)</label>
                            <input type="text" id="folder-name-input" placeholder="ä¾‹å¦‚ï¼šä¸–ç•Œè§‚è®¾å®š">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ›å»º', class: 'btn-primary', handler: async () => {
                            const name = $('#folder-name-input').value.trim();
                            if (!name) return;
                            const existing = await DBHelper.getAll('promptFolders', 'name');
                            if (existing.some(f => f.name === name)) return alert('æ–‡ä»¶å¤¹åç§°å·²å­˜åœ¨');

                            const newFolder = {
                                id: Utils.generateId('folder'),
                                createdAt: Date.now(),
                                name: name,
                                isActive: true
                            };
                            await DBHelper.put('promptFolders', newFolder);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async toggleFolderState(folderId, isActive) {
                const folder = await DBHelper.get('promptFolders', folderId);
                folder.isActive = isActive;
                await DBHelper.put('promptFolders', folder);

                const promptsInFolder = (await DBHelper.getAll('prompts')).filter(p => p.folderId === folderId);
                for (const prompt of promptsInFolder) {
                    prompt.isActive = isActive;
                    await DBHelper.put('prompts', prompt);
                }
                this.renderPromptsPage();
            },
            
            confirmDeleteFolder(folderId) {
                UIManager.showModal({
                    title: 'ç¡®è®¤åˆ é™¤æ–‡ä»¶å¤¹',
                    body: '<p>åˆ é™¤æ–‡ä»¶å¤¹å°†åŒæ—¶åˆ é™¤å…¶ä¸­æ‰€æœ‰çš„æç¤ºè¯ï¼Œä¸”æ— æ³•æ¢å¤ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>',
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            
                            const prompts = (await DBHelper.getAll('prompts')).filter(p => p.folderId === folderId);
                            for (const prompt of prompts) {
                                await DBHelper.delete('prompts', prompt.id);
                            }
                            
                            await DBHelper.delete('promptFolders', folderId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },

            
            
            async showBindingModal(chatId) {
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const boundFolderIds = chatEntity.boundPromptFolderIds || [];
                const allFolders = await DBHelper.getAll('promptFolders');
                
                const boundFolders = allFolders.filter(f => boundFolderIds.includes(f.id));
                let boundFoldersHtml = boundFolders.map(f => `
                    <div class="bound-folder-card">
                        <i class="fas fa-folder-open"></i>
                        <span>${f.name}</span>
                    </div>
                `).join('');
                if (boundFolders.length === 0) {
                    boundFoldersHtml = `<p style="text-align:center; color:#aaa; padding: 20px 0;">æœªç»‘å®šä»»ä½•æç¤ºè¯æ–‡ä»¶å¤¹</p>`;
                }
                
                const modalBody = `
                    <div class="binding-modal-header">
                        <h2>å·²ç»‘å®šæ–‡ä»¶å¤¹</h2>
                        <button id="open-folder-selection-btn" title="ç®¡ç†ç»‘å®š"><i class="fas fa-link"></i></button>
                    </div>
                    <div id="bound-folders-list">${boundFoldersHtml}</div>
                `;

                UIManager.showModal({
                    title: "ç»‘å®šæç¤ºè¯",
                    body: modalBody,
                    actions: [{text: 'å®Œæˆ', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
                
                
                modalContentWrapper.classList.add('binding-modal-content');
                
                $('#open-folder-selection-btn').onclick = () => this.showFolderSelectionModal(chatId, boundFolderIds);

                
                const originalHide = UIManager.hideModal;
                UIManager.hideModal = () => {
                    modalContentWrapper.classList.remove('binding-modal-content');
                    originalHide.call(UIManager);
                    UIManager.hideModal = originalHide; 
                };
            },

            async showFolderSelectionModal(chatId, currentlyBoundIds) {
                const allFolders = await DBHelper.getAll('promptFolders');
                const folderListHtml = allFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-folder" value="${f.id}" ${currentlyBoundIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦ç»‘å®šçš„æ–‡ä»¶å¤¹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.showBindingModal(chatId) },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-folder"]:checked')].map(cb => cb.value);
                            const isGroup = chatId.startsWith('group-');
                            const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                            chatEntity.boundPromptFolderIds = selectedIds;
                            await DBHelper.put(isGroup ? 'groups' : 'contacts', chatEntity);
                            this.showBindingModal(chatId); 
                        }}
                    ]
                });
            },
            handleSimulatedImageSend() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                const networkFallbackImage = 'https://z.wiki/autoupload/20240328/LV9Y.iShot_2024-03-28_22.38.16.png'; 
                
                UIManager.showModal({
                    isPersistent: true,
                    title: "å‘é€å›¾æ–‡æ¶ˆæ¯",
                    body: `
                        <div class="form-group">
                            <label>ä¸Šä¼ å›¾ç‰‡ (é€‰å¡«)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultPlaceholderSvg}" id="sim-image-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                <input type="file" id="sim-image-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('sim-image-input').click()">é€‰æ‹©å›¾ç‰‡</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="sim-image-desc">å›¾ç‰‡æè¿° (å¿…å¡«, AIä¼šçœ‹åˆ°)</label>
                            <textarea id="sim-image-desc" rows="3" placeholder="è¯·è¯¦ç»†æè¿°å›¾ç‰‡å†…å®¹ï¼ŒAIå°†æ ¹æ®æ­¤æè¿°è¿›è¡Œå›åº”..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                            const description = $('#sim-image-desc').value.trim();
                            if (!description) {
                                return UIManager.showToast('å›¾ç‰‡æè¿°ä¸èƒ½ä¸ºç©º');
                            }
                            
                            let finalImageSrc = $('#sim-image-preview').src;
                            
                            if (finalImageSrc === defaultPlaceholderSvg) {
                                finalImageSrc = networkFallbackImage;
                            }
                            
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[å›¾æ–‡] ${description}`,
                                type: 'sent',
                                segmentType: 'image_simulated',
                                cardData: {
                                    imageSrc: finalImageSrc,
                                    description: description
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                $('#sim-image-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#sim-image-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },
            async handleNewMoment() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                 UIManager.showModal({
                    isPersistent: true,
                    title: "å‘å¸ƒåŠ¨æ€",
                    body: `
                        <div class="form-group">
                            <label for="new-moment-content">æ­¤åˆ»çš„æƒ³æ³•...</label>
                            <textarea id="new-moment-content" rows="5"></textarea>
                        </div>
                        <div class="form-group">
                            <label>ä¸Šä¼ å›¾ç‰‡ (å¯é€‰, æœ€å¤š9å¼ )</label>
                             <div class="avatar-uploader">
                                <div id="new-moment-images-preview" style="display:flex; flex-wrap:wrap; gap:10px;"></div>
                                <input type="file" id="new-moment-images-input" accept="image/*" multiple style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('new-moment-images-input').click()">é€‰æ‹©å›¾ç‰‡</button>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘å¸ƒ', class: 'btn-primary', handler: async () => {
                            const content = $('#new-moment-content').value.trim();
                            const imagesPreview = $$('#new-moment-images-preview img');
                            const images = Array.from(imagesPreview).map(img => img.src);

                            if (!content && images.length === 0) {
                                return UIManager.showToast("åŠ¨æ€å†…å®¹å’Œå›¾ç‰‡ä¸èƒ½éƒ½ä¸ºç©ºå“¦");
                            }
                            
                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const newMoment = {
                                id: Utils.generateId('moment'),
                                circleId: appState.currentCircleId,
                                authorId: myProfile.id,
                                content: content,
                                images: images,
                                timestamp: Date.now(),
                                comments: []
                            };

                            await DBHelper.put('moments', newMoment);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage(); 
                            
                            
                            AIHandler.handleMomentsCommentRequest(newMoment.id);
                        }}
                    ]
                });
                
                $('#new-moment-images-input').addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files).slice(0, 9); 
                    const previewContainer = $('#new-moment-images-preview');
                    previewContainer.innerHTML = '';
                    for (const file of files) {
                        const base64 = await Utils.fileToBase64(file);
                        const img = document.createElement('img');
                        img.src = base64;
                        img.style.width = '60px';
                        img.style.height = '60px';
                        img.style.objectFit = 'cover';
                        img.style.borderRadius = '8px';
                        previewContainer.appendChild(img);
                    }
                });
            },

            async handlePlayerLike(momentId) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return;

                
                if (!moment.likes) {
                    moment.likes = [];
                }

                const playerLikeIndex = moment.likes.indexOf(myProfile.name);

                if (playerLikeIndex > -1) {
                    
                    moment.likes.splice(playerLikeIndex, 1);
                } else {
                    
                    moment.likes.push(myProfile.name);
                }

                await DBHelper.put('moments', moment);

                
                const postElement = $(`[data-moment-id="${momentId}"]`);
                if (!postElement) return;

                const likeBtn = postElement.querySelector('[data-action="like"]');
                const interactionsContainer = postElement.querySelector('.post-interactions');
                const likesContainer = postElement.querySelector('.post-likes');
                const playerHasLiked = playerLikeIndex === -1; 

                
                likeBtn.classList.toggle('liked', playerHasLiked);

                
                if (moment.likes.length > 0) {
                    likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    interactionsContainer.style.display = 'block';
                } else {
                    likesContainer.innerHTML = '';
                    
                    if (moment.comments.length === 0) {
                        interactionsContainer.style.display = 'none';
                    }
                }
            },

            toggleCommentInput(postElement, replyToAuthorName = null) {
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const inputField = inputWrapper.querySelector('input');
                
                
                if (inputWrapper.classList.contains('active') && inputWrapper.dataset.replyTo === (replyToAuthorName || '')) {
                    inputWrapper.classList.remove('active');
                    inputWrapper.dataset.replyTo = '';
                    inputField.placeholder = 'è¯„è®º...';
                    return;
                }

                inputWrapper.classList.add('active');
                postElement.querySelector('.post-interactions').style.display = 'block';
                
                if (replyToAuthorName) {
                    inputField.placeholder = `å›å¤ @${replyToAuthorName}:`;
                    inputWrapper.dataset.replyTo = replyToAuthorName;
                } else {
                    inputField.placeholder = 'è¯„è®º...';
                    inputWrapper.dataset.replyTo = '';
                }
                
                inputField.focus();
            },

            async handlePlayerComment(momentId) {
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const input = inputWrapper.querySelector('input');
                const content = input.value.trim();

                if (!content) return;

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const moment = await DBHelper.get('moments', momentId);

                const newComment = {
                    authorId: myProfile.id,
                    content: content,
                    timestamp: Date.now()
                };

                
                const replyTo = inputWrapper.dataset.replyTo;
                if (replyTo) {
                    newComment.replyTo = replyTo;
                }

                if (!moment.comments) moment.comments = [];
                moment.comments.push(newComment);
                await DBHelper.put('moments', moment);

                
                const commentsList = postElement.querySelector('.post-comments-list');
                const commentDiv = document.createElement('div');
                commentDiv.className = 'post-comment-item';
                const replyHtml = replyTo ? `<span class="comment-reply-to"> å›å¤ </span><span class="comment-author">${replyTo}:</span>` : ':';
                commentDiv.innerHTML = `<span class="comment-author" style="color: #EDD4D8;">${myProfile.name}</span>${replyHtml} ${content}`;
                commentsList.appendChild(commentDiv);

                
                input.value = '';
                input.placeholder = 'è¯„è®º...';
                inputWrapper.dataset.replyTo = '';
                inputWrapper.classList.remove('active');

                
                AIHandler.handleMomentsPlayerCommentResponse(momentId, newComment);
            },

            handleMomentCommentInteractionStart(e, type) {
                const commentItem = e.target.closest('.post-comment-item');
                if (!commentItem) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) existingButton.remove();
                    this.showCommentOptions(commentItem);
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            showCommentOptions(commentItem) {
                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';
                wrapper.style.bottom = 'auto';
                wrapper.style.top = 'calc(100% + 2px)';

                wrapper.innerHTML = `<button class="retract-btn" data-action="delete-comment"><i class="fas fa-trash"></i> åˆ é™¤</button>`;
                
                wrapper.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;
                    if (action === 'delete-comment') {
                        const momentId = commentItem.closest('.moments-post').dataset.momentId;
                        const commentIndex = Array.from(commentItem.parentNode.children).indexOf(commentItem);
                        this.confirmDeleteComment(momentId, commentIndex, commentItem);
                    }
                    wrapper.remove();
                });

                commentItem.style.position = 'relative';
                commentItem.appendChild(wrapper);
                setTimeout(() => wrapper.classList.add('show'), 10);
                
                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async confirmDeleteComment(momentId, commentIndex, commentElement) {
                const moment = await DBHelper.get('moments', momentId);
                const comment = moment?.comments?.[commentIndex];
                if (!comment) return;

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');
                let authorName = "æœªçŸ¥ç”¨æˆ·";
                if(comment.authorId === myProfile.id) {
                    authorName = myProfile.name;
                } else {
                    const contact = allContacts.find(c => c.id === comment.authorId);
                    authorName = contact ? (contact.remark || contact.name) : (comment.authorId || 'æœªçŸ¥ç”¨æˆ·');
                }

                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `
                        <p>ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ</p>
                        <div style="background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.9rem; color: var(--text-color-medium);">
                            <strong>${authorName}:</strong> ${comment.content}
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            moment.comments.splice(commentIndex, 1);
                            await DBHelper.put('moments', moment);
                            commentElement.remove();
                            UIManager.showToast("è¯„è®ºå·²åˆ é™¤");
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleSwitchCircle() {
                const circles = await DBHelper.getAll('circles');
                if (circles.length <= 1) {
                    return UIManager.showToast("æ²¡æœ‰å…¶ä»–åœˆå­å¯ä»¥åˆ‡æ¢");
                }
                UIManager.showBottomSheet({
                    title: 'åˆ‡æ¢åœˆå­',
                    items: circles.map(c => ({ value: c.id, text: c.name })),
                    onSelect: async (value, text) => {
                        await UIManager.renderMomentsPage(value);
                        UIManager.hideSidebar();
                    }
                });
            },

            async handleViewCircleInfo() {
                 const circle = await DBHelper.get('circles', appState.currentCircleId);
                 if (!circle) return;

                 const allContacts = await DBHelper.getAll('contacts');
                 const memberNames = circle.memberIds.map(id => allContacts.find(c => c.id === id)?.name || 'æœªçŸ¥å¥½å‹').join('ã€');
                 const extraNames = circle.extraMembers || 'æ— ';
                 const boundFolders = (await DBHelper.getAll('promptFolders')).filter(f => circle.boundPromptFolderIds.includes(f.id));
                 const boundFolderNames = boundFolders.map(f => f.name).join('ã€') || 'æ— ';

                 UIManager.showModal({
                    title: "åœˆå­ä¿¡æ¯",
                    body: `
                        <div class="details-card">
                            <div class="details-header">
                                <img src="${circle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png'}" class="avatar" style="border-radius: 8px;">
                                <div class="details-info">
                                    <div class="name">${circle.name}</div>
                                </div>
                            </div>
                        </div>
                        <div class="details-card">
                            <div class="details-section">
                                <div class="details-section-title">åœˆå†…å¥½å‹</div>
                                <p style="max-height: 80px;">${memberNames}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">é¢å¤–å¥½å‹</div>
                                <p>${extraNames}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">ç»‘å®šæç¤ºè¯</div>
                                <p>${boundFolderNames}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                 });
            },

            async handleAddCircle() {
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');
                if (allContacts.length === 0) {
                    return UIManager.showToast("é€šè®¯å½•ä¸­è¿˜æ²¡æœ‰å¥½å‹ï¼Œæ— æ³•åˆ›å»ºåœˆå­ã€‚");
                }
                
                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}"><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}"><span>${f.name}</span></label>`).join('');

                UIManager.showModal({
                    title: "æ–°å¢åœˆå­",
                    body: `
                        <div class="form-group"><label for="circle-name-input">åœˆå­åç§°</label><input type="text" id="circle-name-input"></div>
                        <div class="form-group"><label>åœˆå†…å¥½å‹ (è‡³å°‘é€‰1ä¸ª)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">é¢å¤–å¥½å‹ (é€‰å¡«, é€—å·éš”å¼€)</label><input type="text" id="circle-extra-input" placeholder="ä¸‰ä¸‰,å…¥å…¥,vv"></div>
                        <div class="form-group"><label>ç»‘å®šæç¤ºè¯æ–‡ä»¶å¤¹ (å¯é€‰)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ›å»º', class: 'btn-primary', handler: async () => {
                            const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("åœˆå­åç§°ä¸èƒ½ä¸ºç©º");
                            
                            const existing = await DBHelper.getAll('circles', 'name');
                            if(existing.some(c => c.name === name)) return UIManager.showToast("è¯¥åœˆå­åç§°å·²å­˜åœ¨");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("è‡³å°‘é€‰æ‹©ä¸€åå¥½å‹");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);

                            const newCircle = {
                                id: Utils.generateId('circle'),
                                name: name,
                                memberIds: memberIds,
                                extraMembers: $('#circle-extra-input').value.trim(),
                                boundPromptFolderIds: boundPromptFolderIds,
                                backgroundImage: null,
                                createdAt: Date.now(),
                                lastRefreshed: 0
                            };

                            await DBHelper.put('circles', newCircle);
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage(newCircle.id); 
                        }}
                    ]
                });
            },

            async handleEditCircle(circleId) {
                if (!circleId) return UIManager.showToast("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåœˆå­");
                const circle = await DBHelper.get('circles', circleId);
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');

                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}" ${circle.memberIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}" ${circle.boundPromptFolderIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');

                 UIManager.showModal({
                    title: "ä¿®æ”¹åœˆå­",
                    body: `
                        <div class="form-group"><label for="circle-name-input">åœˆå­åç§°</label><input type="text" id="circle-name-input" value="${circle.name}"></div>
                        <div class="form-group"><label>åœˆå†…å¥½å‹ (è‡³å°‘é€‰1ä¸ª)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">é¢å¤–å¥½å‹ (é€‰å¡«, é€—å·éš”å¼€)</label><input type="text" id="circle-extra-input" value="${circle.extraMembers || ''}"></div>
                        <div class="form-group"><label>ç»‘å®šæç¤ºè¯æ–‡ä»¶å¤¹ (å¯é€‰)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                             const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("åœˆå­åç§°ä¸èƒ½ä¸ºç©º");
                            
                            const existing = (await DBHelper.getAll('circles', 'name')).filter(c => c.id !== circleId);
                            if(existing.some(c => c.name === name)) return UIManager.showToast("è¯¥åœˆå­åç§°å·²å­˜åœ¨");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("è‡³å°‘é€‰æ‹©ä¸€åå¥½å‹");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);
                            
                            const updatedCircle = { ...circle, name, memberIds, boundPromptFolderIds, extraMembers: $('#circle-extra-input').value.trim() };
                            await DBHelper.put('circles', updatedCircle);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                });
            },

            async handleDeleteCircle() {
                const circles = await DBHelper.getAll('circles');
                 if (circles.length === 0) return UIManager.showToast("æ²¡æœ‰å¯åˆ é™¤çš„åœˆå­");

                const circlesHtml = circles.map(c => `<label class="member-select-item"><input type="checkbox" name="delete-circle" value="${c.id}"><span>${c.name}</span></label>`).join('');
                 UIManager.showModal({
                    title: "åˆ é™¤åœˆå­",
                    body: `<p style="margin-bottom:10px;">é€‰æ‹©è¦åˆ é™¤çš„åœˆå­ï¼ˆå°†åŒæ—¶åˆ é™¤åœˆå­ä¸‹çš„æ‰€æœ‰åŠ¨æ€ï¼‰ï¼š</p><div class="member-select-list">${circlesHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            const idsToDelete = [...$$('input[name="delete-circle"]:checked')].map(cb => cb.value);
                            if (idsToDelete.length === 0) return;

                            for (const id of idsToDelete) {
                                await DBHelper.delete('circles', id);
                                const momentsToDelete = (await DBHelper.getAll('moments')).filter(m => m.circleId === id);
                                for (const moment of momentsToDelete) {
                                    await DBHelper.delete('moments', moment.id);
                                }
                            }
                            
                            if (idsToDelete.includes(appState.currentCircleId)) {
                                appState.currentCircleId = null; 
                            }
                            
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                 });
            },

            async handleExportPrompts() {
                const folders = await DBHelper.getAll('promptFolders');
                if (folders.length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯å¯¼å‡ºçš„æ–‡ä»¶å¤¹");
                }
                const folderListHtml = folders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="export-folder" value="${f.id}">
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦å¯¼å‡ºçš„æ–‡ä»¶å¤¹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å¯¼å‡º', class: 'btn-primary', handler: async () => {
                            const selectedFolderIds = [...$$('input[name="export-folder"]:checked')].map(cb => cb.value);
                            if (selectedFolderIds.length === 0) {
                                return UIManager.showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹");
                            }

                            const allPrompts = await DBHelper.getAll('prompts');
                            
                            
                            let filenamePart;
                            if (selectedFolderIds.length === 1) {
                                const folder = folders.find(f => f.id === selectedFolderIds[0]);
                                filenamePart = folder ? folder.name : 'æœªçŸ¥æ–‡ä»¶å¤¹';
                            } else {
                                filenamePart = 'å¤šä¸ªæ–‡ä»¶å¤¹_æç¤ºè¯å¯¼å‡º';
                            }
                            const finalFilename = `${filenamePart}_${new Date().toISOString().slice(0,10)}.json`;
                            
                            
                            const foldersToExport = folders.filter(f => selectedFolderIds.includes(f.id));
                            const promptsToExport = allPrompts.filter(p => selectedFolderIds.includes(p.folderId));
                            
                            const exportData = {
                                folders: foldersToExport,
                                prompts: promptsToExport
                            };
                            
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], {type: "application/json"});
                            const url = URL.createObjectURL(blob);
                            
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = finalFilename; 
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            handleImportPrompts() {
                const fileInput = $('#import-prompts-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const importedData = JSON.parse(event.target.result);
                            
                            if (!importedData.folders || !importedData.prompts) {
                                return UIManager.showToast("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®");
                            }
                            
                            const existingFolders = await DBHelper.getAll('promptFolders');
                            let importedCount = 0;

                            for (const importedFolder of importedData.folders) {
                                if (existingFolders.some(f => f.name === importedFolder.name)) {
                                    UIManager.showToast(`å·²è·³è¿‡ï¼šæ–‡ä»¶å¤¹ "${importedFolder.name}" å·²å­˜åœ¨`);
                                    continue;
                                }
                                
                                const oldFolderId = importedFolder.id;
                                const newFolder = {
                                    ...importedFolder,
                                    id: Utils.generateId('folder'), 
                                    createdAt: Date.now()
                                };
                                await DBHelper.put('promptFolders', newFolder);
                                
                                
                                const promptsToImport = importedData.prompts.filter(p => p.folderId === oldFolderId);
                                for (const importedPrompt of promptsToImport) {
                                    const newPrompt = {
                                        ...importedPrompt,
                                        id: Utils.generateId('prompt'), 
                                        folderId: newFolder.id, 
                                        createdAt: Date.now()
                                    };
                                    await DBHelper.put('prompts', newPrompt);
                                    importedCount++;
                                }
                            }
                            
                            UIManager.showToast(`å¯¼å…¥å®Œæˆï¼Œå…±å¯¼å…¥ ${importedCount} æ¡æç¤ºè¯`);
                            this.renderPromptsPage();

                        } catch (error) {
                            console.error("å¯¼å…¥å¤±è´¥: ", error);
                            UIManager.showToast("å¯¼å…¥å¤±è´¥ï¼Œæ–‡ä»¶å¯èƒ½å·²æŸå");
                        } finally {
                            
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            }

        };


        
        async function loadFontsAfterSplash() {
            try {
                
                await EventManager.loadCustomFontsOnStartup();
                console.log("è‡ªå®šä¹‰å­—ä½“æ–‡ä»¶å·²åœ¨åå°å‡†å¤‡å°±ç»ªã€‚");
            } catch (error) {
                console.error("åå°è‡ªå®šä¹‰å­—ä½“åŠ è½½å¤±è´¥:", error);
            }
        }

        
        async function initApp() {
            
            setTimeout(() => {
                const splash = $('#splash-screen');
                if (splash) {
                    splash.classList.add('hidden');
                    
                    setTimeout(() => {
                        splash.style.display = 'none';
                    }, 500);
                }
            }, 1500);

            try {
                
                await DBHelper.init();
                await AIHandler.loadApiConfig();

                
                let profile = await DBHelper.get('profile', 'myProfile');
                if (!profile) {
                    profile = {
                        id: 'myProfile',
                        name: 'å•†æ—¶åº',
                        gender: 'å¥³',
                        avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=',
                        background: '',
                    };
                    await DBHelper.put('profile', profile);
                }
                $('#my-avatar').src = profile.avatar;
                appState.favoriteEmojis = profile.favoriteEmojis || [];

                EventManager.init();

                const defaults = {
                    id: 'chatSettings',
                    memoryInterconnection: false,
                    historyLength: 20,
                    showMyNameInGroup: true,
                    showNamesInPrivate: false,
                    bottomBarOffset: false,
                    enterToSend: false,
                    theme: 'neumorphic',
                };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const initialChatSettings = { ...defaults, ...savedSettings };
                appState.theme = initialChatSettings.theme;
                EventManager.applyChatSettings(initialChatSettings);
                await EventManager.applyBackgroundSettings(); 
                await EventManager.applyBubbleSettings(); 
                await EventManager.applyBubbleFontSize(); 

                EventManager.loadAndApplyFontsInBackground(); 

                
                await EventManager.initEmojiPanel(); 
                await UIManager.navigateTo('messages');
                
            } catch (error) {
                console.error("åº”ç”¨åˆå§‹åŒ–å¤±è´¥:", error);
                document.body.innerHTML = `<div style="text-align:center; padding: 50px; color: red;">åº”ç”¨åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒIndexedDBæˆ–æ¸…é™¤ç½‘ç«™æ•°æ®åé‡è¯•ã€‚é”™è¯¯: ${error}</div>`;
            }
        }
        
        document.addEventListener('DOMContentLoaded', initApp);

    })();
    </script>
</body>
</html>